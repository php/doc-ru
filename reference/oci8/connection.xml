<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 5a3f0c18ac46e6d4313367e44866527badac5b73 Maintainer: mch Status: ready -->
<!-- Reviewed: no -->
<!-- $Revision$ -->
<chapter xml:id="oci8.connection" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Работа с соединениями OCI8 и Connection Pooling</title>
 <section>
  <title>Функции подключения</title>
  <para>
   Расширение OCI8 предоставляет три различных функции для подключения
   к серверу Oracle. Стандартная функция соединения - это
   <function>oci_connect</function>. Она создает соединение к базе данных
   Oracle и возвращает ресурс, который используется при последующих обращениях
   к БД.
  </para>
  <para>
   Подключение к серверу Oracle является достаточно дорогостоящей операцией
   с точки зрения времени, которое требуется для выполнения.
   Функция <function>oci_pconnect</function> использует постоянный
   кэш соединений, которые могут быть повторно использованы различными
   запросами скриптов. Это означает, что затраты на установку соединения,
   как правило, происходят только единожды на один процесс PHP
   (или на потомка Apache).
  </para>
  <para>
   Если приложение соединяется к серверу Oracle, используя особый набор
   данных для каждого веб-пользователя, то постоянный кэш соединений,
   используемый функцией <function>oci_pconnect</function> будет менее
   полезным, т.к. количество одновременных пользователей вырастает до
   того уровня, где он может начать оказывать негативное влияние на
   общую производительность сервера Oracle из-за поддержания слишком
   большого количества простаивающих соединений. Если приложение
   настроено таким образом, то рекомендуется либо настроить его с
   помощью параметров конфигурации
   <link linkend="ini.oci8.max-persistent">oci8.max_persistent</link>
   и <link linkend="ini.oci8.persistent-timeout">oci8.persistent_timeout</link>
   (это даст возможность управления размером кэша постоянных соединений и
   их время жизни), либо использовать Oracle Database
   Resident Connection Pooling (в Oracle Database 11g и новее), либо использовать функцию
   <function>oci_connect</function> вместо нее.
  </para>
  <para>
   Вместе <function>oci_connect</function>
   и <function>oci_pconnect</function> используют кэш подключений; если
   множество вызовов <function>oci_connect</function> использует одинаковые
   параметры в данном скрипте, второй и последующие вызовы вернут
   существующий дескриптор соединения. Кэш, используемый функцией
   <function>oci_connect</function>, очищается по завершению выполнения
   скрипта, или когда соединение неявно закрывается. У функции
   <function>oci_pconnect</function> похожее поведение, хотя ее кэш
   обрабатывается отдельно и остается действующим между
   запросами HTTP.
  </para>
  <para>
   Эта возможность кеширования означает, что два дескриптора не изолированы
   транзакционно (они на самом деле являются одним и тем же дескриптором, поэтому здесь
   нет никакой изоляции). Если приложению необходимы два отдельных
   транзакционно изолированных соединения, то необходимо использовать
   функцию <function>oci_new_connect</function>.
  </para>
  <para>
   Кеш функции <function>oci_pconnect</function> очищается и закрываются
   все соединения к БД, когда завершается процесс PHP. Поэтому
   эффективное использование постоянных соединений требует, чтобы PHP был
   модулем Apache или использовался с FCGI или подобным. Постоянные соединения
   не будут иметь никаких преимуществ перед <function>oci_connect</function>,
   когда PHP используется с CGI или через командную строку.
  </para>
  <para>
   Функция <function>oci_new_connect</function> всегда создает
   новое соединение с сервером Oracle, невзирая на то, что другие
   соединения могут уже существовать. Высоконагруженным веб-приложениям
   следует избегать использования <function>oci_new_connect</function>, особенно
   в самых загруженных частях приложения.
  </para>
 </section>
 <section>
  <title>Создание пула соединений DRCP</title>
  <para>
   PHP начиная с 5.3 (PECL OCI8 1.3) поддерживает постоянный пул соединений Oracle 11g
   (DRCP).  DRCP позволяет более эффективно использовать память СУБД и предоставляет
   высокую масштабируемость. Изменять код приложения для использования DRCP либо
   нет необходимости, либо требуются минимальные изменения.
  </para>
  <para>
   DRCP подходит для приложений, которые подключаются используя несколько
   схем БД и сохраняют соединения к БД открытыми короткий промежуток времени.
   Другим приложениям следует использовать доступные по умолчанию
   <literal>Dedicated</literal> серверные процессы или
   использовать <literal>Shared</literal> сервера.
  </para>
  <para>
   DRCP приносит пользу всем трем функциям подключения, однако предоставляет
   самую высокую масштабируемость, когда соединения создаются с
   помощью функции <function>oci_pconnect</function>.
  </para>
  <para>
   Чтобы функционал DRCP был доступен в OCI8, клиентские библиотеки Oracle, используемые в
   PHP, и версия сервера баз данных должны быть 11g и новее.
  </para>
  <para>
   Документация по DRCP находится в нескольких руководствах Oracle. К примеру,
   см. <link xlink:href="&url.oracle.drcp.configure;">Конфигурирование
   пула постоянных соединений базы данных</link> в документации Oracle
   для информации по использованию.
   Документ <link xlink:href="&url.oracle.drcp.whitepaper;">техническое
   описание DRCP</link> содержит дополнительную информацию по DRCP.
  </para>
  <para>
   Для использования DRCP, скомпилируйте PHP с расширением OCI8 1.3 (и новее)ы
   и библиотеками Oracle 11g (и новее) и затем выполните следующие действия:
  </para>
  <para>
   <itemizedlist>
    <listitem>
     <para>
      Как привилегированный администратор БД воспользуйтесь программой
      наподобие SQL*Plus, чтобы запустить пул соединений в СУБД:
     </para>
     <para>
      <informalexample>
       <screen>
<![CDATA[
    SQL> execute dbms_connection_pool.start_pool;
]]>
       </screen>
      </informalexample>
     </para>
    </listitem>
    <listitem>
     <para>
      Дополнительно можно использовать
   <literal>dbms_connection_pool.alter_param()</literal>,
      чтобы конфигурировать параметры DRPC. Текущие настройки пула могут быть
      получены из представления <literal>DBA_CPOOL_INFO</literal>.
     </para>
    </listitem>
    <listitem>
     <para>
      Обновите используемую строку соединения. К примеру, для приложений PHP, которые
      сейчас соединяются, используя Network Connect Name
      <literal>MYDB</literal>:
     </para>
     <para>
      <informalexample>
       <screen>
<![CDATA[
    $c = oci_pconnect("myuser", "mypassword", "MYDB");
]]>
       </screen>
      </informalexample>
     </para>
     <para>
      измените файл tnsnames.ora и добавьте
      оператор <literal>(SERVER=POOLED)</literal>, например:
     </para>
     <para>
      <informalexample>
       <screen>
<![CDATA[
    MYDB = (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp) (HOST=myhost.dom.com)
           (PORT=1521))(CONNECT_DATA=(SERVICE_NAME=sales)
           (SERVER=POOLED)))
]]>
       </screen>
      </informalexample>
     </para>
     <para>
      В качестве альтернативы можно изменить синтаксис упрощенного соединения
      в PHP и добавить туда <literal>:POOLED</literal> после имени сервиса:
     </para>
     <para>
      <informalexample>
       <screen>
<![CDATA[
    $c = oci_pconnect("myuser", "mypassword", "myhost.dom.com:1521/sales:POOLED");
]]>
       </screen>
      </informalexample>
     </para>
    </listitem>
    <listitem>
     <para>
      Отредактируйте &php.ini; и выберите имя класса соединения. Это имя
      устанавливает логическое разделение пула соединений и может использоваться,
      чтобы изолировать пул для отдельных приложений. Любое PHP-приложение
      с одинаковым именем пользователя и классом для соединения
      будет иметь возможность совместно использовать соединения в пуле, получая
      бОльшую масштабируемость.
     </para>
     <para>
      <informalexample>
       <screen>
<![CDATA[
    oci8.connection_class = "MY_APPLICATION_NAME"
]]>
       </screen>
      </informalexample>
     </para>
    </listitem>
    <listitem>
     <para>
      Запустите приложение, соединяющееся с базой 11g и новее.
     </para>
    </listitem>
    </itemizedlist>
  </para>
  <note>
   <para>
    Приложения, использующие Oracle 10g, которые требуют производительности
    от постоянных соединений, могут уменьшить количество памяти сервера БД,
    которое используется <literal>Shared</literal>-серверами Oracle
    (ранее известные как многопоточные сервера). Обратитесь к документации
    Oracle для более подробной информации.
   </para>
  </note>
 </section>
 <section>
  <title>Рекомендации по DRCP и известные ограничения</title>
  <para>
   При изменении пароля через DRCP-соединение будет выдаваться
   ошибка <emphasis>ORA-56609: Usage not supported with DRCP</emphasis>.
   Это документированное ограничение of Oracle Database 11g.
  </para>
  <para>
   Начиная с расширения OCI8 версии 1.3 постоянные соединения теперь могут быть
   закрыты пользователем. Это позволяет получить больший контроль над использованием
   ресурсов соединений. Постоянные соединения теперь будут также закрываться автоматически,
   когда отсутствует указывающая на них переменная PHP, например, в таких случаях, как
   в конце области видимости пользовательской функции PHP. Это откатит любую
   незавершенную транзакцию. Эти изменения в постоянных соединениях делают их
   поведение похожим на поведение непостоянных соединений, упрощая интерфейс и позволяя
   приложениям быть более логичными и предсказуемыми.
   Для сохранения предыдущего поведения используйте директиву
   <link linkend="ini.oci8.old-oci-close-semantics">oci8.old_oci_close_semantics</link>,
   принимающую значение <emphasis>On</emphasis> .
  </para>
  <para>
   Если СУБД Oracle версии 11.1.0.6, то для использования DRCP должен быть применен
   патч для СУБД Oracle для устранения ошибки 6474441.
   Без этого патча могут происходить ошибки, такие как <emphasis>ORA-01000: maximum
   open cursors exceeded</emphasis>, <emphasis>ORA-01001 invalid
   cursor</emphasis> или <emphasis>ORA-01002 fetch out of
   sequence</emphasis>. Эти ошибки исправлены в Oracle версии
   11.1.0.7 и более поздних.
  </para>
   <para>
   Если патч для СУБД Oracle 11.1.0.6 не может быть применен, тогда
   вместо этого можно воспользоваться тремя методами:
  </para>
  <para>
   <itemizedlist>
    <listitem>
     <simpara>
      Соединение используя Oracle <literal>Dedicated</literal>
      или <literal>Shared</literal> сервера вместо DRCP.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Установить директиву PHP <link linkend="ini.oci8.statement-cache-size">oci8.statement_cache_size</link>
      в 0.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Установить событие в файле параметров инициализации базы:
      <emphasis>event="56699 trace name context forever, level 128"</emphasis>.
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   Патч 6474441 для БД Oracle версий 11.1.0.7 и 11.1.0.6
   позволяет приложениям на PHP с DRCP-соединением использовать
   триггер базы <literal>LOGON</literal> для установки параметров сессии
   в момент ее создания. Примерами таких параметров являются язык NLS и
   формат даты.
  </para>
  <para>
   Если патч к БД Oracle 11.1.0.6 не может быть установлен, то
   можно использовать несколько методов вместо использования
   триггеров <literal>LOGON</literal>:
  </para>
  <para>
   <itemizedlist>
    <listitem>
     <simpara>
   После авторизации, явно установите свойства сессии используя
   код приложения PHP.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
   Соединитесь, используя Oracle <literal>Dedicated</literal>
   или <literal>Shared</literal> сервера вместо DRCP.
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   Автоматическое повторное установление постоянного соединения PHP
   после порождения нового процесса Apache или FGCI означает, что
   использование триггеров <literal>LOGON</literal> в PHP рекомендуется
   только для установки атрибутов сессии, а не для пользовательских запросов
   на соединение для каждого приложения. Это даже более проявляется с DRCP за
   счет автоматического изменения размера буфера соединений и со способом триггеров <literal>LOGON</literal>
   конфликтующим с DRCP аутентификацией.
  </para>
 </section>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

