<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 86d3fb841e0206e2588896ad3c21432333535848 Maintainer: malferov Status: ready -->
<!-- Reviewed: no -->
<section xmlns="http://docbook.org/ns/docbook" xml:id="pdo.constants.fetch-modes">
 <title>Режимы выборки</title>

 <simpara>
  Информацию о семействе констант курсора — <literal>PDO::FETCH_ORI_*</literal> —
  содержит раздел «<link linkend="pdo.constants.cursors">Константы курсора</link>».
 </simpara>

 <section xml:id="pdo.fetch-modes.basic" annotations="chunk:false">
  <title>Базовые режимы выборки</title>
  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Режим выборки</entry>
      <entry>Краткое описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <constant>PDO::FETCH_DEFAULT</constant>
      </entry>
      <entry>
       Служебный режим, в котором данные извлекаются в текущем режиме выборки по умолчанию.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_ASSOC</constant>
      </entry>
      <entry>
       Ассоциативный массив с индексацией только по названию столбца.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_BOTH</constant> (режим по умолчанию)
      </entry>
      <entry>
       Индексно-ассоциативный массив с индексацией как по номеру, так и по названию столбца.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_NAMED</constant>
      </entry>
      <entry>
       Вариант режима <constant>PDO::FETCH_ASSOC</constant>, в котором при дублировании названий столбцов значения не перезаписываются,
       а возвращаются в массиве.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_NUM</constant>
      </entry>
      <entry>
       Индексный массив с индексацией только по номеру столбца.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_COLUMN</constant>
      </entry>
      <entry>
       Значение или массив значений одного столбца.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_KEY_PAIR</constant>
      </entry>
      <entry>
       Массив пар «ключ — значение» с индексацией по первому столбцу.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_FUNC</constant>
      </entry>
      <entry>
       Результат вызова callback-функции.
       Режим совместим только с методом <methodname>PDOStatement::fetchAll</methodname>.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_OBJ</constant>
      </entry>
      <entry>
       Объект стандартного класса — <classname>stdClass</classname>.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_CLASS</constant>
      </entry>
      <entry>
       Объект конкретного класса.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </section>

 <section xml:id="pdo.fetch-modes.class-flags" annotations="chunk:false">
  <title>Опции режима PDO::FETCH_CLASS</title>

  <simpara>
   Опции изменяют поведение режима
   <constant>PDO::FETCH_CLASS</constant>.
  </simpara>

  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Опция</entry>
      <entry>Краткое описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <constant>PDO::FETCH_CLASSTYPE</constant>
      </entry>
      <entry>
       Опция указывает вернуть данные в объекте класса,
       название которого совпадает с названием первого столбца в запросе.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_PROPS_LATE</constant>
      </entry>
      <entry>
       Опция указывает вызвать конструктор перед установкой свойств объекта.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_SERIALIZE</constant>
      </entry>
      <entry>
       Опция указывает вернуть PHP-объект из сериализованных данных. Начиная с PHP 8.1.0 опция устарела.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </section>

 <section xml:id="pdo.fetch-modes.single" annotations="chunk:false">
  <title>Режимы с одним результатом</title>

  <simpara>
   Следующие режимы несовместимы
   с методом <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>

  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Режим выборки</entry>
      <entry>Краткое описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <constant>PDO::FETCH_BOUND</constant>
      </entry>
      <entry>
       Привязывает значения к переменным.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_INTO</constant>
      </entry>
      <entry>
       Обновляет свойства объекта.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_LAZY</constant>
      </entry>
      <entry>
       Ленивая выборка через объект <classname>PDORow</classname>, который поддерживает доступ
       к свойствам как через синтаксис доступа к элементам массива, так и через стандартный синтаксис доступа к свойствам объекта.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </section>

 <section xml:id="pdo.fetch-modes.grouped" annotations="chunk:false">
  <title>
   Флаги специфичного поведения метода <methodname>PDOStatement::fetchAll</methodname>
  </title>

  <simpara>
   Следующие режимы работают только для многострочной выборки
   методом <methodname>PDOStatement::fetchAll</methodname> и несовместимы
   с режимами выборки по другой логике. Подробности даёт полная документация.
  </simpara>

  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Режим выборки</entry>
      <entry>Краткое описание</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <constant>PDO::FETCH_GROUP</constant>
      </entry>
      <entry>
       Группирует результаты по первому столбцу.
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_UNIQUE</constant>
      </entry>
      <entry>
       Уникально индексирует результаты по первому столбцу.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </section>

 <section xml:id="pdo.fetch-modes.duplicate-names" annotations="chunk:false">
  <title>Обработка дублирующихся названий столбцов</title>
  <simpara>
   Результаты выборки иногда содержат столбцы с одинаковым названием,
   как при объединении двух таблиц с одноимёнными столбцами.
  </simpara>
  <simpara>
    Массив или объект возвращается с единственным значением из одноимённых столбцов,
    поскольку PHP-структуры — массивы и объекты — не поддерживают одинаковых названий
    ключей или свойств.
  </simpara>
  <simpara>
   Какое значение из дубликатов названий вернётся — не определено.
  </simpara>
  <simpara>
   Столбцам указывают псевдонимы, чтобы проблема дублирования названий столбцов не возникала. Например:
  </simpara>
  <informalexample>
   <programlisting role="sql">
<![CDATA[
SELECT table1.created_at AS t1_created_at,
       table2.created_at AS t2_created_at
FROM table1
JOIN table2 ON table1.table2id = table2.id
]]>
   </programlisting>
  </informalexample>
  <simpara>
   Дополнительную информацию даёт описание режимов <constant>PDO::FETCH_NAMED</constant>,
   <constant>PDO::ATTR_FETCH_TABLE_NAMES</constant>
   и <constant>PDO::ATTR_FETCH_CATALOG_NAMES</constant>.
  </simpara>
 </section>

 <section xml:id="pdo.fetch-modes.default" annotations="chunk:false">
  <title>Установка режима выборки по умолчанию</title>
  <simpara>
   Передача константы <constant>PDO::ATTR_DEFAULT_FETCH_MODE</constant>
   в параметрах метода <methodname>PDO::__construct</methodname>
   или в аргументе атрибута метода <methodname>PDO::setAttribute</methodname>
   устанавливает режим выборки по умолчанию для всех запросов.
  </simpara>
  <simpara>
   Режим выборки по умолчанию для конкретной SQL-инструкции устанавливают
   методом <methodname>PDOStatement::setFetchMode</methodname>.
   Индивидуальный режим влияет на повторное выполнение подготовленных SQL-инструкций
   и перебор результатов конструкцией &foreach;.
  </simpara>
  <caution>
   <simpara>
    Методом <methodname>PDOStatement::setAttribute</methodname> нельзя установить
    режим выборки по умолчанию для конкретного запроса. Метод принимает только атрибуты, совместимые с текущим драйвером,
    и молча игнорирует атрибуты, которые не распознал.
   </simpara>
  </caution>
 </section>

 <section xml:id="pdo.constants.fetch-default" annotations="chunk:false">
  <title>PDO::FETCH_DEFAULT (<type>int</type>)</title>
  <simpara>
   Режим доступен с PHP 8.0.7.
  </simpara>
  <simpara>
   Служебное значение, которое ссылается на текущий режим выборки по умолчанию
   для объекта <classname>PDOStatement</classname>. Константу часто указывают как значение по умолчанию
   для параметров методов пользовательских классов, которые расширяют класс
   <classname>PDOStatement</classname> и которые указывают
   через атрибут <constant>PDO::ATTR_STATEMENT_CLASS</constant> как тип для возврата результатов запроса.
  </simpara>
  <para>
   Значение нельзя указывать с атрибутом
   <constant>PDO::ATTR_DEFAULT_FETCH_MODE</constant>.
  </para>
 </section>

 <section xml:id="pdo.constants.fetch-assoc" annotations="chunk:false">
  <title>PDO::FETCH_ASSOC (<type>int</type>)</title>
  <simpara>
   В режиме <constant>PDO::FETCH_ASSOC</constant> возвращается ассоциативный массив,
   в котором ключи соответствуют названиям столбцов.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

$stmt = $pdo->query("SELECT userid, name, country FROM users");
$row = $stmt->fetch(\PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [userid] => 104
    [name] => Chris
    [country] => Ukraine
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-both" annotations="chunk:false">
  <title>PDO::FETCH_BOTH (<type>int</type>)</title>
  <simpara>
   Режим выборки по умолчанию.
  </simpara>
  <simpara>
   В режиме <constant>PDO::FETCH_BOTH</constant> возвращается индексно-ассоциативный массив,
   в котором значение каждой строки дублируется: одно возвращается со строковым ключом по названию столбца,
   другое — с числовым ключом по номеру столбца.
  </simpara>
  <simpara>
   Нумерация столбцов начинаются с 0 и определяется порядком столбцов в результатах
   запроса, а не, например, порядком определения столбцов в таблице.
  </simpara>
  <note>
   <para>
    Лучше не опираться на числовой индекс столбца, поскольку нумерация изменится
    при изменении порядка столбцов в запросе или при изменении схемы таблицы
    и запросе наподобие <literal>SELECT *</literal>.
   </para>
  </note>
  <note>
   <simpara>
    Количество записей с индексацией по названию столбца не совпадёт с количеством записей
    с индексацией по номеру столбца, если в результате возвращаются столбцы с одинаковым названием.
   </simpara>
  </note>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

$stmt = $pdo->query("SELECT userid, name, country FROM users");
$row = $stmt->fetch(\PDO::FETCH_BOTH);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [id] => 104,
    [0] => 104,
    [name] => Chris,
    [1] => Chris,
    [country] => Ukraine,
    [2] => Ukraine
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-named" annotations="chunk:false">
  <title>PDO::FETCH_NAMED (<type>int</type>)</title>
  <simpara>
   В режиме <constant>PDO::FETCH_NAMED</constant> результаты возвращаются в формате, аналогичном
   режиму <constant>PDO::FETCH_ASSOC</constant>, за исключением возврата всех значений повторных
   столбцов в виде списка.
  </simpara>
  <simpara>
   Подробнее об обработке повторных названий столбцов и альтернативах рассказывает раздел
   «<link linkend="pdo.fetch-modes.duplicate-names">Обработка дублирующихся названий столбцов</link>».
  </simpara>
  <simpara>
   Порядок возврата значений повторных столбцов не определён.
   Невозможно определить конкретный источник каждого значения.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

$stmt = $pdo->query(
    "SELECT users.*, referrer.name
     FROM users
     LEFT JOIN users AS referrer ON users.referred_by = referrer.userid
     WHERE userid = 109"
);

$row = $stmt->fetch(\PDO::FETCH_NUM);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [userid] => 109
    [name] => Array
        (
            [0] => Toni
            [1] => Chris
        )
    [country] => Germany
    [referred_by] = 104
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-num" annotations="chunk:false">
  <title>PDO::FETCH_NUM (<type>int</type>)</title>
  <simpara>
   В режиме <constant>PDO::FETCH_NUM</constant> возвращается индексный массив, в котором ключи
   соответствуют номеру столбца. Нумерация столбцов начинается с 0 и определяется порядком столбцов в результатах
   запроса, а не, например, порядком определения столбцов в таблице.
  </simpara>
  <note>
   <simpara>
    Лучше не опираться на числовой индекс столбца, поскольку нумерация изменится
    при изменении порядка столбцов в запросе или при изменении схемы таблицы
    и запросе наподобие <literal>SELECT *</literal>.
   </simpara>
  </note>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

$stmt = $pdo->query("SELECT userid, name, country FROM users");
$row = $stmt->fetch(\PDO::FETCH_NUM);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [0] => 104
    [1] => Chris
    [2] => Ukraine
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-column" annotations="chunk:false">
  <title>PDO::FETCH_COLUMN (<type>int</type>)</title>
  <simpara>
   В режиме <constant>PDO::FETCH_COLUMN</constant> возвращаются значения из одного столбца.
   При вызове метода <methodname>PDOStatement::setFetchMode</methodname>
   или <methodname>PDOStatement::fetchAll</methodname> конкретный столбец
   указывают во втором аргументе.
  </simpara>
  <simpara>
   Метод выбросит ошибку <classname>ValueError</classname>,
   если таблица не содержит заданный столбец.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

$stmt = $pdo->query("SELECT name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_COLUMN);
print_r($row);

$stmt = $pdo->query("SELECT name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_COLUMN, 1);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [0] => Chris
    [1] => Jamie
    [2] => Robin
)

Array
(
    [0] => Ukraine
    [1] => England
    [2] => Germany
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-key-pair" annotations="chunk:false">
  <title>PDO::FETCH_KEY_PAIR (<type>int</type>)</title>
  <simpara>
   В режиме <constant>PDO::FETCH_KEY_PAIR</constant> возвращается массив пар «ключ — значение»,
   в котором ключи соответствуют первому столбцу. В этом режиме в запросе указывают только 2 столбца.
   Режим выборки вернёт осмысленные результаты только при вызове метода <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>
  <note>
   <simpara>
    Значения потеряются, если первый столбец содержит неуникальные значения. Невозможно определить,
    какое значение или какие значения теряются.
   </simpara>
  </note>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

$stmt = $pdo->query("SELECT name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_KEY_PAIR);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [Chris] => Ukraine
    [Jamie] => England
    [Robin] => Germany
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-func" annotations="chunk:false">
  <title>PDO::FETCH_FUNC (<type>int</type>)</title>
  <simpara>
   В этом режиме возвращается значение, которое вернёт функция обратного вызова.
   Режим работает только с методом <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>
  <simpara>
   Значения столбцов становятся аргументами функции.
   По значениям аргументов невозможно получить названия столбцов.
   При определении пользовательской функции проверяют соответствие порядка столбцов в запросе
   порядку параметров функции.
  </simpara>
  <note>
   <simpara>
    Режим <constant>PDO::FETCH_GROUP</constant> группирует,
    а режим <constant>PDO::FETCH_UNIQUE</constant> уникализирует результаты выборки
    до вызова пользовательской функции обратного вызова.
   </simpara>
  </note>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

function valueCreator($col1, $col2, $col3)
{
    return [
        'col1' => $col1,
        'col2' => strtoupper($col2),
        'col3' => $col3,
        'customKey' => 'customValue',
    ];
}

$stmt = $pdo->query("SELECT userid, name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_FUNC, valueCreator(...));
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [0] => Array
        (
            [col1] => 104
            [col2] => SAM
            [col3] => Ukraine
            [customKey] => customValue
        )

    [1] => Array
        (
            [col1] => 105
            [col2] => JAMIE
            [col3] => England
            [customKey] => customValue
        )

    [2] => Array
        (
            [col1] => 107
            [col2] => ROBIN
            [col3] => Germany
            [customKey] => customValue
        )

)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-obj" annotations="chunk:false">
  <title>PDO::FETCH_OBJ (<type>int</type>)</title>
  <simpara>
   В режиме <constant>PDO::FETCH_OBJ</constant> возвращается объект <classname>stdClass</classname>.
  </simpara>
  <simpara>
   См. также описания метода <methodname>PDOStatement::fetchObject</methodname>
   и режима <constant>PDO::FETCH_CLASS</constant>.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

$stmt = $pdo->query("SELECT userid, name, country FROM users");
$row = $stmt->fetch(\PDO::FETCH_OBJ);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
stdClass Object
(
    [userid] => 104
    [name] => Chris
    [country] => Ukraine
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-class" annotations="chunk:false">
  <title>PDO::FETCH_CLASS (<type>int</type>)</title>
  <simpara>
   В этом режиме возвращается объект заданного класса. Дополнительную информацию о поведении
   даёт описание <link linkend="pdo.fetch-modes.class-flags">флагов опций</link>.
  </simpara>
  <simpara>
   Свойство объявится динамически, если класс не содержит свойства с названием возвращаемого столбца.
   Объявление динамических свойств устарело и начиная с PHP 9.0 вызовет ошибку.
  </simpara>
  <simpara>
   См. также описание метода <methodname>PDOStatement::fetchObject</methodname>.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

class TestEntity
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;

    public function __construct()
    {
        print "Конструктор вызвали со следующим количеством аргументов: " . count(func_get_args()) . "\n";
        print "Свойства устанавливаются до вызова конструктора? "
            . (isset($this->name) ? 'Да' : 'Нет') . "\n";
    }
}

$stmt = $db->query(
    "SELECT userid, name, country, referred_by_userid FROM users"
);

$stmt->setFetchMode(PDO::FETCH_CLASS, TestEntity::class);

$result = $stmt->fetch();

var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Конструктор вызвали со следующим количеством аргументов: 0
Свойства устанавливаются до вызова конструктора? Да
object(TestEntity)#3 (4) {
  ["userid"]=>
  int(104)
  ["name"]=>
  string(5) "Chris"
  ["country"]=>
  string(7) "Ukraine"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-classtype" annotations="chunk:false">
  <title>PDO::FETCH_CLASSTYPE (<type>int</type>)</title>
  <simpara>
   Опция работает только в сочетании с режимом
   <constant>PDO::FETCH_CLASS</constant>
   <link linkend="pdo.fetch-modes.class-flags">и другими опциями режима</link>.
  </simpara>
  <simpara>
   С этой опцией модуль PDO возвращает данные в объекте класса, название которого
   совпадает с названием первого столбца в запросе.
  </simpara>
  <simpara>
   Модуль вернет объект <classname>stdClass</classname>, без выдачи предупреждения или ошибки,
   если заданный класс недоступен.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

class TestEntity
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;

    public function __construct()
    {
        print "Конструктор вызвали со следующим количеством аргументов: " . count(func_get_args()) . "\n";
        print "Свойства устанавливаются до вызова конструктора? "
            . (isset($this->name) ? 'Да' : 'Нет') . "\n";
    }
}

$stmt = $db->query(
    "SELECT 'TestEntity', userid, name, country, referred_by_userid FROM users"
);

$stmt->setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_CLASSTYPE);

$result = $stmt->fetch();

var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Конструктор вызвали со следующим количеством аргументов: 0
Свойства устанавливаются до вызова конструктора? Да
object(TestEntity)#3 (4) {
  ["userid"]=>
  int(104)
  ["name"]=>
  string(5) "Chris"
  ["country"]=>
  string(7) "Ukraine"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-props-late" annotations="chunk:false">
  <title>PDO::FETCH_PROPS_LATE (<type>int</type>)</title>
  <simpara>
   Опция работает только в сочетании с режимом
   <constant>PDO::FETCH_CLASS</constant>
   <link linkend="pdo.fetch-modes.class-flags">и другими опциями режима</link>.
  </simpara>
  <simpara>
   С этой опцией конструктор вызывается до установки свойств.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

class TestEntity
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;

    public function __construct()
    {
        print "Конструктор вызвали со следующим количеством аргументов: " . count(func_get_args()) . "\n";
        print "Свойства устанавливаются до вызова конструктора? "
            . (isset($this->name) ? 'Да' : 'Нет') . "\n";
    }
}

$stmt = $db->query(
    "SELECT userid, name, country, referred_by_userid FROM users"
);

$stmt->setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE, TestEntity::class);

$result = $stmt->fetch();
var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Конструктор вызвали со следующим количеством аргументов: 0
Свойства устанавливаются до вызова конструктора? Нет
object(TestEntity)#3 (4) {
  ["userid"]=>
  int(104)
  ["name"]=>
  string(5) "Chris"
  ["country"]=>
  string(7) "Ukraine"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-serialize" annotations="chunk:false">
  <title>PDO::FETCH_SERIALIZE (<type>int</type>)</title>
  &warn.deprecated.feature-8-1-0;
  <simpara>
   Режим выборки работает только в сочетании
   с режимом <constant>PDO::FETCH_CLASS</constant>
   <link linkend="pdo.fetch-modes.class-flags">и опциями режима</link>.
  </simpara>
  <simpara>
   Режим устанавливают только с классами, которые реализуют
   интерфейс <interfacename>Serializable</interfacename>.
  </simpara>
  <caution>
   <simpara>
    Режим не поддерживает сами строки с результатом сериализации объекта,
    как это делает функция <function>serialize</function>.
   </simpara>
  </caution>
  <caution>
   <para>
    Режим выборки не вызывает конструктор.
   </para>
  </caution>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

class TestEntity implements Serializable
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;

    public function __construct()
    {
        print "Конструктор вызвали со следующим количеством аргументов: " . count(func_get_args()) . "\n";
        print "Свойства устанавливаются до вызова конструктора? "
            . (isset($this->name) ? 'Да' : 'Нет') . "\n";
    }

    public function serialize()
    {
        return join(
            "|",
            [$this->userid, $this->name, $this->country, $this->referred_by_userid]
        );
    }

    public function unserialize(string $data)
    {
        $parts = explode("|", $data);
        $this->userid = (int) $parts[0];
        $this->name = $parts[1];
        $this->country = $parts[2];

        $refId = $parts[3];
        $this->referred_by_userid = ($refId === "" ? null : (int) $refId);
    }
}

print "Настройка записи (конструктор вызывается вручную):\n";
$db->exec(
    "CREATE TABLE serialize (
        sdata TEXT
    )"
);

$origObj = new TestEntity();
$origObj->userid = 200;
$origObj->name = 'Seri';
$origObj->country = 'Syria';
$origObj->referred_by_userid = null;

$insert = $db->prepare("INSERT INTO serialize (sdata) VALUES (:sdata)");
$insert->execute(['sdata' => $origObj->serialize()]);

print "\nПолучаем результат:\n";

$query = "SELECT sdata FROM serialize";

$stmt = $db->query($query);

// ПРИМЕЧАНИЕ: Конструктор не вызывается!
$stmt->setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_SERIALIZE, TestEntity::class);

$result = $stmt->fetch();

var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Deprecated: TestEntity implements the Serializable interface, which is deprecated. Implement __serialize() and __unserialize() instead (or in addition, if support for old PHP versions is necessary) in Standard input code on line 2
Настройка записи (конструктор вызывается вручную):
Конструктор вызвали со следующим количеством аргументов: 0
Свойства устанавливаются до вызова конструктора? Нет

Получаем результат:
Deprecated: PDOStatement::setFetchMode(): The PDO::FETCH_SERIALIZE mode is deprecated in Standard input code on line 58

Deprecated: PDOStatement::fetch(): The PDO::FETCH_SERIALIZE mode is deprecated in Standard input code on line 59
object(TestEntity)#5 (4) {
  ["userid"]=>
  int(200)
  ["name"]=>
  string(4) "Seri"
  ["country"]=>
  string(5) "Syria"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-bound" annotations="chunk:false">
  <title>PDO::FETCH_BOUND (<type>int</type>)</title>
  <simpara>
   Опция несовместима с методом
   <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>
  <simpara>
   С этой опцией модуль не возвращает результат напрямую, а привязывает значения к переменным,
   которые указали методом <methodname>PDOStatement::bindColumn</methodname>.
   Вызов метода выборки возвращает значение &true;.
  </simpara>
  <note>
   <para>
    Для корректной работы подготовленных SQL-инструкций переменные привязывают
    после выполнения запроса.
   </para>
  </note>
  <programlisting role="php">
<![CDATA[
<?php

$query = "SELECT users.userid, users.name, users.country, referrer.name
    FROM users
    LEFT JOIN users AS referrer ON users.referred_by_userid = referrer.userid";
$stmt = $db->prepare($query);
$stmt->execute();

$stmt->bindColumn('userid', $userId);
$stmt->bindColumn('name', $name);
$stmt->bindColumn('country', $country);
// Связываем переменную по позиции столбца, чтобы разрешить дублирование названия столбца.
// А лучше вместо названия столбца указать в SQL-запросе псевдоним,
// чтобы не сломать привязку при изменении запроса,
// например: referrer.name AS referrer_name
$stmt->bindColumn(4, $referrerName);

while ($stmt->fetch(\PDO::FETCH_BOUND)) {
    print join("\t", [$userId, $name, $country, ($referrerName ?? 'NULL')]) . "\n";
}
]]>
  </programlisting>
  &example.outputs;
  <screen>
<![CDATA[
104	Chris	Ukraine	NULL
105	Jamie	England	NULL
107	Robin	Germany	Chris
108	Sean	Ukraine	NULL
109	Toni	Germany	NULL
110	Toni	Germany	NULL
]]>
  </screen>
 </section>

 <section xml:id="pdo.constants.fetch-into" annotations="chunk:false">
  <title>PDO::FETCH_INTO (<type>int</type>)</title>
  <simpara>
   Режим выборки несовместим с методом
   <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>
  <simpara>
   Режим выборки обновляет свойства заданного объекта. Метод выборки возвращает объект,
   если выполнился успешно.
  </simpara>
  <simpara>
   Свойство объявится динамически, если класс не содержит свойства с названием возвращаемого столбца.
   Объявление динамических свойств устарело и начиная с PHP 9.0 вызовет ошибку.
  </simpara>
  <simpara>
   В этом режиме обновляются только свойства с модификатором <literal>public</literal>, а защищённые и закрытые свойства
   игнорируются, попытка обновить свойство с модификатором <literal>readonly</literal> вызовет фатальную ошибку.
  </simpara>
  <caution>
   <simpara>
    Невозможно изменить обновляемый объект без вызова метода
    <methodname>PDOStatement::setFetchMode</methodname> между извлечением каждой записи.
   </simpara>
  </caution>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

class TestEntity
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;
}

$obj = new TestEntity();
$stmt->setFetchMode(\PDO::FETCH_INTO, $obj);

$stmt = $db->query("SELECT userid, name, country, referred_by_userid FROM users");
$result = $stmt->fetch();
var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
object(TestEntity)#3 (4) {
  ["userid"]=>
  int(104)
  ["name"]=>
  string(5) "Chris"
  ["country"]=>
  string(7) "Ukraine"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-lazy" annotations="chunk:false">
  <title>PDO::FETCH_LAZY (<type>int</type>)</title>
  <simpara>
   Режим выборки несовместим с методом
   <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>
  <simpara>
   Режим возвращает объект <classname>PDORow</classname>, который поддерживает доступ к свойствам
   как через синтаксис доступа к элементам массива, так и через синтаксис доступа к свойствам объекта, сочетая поведение
   режимов <constant>PDO::FETCH_BOTH</constant> и <constant>PDO::FETCH_OBJ</constant>.
   В этом режиме при извлечении очередной строки метод подготавливает объект с результатами
   «ленивым» способом — не создаёт новый экземпляр, а обновляет значения свойств в том же объекте.
  </simpara>
  <simpara>
   Ленивое извлечение повышает эффективность доступа к небуферизованным результатам на сервере
   баз данных, с точки зрения работы с памятью на стороне PHP. Буферизует ли модуль PDO результаты на клиентской
   стороне, зависит от специфичного для базы данных драйвера и его конфигурации.
  </simpara>
  <caution>
   <simpara>
    При доступе к неопределённым свойствам или ключам объект <classname>PDORow</classname>
    вернет значение <literal>NULL</literal>, без ошибки или предупреждения.
    Это затруднит обнаружение и отладку ошибок, которые возникают из-за опечаток, или запросов, которые не возвращают ожидаемые данные.
   </simpara>
  </caution>
  <caution>
   <simpara>
    Возвращаемый объект <classname>PDORow</classname> обновляется каждый раз
    при извлечении результата.
   </simpara>
  </caution>
  <programlisting role="php">
<![CDATA[
<?php

$stmt = $db->query("SELECT userid, name, country, referred_by_userid FROM users");
$result = $stmt->fetch(\PDO::FETCH_LAZY);

print "ID: " . $result[0] . "\n";
print "Name: {$result->name}\n";
print "Country: " . $result['country'] . "\n";
// Возвращается NULL. Без выдачи предупреждения или ошибки.
print "Неопределённое свойство: " . var_export($result->does_not_exist, true) . "\n";

$differentResult = $stmt->fetch(\PDO::FETCH_LAZY);
// Предыдущий объект PDORow теперь указывает на вновь извлечённый результат
print "ID: " . $result[0] . "\n";
]]>
  </programlisting>
  &example.outputs;
  <screen>
<![CDATA[
ID: 104
Name: Chris
Country: Ukraine
Неопределённое свойство: NULL
ID: 105
]]>
  </screen>
 </section>

 <section xml:id="pdo.constants.fetch-group" annotations="chunk:false">
  <title>PDO::FETCH_GROUP (<type>int</type>)</title>
  <simpara>
   В режиме <constant>PDO::FETCH_GROUP</constant> возвращаются списки ассоциативных массивов,
   ключами которых становятся значения первого столбца. Для уникальных столбцов возвращаются списки из одной записи,
   поэтому установка режима становится оправданной только при группировке результатов по неуникальному столбцу.
   Режим выборки работает только с методом <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>
  <simpara>
   При объединении с режимом <constant>PDO::FETCH_UNIQUE</constant>
   оба проиндексируют результаты выборки по одному и тому же столбцу, поэтому сочетание режимов бесполезно.
  </simpara>
  <simpara>
   Режим выборки с группировкой по первому столбцу комбинируют со следующими режимами:
   <constant>PDO::FETCH_ASSOC</constant>, <constant>PDO::FETCH_BOTH</constant>,
   <constant>PDO::FETCH_NAMED</constant>, <constant>PDO::FETCH_NUM</constant>,
   <constant>PDO::FETCH_COLUMN</constant>
   или <constant>PDO::FETCH_FUNC</constant>.
  </simpara>
  <simpara>
   Объект <classname>PDOStatement</classname> обработает результаты в режиме выборки по умолчанию,
   если для режима группировки не задали режим из приведённого списка.
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

$stmt = $pdo->query("SELECT country, userid, name FROM users");
$row = $stmt->fetchAll(\PDO::FETCH_GROUP | \PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [Ukraine] => Array
        (
            [0] => Array
                (
                    [userid] => 104
                    [name] => Chris
                )

            [1] => Array
                (
                    [userid] => 108
                    [name] => Sean
                )

        )
    [England] => Array
        (
            [0] => Array
                (
                    [userid] => 105
                    [name] => Jamie
                )

        )

    [Germany] => Array
        (
            [0] => Array
                (
                    [userid] => 107
                    [name] => Robin
                )

            [1] => Array
                (
                    [userid] => 109
                    [name] => Toni
                )
        )
)
]]>
   </screen>
  </informalexample>
  <simpara>
   В приведённом примере массивы со значениями построчных результатов не включают первый столбец,
   который доступен только как ключ. Для включения в состав массива
   название столбца повторяют в запросе, как в следующем примере:
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

$stmt = $pdo->query("SELECT country, userid, name, country FROM users");
$row = $stmt->fetchAll(\PDO::FETCH_GROUP | \PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [Ukraine] => Array
        (
            [0] => Array
                (
                    [userid] => 104
                    [name] => Chris
                    [country] => Ukraine
                )

            [1] => Array
                (
                    [userid] => 108
                    [name] => Sean
                    [country] => Ukraine
                )

        )
    [England] => Array
        (
            [0] => Array
                (
                    [userid] => 105
                    [name] => Jamie
                    [country] => England
                )

        )

    [Germany] => Array
        (
            [0] => Array
                (
                    [userid] => 107
                    [name] => Robin
                    [country] => Germany
                )

            [1] => Array
                (
                    [userid] => 109
                    [name] => Toni
                    [country] => Germany
                )
        )
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-unique" annotations="chunk:false">
  <title>PDO::FETCH_UNIQUE (<type>int</type>)</title>
  <simpara>
   В режиме <constant>PDO::FETCH_UNIQUE</constant> возвращается массив, в котором записи индексируются по первому столбцу,
   и возвращается только одна запись для значения индекса. Режим выборки работает только
   с методом <methodname>PDOStatement::fetchAll</methodname>.
  </simpara>
  <simpara>
   При объединении с режимом <constant>PDO::FETCH_GROUP</constant>
   оба проиндексируют результаты выборки по одному и тому же столбцу, поэтому сочетание режимов бесполезно.
  </simpara>
  <simpara>
   Режим выборки с уникализацией по первому столбцу комбинируют со следующими режимами:
   <constant>PDO::FETCH_ASSOC</constant>, <constant>PDO::FETCH_BOTH</constant>,
   <constant>PDO::FETCH_NAMED</constant>, <constant>PDO::FETCH_NUM</constant>,
   <constant>PDO::FETCH_COLUMN</constant>
   или <constant>PDO::FETCH_FUNC</constant>.
  </simpara>
  <simpara>
   Объект <classname>PDOStatement</classname> обработает результаты в режиме выборки по умолчанию,
   если для режима уникализации не задали режим из приведённого списка.
  </simpara>
  <simpara>
   При работе с уникальным столбцом наподобие ID
   режим быстро возвращает результаты, поскольку БД содержит индекс для такого значения.
  </simpara>
  <note>
   <simpara>
    При выборке из неуникальных столбцов значения потеряются. Невозможно определить,
    какое значение или какие значения теряются.
   </simpara>
  </note>
  <caution>
   <simpara>
    Фильтрацию записей лучше выполнять в SQL-запросе, когда возможно. База данных
    построит план запроса с учётом индексов, чтобы оптимизировать фильтрацию и вернуть только искомые записи.
    Выборка из базы данных избыточного количества записей значительно
    увеличивает потребление памяти и время выполнения запроса для более крупных наборов данных с результатами запроса.
   </simpara>
  </caution>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

$stmt = $pdo->query("SELECT userid, name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_UNIQUE | \PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [104] => Array
        (
            [name] => Chris
            [country] => Ukraine
        )

    [105] => Array
        (
            [name] => Jamie
            [country] => England
        )

    [107] => Array
        (
            [name] => Robin
            [country] => Germany
        )

)
]]>
   </screen>
  </informalexample>
  <simpara>
   В приведённом примере массивы со значениями построчных результатов не включают первый столбец,
   который доступен только как ключ. Для включения в состав массива
   название столбца повторяют в запросе, как в следующем примере:
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

$stmt = $pdo->query("SELECT userid, userid, name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_UNIQUE | \PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [104] => Array
        (
            [userid] => 104
            [name] => Chris
            [country] => Ukraine
        )

    [105] => Array
        (
            [userid] => 105
            [name] => Jamie
            [country] => England
        )

    [107] => Array
        (
            [userid] => 107
            [name] => Robin
            [country] => Germany
        )

)
]]>
   </screen>
  </informalexample>
 </section>

</section>
<!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"~/.phpdoc/manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 vim600: syn=xml fen fdm=syntax fdl=2 si
 vim: et tw=78 syn=sgml
 vi: ts=1 sw=1
 -->
