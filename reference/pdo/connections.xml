<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: a56106f69198dfe88c6084593c78a71c26b24353 Maintainer: tmn Status: ready -->
<!-- Reviewed: no -->
<!-- $Revision: $ -->

<chapter xml:id="pdo.connections" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Подключения и Управление подключениями</title>
 <para>
  Соединения устанавливаются автоматически при создании объекта PDO от
  его базового класса. Не имеет значения, какой драйвер вы хотите использовать;
  все что требуется, это имя базового класса. Конструктор класса принимает
  аргументы для задания источника данных (DSN), а также необязательные
  имя пользователя и пароль (если есть).
 </para>
 <para>
  <example>
   <title>Подключение к MySQL</title>
   <programlisting role="php">
<![CDATA[
<?php
$dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass);
?>
]]> 
   </programlisting>
  </example>
 </para>
 <para>
  В случае ошибки при подключении будет выброшено исключение
  <literal>PDOException</literal>. Его можно перехватить и обработать, либо
  оставить на откуп глобальному обработчику ошибок, который вы задали
  функцией <function>set_exception_handler</function>.
 </para>
 <para>
  <example><title>Обработка ошибок подключения</title>
   <programlisting role="php">
<![CDATA[
<?php
try {
    $dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass);
    foreach($dbh->query('SELECT * from FOO') as $row) {
        print_r($row);
    }
    $dbh = null;
} catch (PDOException $e) {
    print "Error!: " . $e->getMessage() . "<br/>";
    die();
}
?>
]]>
   </programlisting>
  </example>
 </para>
 <warning>
  <para>
   Если ваше приложение не перехватывает исключение PDO конструктора, движок
   zend выполнит стандартные операции для завершения работы скрипта и вывода
   обратной трассировки. В этой трассировке будет содержаться детальная
   информация о соединении с базой данных, включая имя пользователя и пароль.
   Ответственность за перхват исключений лежит на вас. Перехватить исключение
   можно явно (с помощью выражения <literal>catch</literal>), либо неявно, задав
   глобальный обработчик ошибок функцией
   <function>set_exception_handler</function>.
  </para>
 </warning>
 <para>
  При успешном подключении к базе данных в скрипт будет возвращен созданный
  PDO объект. Соединение остается активным на протяжении всего времени жизни
  объекта. Чтобы закрыть соединение, необходимо уничтожить объект путем удаления
  всех ссылок на него (этого можно добиться, присваивая &null; всем переменным,
  указывающим на объект). Если не сделать этого явно, PHP автоматически
  закроет соединение по окончании работы скрипта.
 </para>
 <para>
  <example>
   <title>Закрытие соединения</title>
   <programlisting role="php">
<![CDATA[
<?php
$dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass);
// здесь мы каким-то образом используем соединение


// соединение больше не нужно, закрываем
$dbh = null;
?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  Во многих приложениях может оказаться полезным использование постоянных
  соединений к базам данных. Постоянные соединения не закрываются при
  завершении работы скрипта, они кэшируются и используются повторно,
  когда другой скрипт запрашивает соединение с теми же учетными данными.
  Постоянные соединения позволяют избежать создания новых подключений каждый
  раз, когда требуется обмен данными с базой, что в результате дает прирост
  скорости работы таких приложений.
 </para>
 <para>
  <example>
   <title>Постоянные соединения</title>
   <programlisting role="php">
<![CDATA[
<?php
$dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass, array(
    PDO::ATTR_PERSISTENT => true
));
?>
]]>
   </programlisting>
  </example>
 </para>
 <note>
  <para>
   Чтобы использовать постоянные соединения, необходимо добавить константу
   <constant>PDO::ATTR_PERSISTENT</constant> в массив параметров драйвера,
   который передается конструктору PDO. Если просто задать этот атрибут
   функцией <function>PDO::setAttribute</function> уже после создания объекта,
   драйвер не будет использовать постоянные соединения.
  </para>
 </note>
 <note>
  <para>
   Если вы используете PDO ODBC драйвер и ваши ODBC библиотеки поддерживают
   объединение подключений в пул (ODBC Connection Pooling) (unixODBC и Windows
   точно поддерживают, но могут быть и другие), то рекомендуется вместо постоянных
   соединений пользоваться этим пулом. Пул подключений ODBC доступен всем модулям
   текущего процесса; если PDO сам кэширует соединение, то это соединение
   будет недоступно другим модулям и не попадет в пул. В результате каждый модуль
   будет создавать дополнительные подключения для своих нужд.
  </para>
 </note>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
 
