<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 8b6d169424ff189bb563ef4c3f35f8adff3f42c5 Maintainer: rjhdby Status: ready -->
<!-- Reviewed: no -->
<!-- $Revision$ -->
<chapter xml:id="svm.examples" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 &reftitle.examples;
 
 <para>
  Процесс довольно прост: задаем параметры, предоставляем обучающие данные,
  на основе которых будет создана модель, а затем делаем прогнозы, основанные
  на этой модели. Набор параметров по умолчанию гарантирует получение
  хоть какого-то результата практически для любых входных данных, так что
  на нем останавливаться не будем и сразу перейдем к обучающим данным.
 </para>
 <para>
  Есть три пути предоставления обучающих данных: файл, поток и массив.
  Если данные предоставляются с помощью файла или потока, то на каждой
  строке должен содержаться один обучающий пример, отформатированный
  следующим образом: в начале должно быть целое число  (обычно 1 или -1),
  это число обозначается термином "класс", а следом за ним перечисление пар 
  признак:значение в порядке увеличения признака. Признаки должны быть 
  целыми числами, а их значения рациональными, обычно на диапазоне 0-1. 
  Например:
 </para>
 <para>
  -1 1:0.43 3:0.12 9284:0.2
 </para>
 <para>
  В проблеме классификации документов, например при проверке письма на спам,
  каждая строка должна представлять один документ. Для задачи проверки на спам
  нам понадобится два класса, -1 для спама и 1 для нормального письма.
  Каждый признак должен означать некое слово, а его значение - важность
  данного слова в документе (возможно частота появления относительно длины 
  элемента). Признаки со значением 0 (т.е. слово в документе не встречается)
  просто не включаем в набор.
 </para>
 <para>
  В случае использования массива, данные должны быть представлены в
  виде массива массивов, в котором каждый вложенный массив должен 
  первым элементом содержать класс, а все последующие элементы
  содержать пары "признак" => "значение".
 </para>
 <para>
  Эти данные передаются обучающей функции класса SVM, которая в результате
  вернет модель (SVMModel).
 </para>
 <para>
  Созданная модель может использоваться для построения предположений
  о классе новых объектов, описанных признаками и их значениями.
  Данные, на основе которых делаются предположения, должны быть
  переданы функции модели в том же формате, что описан выше, но
  без указания их класса (т.е. без первого элемента), которая вернет
  предполагаемый класс, подходящий под эти данные.
 </para>
 <para>
  Модель в последствии можно сохранять и загружать с помощью функций,
  принимающих путь к файлу в качестве параметра.
 </para>
 <para>
  <example>
   <title>Обучение из массива</title>
   <programlisting role="php">
<![CDATA[
<?php
$data = array(
    array(-1, 1 => 0.43, 3 => 0.12, 9284 => 0.2),
    array(1, 1 => 0.22, 5 => 0.01, 94 => 0.11),
);

$svm = new SVM();
$model = $svm->train($data);

$data = array(1 => 0.43, 3 => 0.12, 9284 => 0.2);
$result = $model->predict($data);
var_dump($result);
$model->save('model.svm');
?>
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
int(-1)
]]>
   </screen>
  </example>
  <example>
   <title>Обучение из файла</title>
   <programlisting role="php">
<![CDATA[
<?php
$svm = new SVM();
$model = $svm->train("traindata.txt");
?>
]]>
   </programlisting>
  </example>
 </para>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

