<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: ee4558e955136c5a1dd8d6c34a61d786977ffd1c Maintainer: rjhdby Status: ready -->
<!-- Reviewed: no -->

<chapter xml:id="mysqlnd-ms.setup" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 &reftitle.setup;
 
 <section xml:id="mysqlnd-ms.requirements">
  &reftitle.required;
  <para>
   <literal>PHP 5.3.6</literal> или новее.
   Некоторая продвинутая функциональность требует <literal>PHP 5.4.0</literal> или новее.
  </para>
  <para>
   Плагин репликации и распределения нагрузки <literal>mysqlnd_ms</literal> 
   поддерживается всеми приложениями PHP и всеми доступными расширениями PHP MySQL
   (<link linkend="ref.mysqli">mysqli</link>,
   <link linkend="ref.mysql">mysql</link>,
   <link linkend="ref.pdo-mysql">PDO_MYSQL</link>).
   Расширения PHP MySQL должны быть сконфигурированы с поддержкой
   <link linkend="book.mysqlnd">mysqlnd</link>, чтобы можно было использовать
   плагин <literal>mysqlnd_ms</literal> для
   <link linkend="book.mysqlnd">mysqlnd</link>.
  </para>
 </section>
 
 &reference.mysqlnd-ms.configure;
 &reference.mysqlnd-ms.ini;
 
 <section xml:id="mysqlnd-ms.plugin-ini-json">
  <title xmlns="http://docbook.org/ns/docbook">Файл настроек плагина (&gt;=1.1.x)</title>
  
  <para>
   Следующая документация относится к PECL/mysqlnd_ms &gt;= 1.1.0-beta.
   Она не подходит для более ранних версий. Документация для более ранних
   версий содержится в разделе
   <link linkend="mysqlnd-ms.plugin-ini-v1">mysqlnd_ms 1.0.x и ниже</link>.
  </para>
  
  <section xml:id="mysqlnd-ms.plugin-ini-json-introduction">
   <title>Введение</title>
   
   
   <note>
    <title>Список изменений: Функционал добавленный в PECL/mysqlnd_ms 1.1.0-beta</title>
    <para>
     Следующая документация относится к PECL/mysqlnd_ms &gt;= 1.1.0-beta.
     Она не подходит для более ранних версий.
    </para>
   </note>
   
   <para>
    Плагин использует собственный файл конфигурации.
    Файл конфигурации содержит информацию о главном сервере репликации MySQL, 
    подчинённых серверах репликации MySQL, политике выбора сервера 
    (балансировка нагрузки), стратегии обработки отказов и использовании
    ленивых соединений.
   </para>
   <para>
    Плагин загружает свой файл конфигурации в начале веб-запроса. Затем он кешируется 
    в памяти и используется в течение всей обработки запроса. Таким образом, нет
    необходимости перезапускать PHP после изменения файла конфигурации. 
    Изменения в конфигурационном файле станут активными почти мгновенно.
   </para>
   <para>
    Для определения конфигурационного файла используется директива конфигурации PHP
    <link linkend="ini.mysqlnd-ms.config-file"><literal>mysqlnd_ms.config_file</literal></link>.
    Обратите внимание, что эта директива не будет повторно прочитана для обработки каждого
    нового веб-запроса. Таким образом, при изменении имени или местоположения
    файла конфигурации потребуется перезагрузка PHP. Однако, если имя и путь
    файла остались прежними, то все изменения в нем будут применены.
   </para>
   <para>
    Использование и разбор <acronym>JSON</acronym> достаточно эффективно, и
    использование <acronym>JSON</acronym> позволяет создать иерархические структуры
    данных намного легче, в отличие от стандартного файла <filename>php.ini</filename>.
   </para>
   <para>
    <example>
     <title>Преобразование массива PHP в формат JSON</title>
     <para>
      Или в качестве альтернативы, если есть желание, можно использовать синтаксис массивов PHP.
      В этом примере показан процесс преобразования массива в формат
      <acronym>JSON</acronym>.
     </para>
     <programlisting role="php">
<![CDATA[
<?php
$config = array(
  "myapp" => array(
    "master" => array(
      "master_0" => array(
        "host"   => "localhost",
        "socket" => "/tmp/mysql.sock",
      ),
    ),
    "slave" => array(),
  ),
);

file_put_contents("mysqlnd_ms.ini", json_encode($config, JSON_PRETTY_PRINT));
printf("Файл mysqlnd_ms.ini создан...\n");
printf("Сброс содержимого файла...\n");
printf("%s\n", str_repeat("-", 80));
echo file_get_contents("mysqlnd_ms.ini");
printf("\n%s\n", str_repeat("-", 80));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Файл mysqlnd_ms.ini создан...
Сброс содержимого файла...
--------------------------------------------------------------------------------
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": [

        ]
    }
}
--------------------------------------------------------------------------------
]]>
    </screen>
   </example>
   </para>
   <para>
    Конфигурационный файл плагина состоит из одной или более секций.
    Секции представлены свойствами самого верхнего уровня в дереве
    <acronym>JSON</acronym>. Секции также можно назвать
    <emphasis>именами конфигураций</emphasis>.
   </para>
   <para>
    Приложения ссылаются на секции по их имени. Приложения используют имена
    секций в качестве параметра хоста (сервера) в методах создания соединения
    расширений <link linkend="ref.mysqli">mysqli</link>,
    <link linkend="ref.mysql">mysql</link> и
    <link linkend="ref.pdo-mysql">PDO_MYSQL</link>. После подключения
    плагин <link linkend="book.mysqlnd">mysqlnd</link> сравнивает имя хоста со
    всеми именами секций из файла конфигурации плагина. Если совпадение найдено, то
    будут загружены настройки для этой секции.
   </para>
   <para xml:id="mysqlnd-ms.plugin-ini-json.using-section">
    <example>
     <title>Пример использования имён секций</title>
     <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27"
            },
            "slave_1": {
                "host": "192.168.2.27",
                "port": 3306
            }
        }
    },
    "localhost": {
        "master": [
            {
                "host": "localhost",
                "socket": "\/path\/to\/mysql.sock"
            }
        ],
        "slave": [
            {
                "host": "192.168.3.24",
                "port": "3305"
            },
            {
                "host": "192.168.3.65",
                "port": "3309"
            }
        ]
    }
}
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* Все эти соединения будут использовать распределение нагрузки */
$mysqli = new mysqli("myapp", "username", "password", "database");
$pdo = new PDO('mysql:host=myapp;dbname=database', 'username', 'password');
$mysql = mysql_connect("myapp", "username", "password");

$mysqli = new mysqli("localhost", "username", "password", "database");
?>
]]>
    </programlisting>
   </example>
   </para>
   <para>
    Имена секций - это строки. Допустимо использовать такие значения:
    <literal>192.168.2.1</literal>, <literal>127.0.0.1</literal> или
    <literal>localhost</literal>. Если, к примеру, приложение соединяется
    к <literal>localhost</literal> и присутствует секция
    <literal>localhost</literal>, то семантика операции соединения будет изменена.
    Приложение будет использовать не только сервер MySQL, расположенный на
    <literal>localhost</literal>, но плагин также начнёт балансировку нагрузки MySQL-запросов,
    согласно правилам из секции <literal>localhost</literal>. Таким образом, вы можете
    настроить балансировку нагрузки без изменения исходного кода приложения.
    Имейте в виду, что такая конфигурация может не способствовать общей 
    читаемости исходного кода вашего приложения. Использование имён секций,
    совпадающих с реальными именами хостов, следует рассматривать как последнее средство.
   </para>
   <para xml:id="mysqlnd-ms.plugin-ini-json.server-list-syntax">
    Каждая секция конфигурации, как минимум, должна содержать список
    основных (master) серверов и список подчинённых (slave) серверов.
    Список основных серверов содержится в секции <literal>master</literal>, а
    список подчинённых в секции <literal>slave</literal>. Если не задать список
    подчинённых серверов, то будет выдана фатальная ошибка уровня
    <constant>E_ERROR</constant>, поэтому просто оставляйте её пустой.
    Допустимо не использовать подчинённые сервера, но рекомендуется это делать
    только в случае синхронных кластеров. Более подробно читайте в разделе
    <link linkend="mysqlnd-ms.supportedclusters">поддерживаемые кластеры</link>.
    Основная часть документации фокусируется на использовании асинхронных
    кластеров репликации MySQL.
   </para>
   <para>
    Списки подчинённых и основных серверов могут быть индексированы символьными 
    именами. Либо же можно использовать массив анонимных записей.
   </para>
   <para>
    <example>
     <title>Список анонимных подчинённых серверов</title>
     <programlisting role="ini">
<![CDATA[
"slave": [
    {
        "host": "192.168.3.24",
        "port": "3305"
    },
    {
        "host": "192.168.3.65",
        "port": "3309"
    }
]
]]>
    </programlisting>
   </example>
   </para>
   <para>
    Список анонимных серверов задаётся массивом <literal>JSON</literal>.
    Список индексированных серверов задаётся объектом <literal>JSON</literal>.
   </para>
   <para>
    <example>
     <title>Список основных серверов с символьными именами</title>
     <programlisting role="ini">
<![CDATA[
"master": {
    "master_0": {
        "host": "localhost"
    }
}
]]>
    </programlisting>
   </example>
   </para>
   <para>
    Рекомендуется всё же использовать имена для серверов, так как они будут 
    показаны в сообщениях об ошибках.
   </para>
   <para>
    Порядок серверов сохраняется и учитывается mysqlnd_ms.
    Если, например, вы сконфигурируете стратегию балансировки round robin, то
    первый запрос <literal>SELECT</literal> будет запущен на первом из списка сервере.
   </para>
   <para>
    Сервер описывается с помощью полей <literal>host</literal>,
    <literal>port</literal>, <literal>socket</literal>, <literal>db</literal>,
    <literal>user</literal>, <literal>password</literal> и <literal>connect_flags</literal>.
    Обязательным из них является только <literal>host</literal>, а остальные опциональны.
   </para>
   <para>
    <example>
     <title>Конфигурация сервера</title>
     <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "db_server_host",
                "port": "db_server_port",
                "socket": "db_server_socket",
                "db": "database_resp_schema",
                "user": "user",
                "password": "password",
                "connect_flags": 0
            }
        },
        "slave": {
            "slave_0": {
                "host": "db_server_host",
                "port": "db_server_port",
                "socket": "db_server_socket"
            }
        }
    }
}
]]>
    </programlisting>
   </example>
   </para>
   <para>
    Если какие-либо параметры не заданы, то плагин будет использовать заданные
    пользователем значения в функции соединения.
    Смотрите раздел
    <link linkend="mysqlnd-ms.plugin-ini-json.using-section">с примером использования имён секций</link>.
   </para>
   <para>
    Формат конфигурационного файла был изменён в версии 1.1.0-beta для 
    возможности задания связанных фильтров. Фильтры нужны для фильтрации
    списка серверов для выбора того, на котором будет выполняться запрос.
    Фильтры настраиваются в разделе <literal>filter</literal>. Фильтры запускаются
    mysqlnd_ms в том порядке, как они описаны в конфигурационном файле.
    Определение фильтров не является обязательным, так что, если они вам не
    нужны, то можете не указывать секцию <literal>filters</literal>.
   </para>
   <para>
    Фильтры заменяют использовавшуюся в более ранних версиях настройку
    <link linkend="ini.mysqlnd-ms-plugin-config.pick"><literal>pick[]</literal></link>
    Новые <literal>random</literal> и
    <literal>roundrobin</literal> предоставляют ту-же функциональность.
   </para>
   <para>
    <example>
     <title>Новый фильтр <literal>roundrobin</literal>, старая функциональность</title>
     <programlisting role="ini">
<![CDATA[
   {
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.78.136",
                "port": "3306"
            },
            "slave_1": {
                "host": "192.168.78.137",
                "port": "3306"
            }
        },
        "filters": {
            "roundrobin": [

            ]
        }
    }
}
]]>
    </programlisting>
   </example>
   </para>
   <para>
    Функция
    <function>mysqlnd_ms_set_user_pick_server</function>
    была удалена. Определение функции обратного вызова теперь происходит
    с помощью фильтра <literal>user</literal>. Фильтр <literal>user</literal> принимает
    обязательный параметр <literal>callback</literal> для установки обработчика, 
    ранее устанавливавшегося с помощью функции
    <function>mysqlnd_ms_set_user_pick_server</function>.
    <example>
     <title>Фильтр <literal>user</literal> заменяет <function>mysqlnd_ms_set_user_pick_server</function></title>
     <programlisting role="ini">
<![CDATA[
"filters": {
    "user": {
        "callback": "pick_server"
    }
}
]]>
    </programlisting>
   </example>
   </para>
   <para xml:id="mysqlnd-ms.plugin-ini-json.debug_config">
    Корректность конфигурационного файла проверяется на двух этапах,
    при его первоначальном чтении и при создании соединения. Чтение
    конфигурационного файла происходит при старте обработки веб-запроса PHP.
    На ранних стадиях загрузки расширения, ошибки могут отображаться некорректно.
    В самом худшем случае ошибки вообще не будут показаны и соединения
    не будут устанавливаться, возвращая неадекватные сообщения. Эта проблема
    была решена версии 1.5.0.
   </para>
   <para>
    <example>
     <title>Обычные сообщения об ошибках в случае некорректности конфигурационного файла (до версии 1.5.0)</title>
     <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Warning: mysqli::mysqli(): (mysqlnd_ms) (mysqlnd_ms) Failed to parse config file [s1.json]. Please, verify the JSON in Command line code

Warning: mysqli::mysqli(): (HY000/2002): php_network_getaddresses: getaddrinfo failed: Name or service not known in Command line code on line 1

Warning: mysqli::query(): Couldn't fetch mysqli in Command line code on line 1

Fatal error: Call to a member function fetch_assoc() on a non-object in Command line code on line 1
]]>
    </screen>
   </example>
   </para>
   <para>
    Начиная с версии 1.5.0, ошибки этапа чтения конфигурационного файла
    сохраняются в буфере и выводятся при попытке установки соединения.
    Для установки уровня ошибок, который будет использоваться для вывода
    забуферизованных ошибок, используйте директиву
    <link linkend="ini.mysqlnd-ms.force-config-usage"><literal>mysqlnd_ms.force_config_usage</literal></link>.
    По умолчанию будет использоваться уровень <literal>E_WARNING</literal>.
   </para>
   <para>
    <example>
     <title>Улучшенная проверка конфигурационного файла, начиная с версии 1.5.0</title>
     <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Warning: mysqli::mysqli(): (mysqlnd_ms) (mysqlnd_ms) Failed to parse config file [s1.json]. Please, verify the JSON in Command line code on line 1
]]>
    </screen>
   </example>
   </para>
   <para>
    Для отладки потенциальных ошибок конфигурационного файла может быть
    полезным установить <link linkend="ini.mysqlnd-ms.force-config-usage"><literal>mysqlnd_ms.force_config_usage = 1</literal></link>.
    Это не только переключит уровень ошибок на <literal>E_RECOVERABLE_ERROR</literal>,
    но и позволит отловить опечатки в именах секций.
   </para>
   <para>
    <example>
     <title>Возможно более точная ошибка из-за <literal>mysqlnd_ms.force_config_usage=1</literal></title>
     <programlisting role="ini">
<![CDATA[
mysqlnd_ms.force_config_usage=1
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("invalid_section", "username", "password", "database");
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Warning: mysqli::mysqli(): (mysqlnd_ms) Exclusive usage of configuration enforced but did not find the correct INI file section (invalid_section) in Command line code on line 1 line 1
]]>
    </screen>
    
   </example>
   </para>
  </section>
  
  <section xml:id="mysqlnd-ms.plugin-ini-json-reference">
   <title>Конфигурационные директивы</title>
   
   <para>
    Ниже приведено краткое описание доступных директив конфигурации.
   </para>
   <para>
    <variablelist>
     <varlistentry xml:id="ini.mysqlnd-ms-plugin-config-v2.master">
      <term>
       <parameter>master</parameter>
       <type>массив или объект</type>
      </term>
      <listitem>
       <para>
        Списков основных серверов MySQL. Список может быть как типа
        <literal>массив JSON</literal> для указания списка анонимных серверов,
        так и типа <literal>объект JSON</literal>. Примеры смотрите
        <link linkend="mysqlnd-ms.plugin-ini-json.server-list-syntax">выше</link>.
       </para>
       <para>
        Обязательно должен быть определён хотя бы один основной сервер.
        Если в конфигурационном файле будет отсутствовать эта директива, то
        плагин вызовет ошибку уровня <literal>E_ERROR</literal>.
        Фатальная ошибка может выглядеть так
        <literal>(mysqlnd_ms) Section [master] doesn't exist for host
         [name_of_a_config_section] in %s on line %d</literal>.
       </para>
       <para>
        Сервер описывается с помощью
        <literal>host</literal>, <literal>port</literal>,
        <literal>socket</literal>, <literal>db</literal>,
        <literal>user</literal>, <literal>password</literal> и
        <literal>connect_flags</literal>. Обязательно должно присутствовать
        значение <literal>host</literal>. Остальные настройки по желанию. Если
        их не задавать, то плагин возьмёт их из параметров, указанных
        пользователем в функции соединения с БД. Также см.:
        <link linkend="mysqlnd-ms.plugin-ini-json.using-section">пример использование имён секций</link>.
       </para>
       <para xml:id="mysqlnd-ms.plugin-ini-json.server-config-keywords">
        Таблица параметров настройки сервера.
       </para>
       <informaltable>
        <tgroup cols="3">
         <colspec colwidth="1*"/>
         <colspec colwidth="7*"/>
         <colspec colwidth="2*"/>
         <thead>
          <row>
           <entry>Ключ</entry>
           <entry>Описание</entry>
           <entry>Версия</entry>
          </row>
         </thead>
         <tbody>
          <row>
           <entry>
            <literal>host</literal>
          </entry>
          <entry>
           <para>
            Хост, на котором развёрнута база данных. Это обязательный параметр.
            В случае его отсутствия, при попытке соединения будет выдана ошибка
            уровня <literal>E_RECOVERABLE_ERROR</literal>.
            Ошибка будет примерно такая <literal>(mysqlnd_ms) Cannot find [host] in
            [%s] section in config in %s on line %d</literal>.
           </para>
          </entry>
          <entry>Начиная с 1.1.0.</entry>
         </row>
         <row>
          <entry>
           <literal>port</literal>
          </entry>
          <entry>
           <para>
            Порт TCP/IP, на котором слушает БД.
           </para>
          </entry>
          <entry>Начиная с 1.1.0.</entry>
         </row>
         <row>
          <entry>
           <literal>socket</literal>
          </entry>
          <entry>
           <para>
            Сокет Unix сервера баз данных.
           </para>
          </entry>
          <entry>Начиная с 1.1.0.</entry>
         </row>
         <row>
          <entry>
           <literal>db</literal>
          </entry>
          <entry>
           <para>
            База данных (схема).
           </para>
          </entry>
          <entry>Начиная с 1.1.0.</entry>
         </row>
         <row>
          <entry>
           <literal>user</literal>
          </entry>
          <entry>
           <para>
            Пользователь.
           </para>
          </entry>
          <entry>Начиная с 1.1.0.</entry>
         </row>
         <row>
          <entry>
           <literal>password</literal>
          </entry>
          <entry>
           <para>
            Пароль.
           </para>
          </entry>
          <entry>Начиная с 1.1.0.</entry>
         </row>
         <row>
          <entry>
           <literal>connect_flags</literal>
          </entry>
          <entry>
           <para>
            Флаги соединения.
           </para>
          </entry>
          <entry>Начиная с 1.1.0.</entry>
         </row>
        </tbody>
       </tgroup>
      </informaltable>
      <para>
       Плагин поддерживает только один основной сервер. Существует экспериментальная
       настройка, позволяющая использовать несколько основных серверов. Подробности не
       задокументированы. Настройка предназначена только для разработки.
      </para>
    </listitem>
   </varlistentry>
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config-v2.slave">
    <term>
     <parameter>slave</parameter>
     <type>массив или объект</type>
     </term>
     <listitem>
      <para>
       Список подчинённых серверов репликации MySQL. Синтаксис аналогичен
       списку основных серверов. См.
       <link linkend="ini.mysqlnd-ms-plugin-config-v2.master"><literal>master</literal></link>.
      </para>
      <para>
       Плагин поддерживает работу с одним или более подчинёнными серверами.
      </para>
      <para>
       Список подчинённых серверов должен присутствовать в обязательном
       порядке. Плагин вызовет ошибку уровня <literal>E_ERROR</literal>,
       если в конфигурационном файле будет отсутствовать директива <literal>slave</literal>.
       Сообщение об ошибке будет примерно таким
       <literal>(mysqlnd_ms) Section [slave] doesn't exist for host [%s] in %s on line %d</literal>.
       Обратите внимание, что допустимо указывать пустой список.
       Ошибка была введена только для контроля, что секция
       <literal>slave</literal> в принципе присутствует.
       Если у вас используются только основные сервера, то допустимо оставлять
       этот список пустым.
      </para>
      <para>
       При пустом списке, если будет предпринята попытка запустить запрос на
       подчинённом сервере, плагин может выдать предупреждение типа
       <literal>mysqlnd_ms) Couldn't find the appropriate slave connection.
        0 slaves to choose from.</literal>.
       Также возможно у другое предупреждение, такое как
       <literal>(mysqlnd_ms) No connection selected by the last filter</literal>.
      </para>
     </listitem>
   </varlistentry>
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config-v2.gtid">
    <term>
     <parameter>global_transaction_id_injection</parameter>
     <type>массив или объект</type>
    </term>
    <listitem>
     <para>
      Настройка глобального идентификатора транзакции относится как
       к встроенному серверному механизму глобальных идентификаторов
       транзакций, так и к эмуляции на стороне клиента.
      </para>
      <informaltable>
       <tgroup cols="3">
        <colspec colwidth="1*"/>
        <colspec colwidth="7*"/>
        <colspec colwidth="2*"/>
        <thead>
         <row>
          <entry>Ключ</entry>
          <entry>Описание</entry>
          <entry>Версия</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry>
           <literal>fetch_last_gtid</literal>
          </entry>
          <entry>
           <para>
            SQL-запрос для извлечения последнего глобального идентификатора транзакций.
            Этот запрос нужен тогда, когда плагину необходимо узнать самый свежий
            идентификатор глобальной транзакции. Это нужно, например, при проверке
            статуса подчинённого сервера. Также используется функцией
            <function>mysqlnd_ms_get_last_gtid</function>.
           </para>
          </entry>
          <entry>Начиная с 1.2.0.</entry>
         </row>
         <row>
          <entry>
           <literal>check_for_gtid</literal>
          </entry>
          <entry>
           <para>
            SQL-запрос для проверки того, что на реплике применились все транзакции вплоть
            до искомой, включая её. Этот запрос нужен для поиска реплики с
            наилучшей согласованностью, покрывающей необходимую.
            Этот запрос может содержать шаблон <literal>#GTID</literal>, который
            будет заменён необходимым плагину глобальным идентификатором транзакции.
            Примеры смотрите в разделе <link linkend="mysqlnd-ms.quickstart.gtid">быстрый старт</link>.
           </para>
          </entry>
          <entry>Начиная с 1.2.0.</entry>
         </row>
         <row>
          <entry>
           <literal>report_errors</literal>
          </entry>
          <entry>
           <para>
            Выдавать ли предупреждение в случае, если выполнение какого либо из этих
            запросов завершилось ошибкой.
           </para>
          </entry>
          <entry>Начиная с 1.2.0.</entry>
         </row>
         <row>
          <entry>
           <literal>on_commit</literal>
          </entry>
          <entry>
           <para>
            Только для эмуляции глобального идентификатора транзакции на стороне клиента.
            SQl-запрос, который будет запущен по окончанию транзакции для обновления
            глобального идентификатора транзакции на основном сервере.
            Примеры смотрите в разделе <link linkend="mysqlnd-ms.quickstart.gtid">быстрый старт</link>.
           </para>
          </entry>
          <entry>Начиная с 1.2.0.</entry>
         </row>
         <row>
          <entry>
           <literal>wait_for_gtid_timeout</literal>
          </entry>
          <entry>
           <para>
            Заставляет плагин ждать <literal>wait_for_gtid_timeout</literal> секунд, 
            пока подчинённый сервер не придёт в согласованное состояние, при 
            поиске подчинённого сервера. Эта настройка ограничивает время 
            выделяемое на опрос статуса подчинённого сервера. Если опрос занимает
            слишком много времени, то общее затраченное время может превысить
            <literal>wait_for_gtid_timeout</literal>.
            Плагин вызывает <literal>sleep(1)</literal> для паузы в одну секунду
            между двумя опросами.
           </para>
           <para>
            Эта настройка может использоваться как с функционалом MySQL 5.6., так и
            с эмуляцией глобального идентификатора транзакций на стороне клиента.
           </para>
           <para>
            Ожидание, пока подчинённый сервер среплицирует необходимый GTID,
            необходимо для поддержание согласованности сессии и позволяет
            притормозить клиента. Притормаживание клиента неявно сказывается
            на уменьшении нагрузки по записи на основной сервер. Системы репликации,
            базирующиеся на копировании с основных серверов на подчинённые, такие
            как репликация MySQL, требуют больше времени для достижения 
            согласованности. Это может быть полезно для увеличения количества
            копий данных для обеспечения высокой доступности, или для снижения
            нагрузки на основной сервер.
           </para>
          </entry>
          <entry>Начиная с 1.4.0.</entry>
         </row>
        </tbody>
       </tgroup>
      </informaltable>
     </listitem>
   </varlistentry>
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config-v2.fabric">
    <term>
     <parameter>fabric</parameter>
     <type>объект</type>
    </term>
    <listitem>
     <para>
      Настройки, относящиеся к MySQL Fabric. Если плагин используется вместе с
      MySQL Fabric, то файл конфигурации плагина не содержит секций со списками 
      серверов. Вместо этого плагин запрашивает эти списки у MySQL Fabric.
     </para>
     <para>
      Минимальная конфигурация для использования плагина с MySQL Fabric должна
       содержать список из одного или более хостов MySQL Fabric, к которым он будет 
       обращаться. Если задано более одного хоста, то плагин будет использовать
       стратегию roundrobin для выбора одного из них. Другие стратегии пока недоступны.
      </para>
      <para>
       <example>
        <title>Минимальная конфигурация плагина для использования с MySQL Fabric</title>
        <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "fabric": {
            "hosts": [
                {
                    "host" : "127.0.0.1",
                    "port" : 8080
                }
            ]
        }
    }
}
]]>
        </programlisting>
       </example>
      </para>
      <para>
       Каждый хост MySQL Fabric описывается объектом JSON со следующими параметрами.
      </para>
      <informaltable>
       <tgroup cols="3">
        <colspec colwidth="1*"/>
        <colspec colwidth="7*"/>
        <colspec colwidth="2*"/>
        <thead>
         <row>
          <entry>Ключ</entry>
          <entry>Описание</entry>
          <entry>Версия</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry>
           <literal>host</literal>
          </entry>
          <entry>
           <para>
            Хост MySQL Fabric.
           </para>
          </entry>
          <entry>Начиная с 1.6.0.</entry>
         </row>
         <row>
          <entry>
           <literal>port</literal>
          </entry>
          <entry>
           <para>
            Порт TCP/IP, на котором MySQL Fabric принимает запросы от
            удалённых клиентов, типа нашего плагина.
           </para>
          </entry>
          <entry>Начиная с 1.6.0.</entry>
         </row>
        </tbody>
       </tgroup>
      </informaltable>
      <para>
       Плагин использует потоки PHP для общения с MySQL Fabric через
       XML RPC поверх HTTP. По умолчанию дл сетевого взаимодействия
       не заданы какие0либо тайм-ауты. Таким образом, по умолчанию
       используются тайм-ауты потоков PHP, которые не контролируются плагином.
      </para>
      <para>
       Можно задать собственные тайм-ауты. Настройка тайм-аутов в
       конфигурационном файле плагина будет иметь тот же эффект, что
       и настройка тайм-аутов для HTTP-соединения через потоки PHP.
      </para>
      <para>
       Тайм-аут задаётся в секундах. Допустимые значения лежат в диапазоне
       от 0 до 65535. Эта настройка доступна с версии 1.6.
      </para>
      <para>
       <example>
        <title>Таймаут соединения с Fabric</title>
        <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "fabric": {
            "hosts": [
                {
                    "host" : "127.0.0.1",
                    "port" : 8080
                }
            ],
            "timeout": 2
        }
    }
}
]]>
        </programlisting>
       </example>
      </para>
      <para>
       <link linkend="ini.mysqlnd-ms-plugin-config-v2.trx-stickiness">
        Закрепление транзакции за сервером (Transaction stickiness)</link>
       и логика MySQL Fabric могут противоречить друг другу. Закрепление транзакции
       запрещает переключение между серверами на протяжении выполнения транзакции.
       При использовании Fabric и шардинга, пользователь ошибочно может запустить
       локальную транзакцию на одном сервере и затем попытаться переключиться на
       другой, используя функции <function>mysqlnd_ms_fabric_select_shard</function> или
       <function>mysqlnd_ms_fabric_select_global</function>. В этом случае плагин не
       отвергнет запрос на переключение посреди транзакции, а позволит пользователю
       переключиться независимо от того, включено ли закрепление. Это будет исключительно
       ошибкой пользователя, написавшего такой код.
      </para>
      <para>
       Если закрепление транзакции включено и вы хотите получать предупреждения,
       используя функции <function>mysqlnd_ms_fabric_select_shard</function> или
       <function>mysqlnd_ms_fabric_select_global</function>, то установите
       логический флаг <literal>trx_warn_server_list_changes</literal>.
      </para>
      <para>
       <example>
        <title>Предупреждение о нарушении границ транзакции</title>
        <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "fabric": {
            "hosts": [
                {
                    "host" : "127.0.0.1",
                    "port" : 8080
                }
            ],
            "trx_warn_serverlist_changes": 1
        },
        "trx_stickiness": "on"
    }
}
]]>
        </programlisting>
        <programlisting role="php">
<![CDATA[
<?php
$link = new mysqli("myapp", "root", "", "test");
/*
  Этот запрос скорее всего завершится с ошибкой.
  Но в любом случае мы перейдём в режим
  необходимый для демонстрации.
*/
@mysqlnd_ms_fabric_select_global($link, 1);
$link->begin_transaction();
@$link->query("DROP TABLE IF EXISTS test");
/*
  Переключение серверов/шардов является ошибкой
  при открытии локальной транзакции!
*/
mysqlnd_ms_select_global($link, 1);
?>
]]>
        </programlisting>
        &example.outputs;
        <screen>
<![CDATA[
PHP Warning: mysqlnd_ms_fabric_select_global(): (mysqlnd_ms) Fabric server exchange in the middle of a transaction in %s on line %d
]]>
        </screen>
       </example>
      </para>
      <para>
       Обратите внимание, что эта особенность экспериментальная и в будущем синтаксис и семантика могут поменяться.
      </para>
     </listitem>
   </varlistentry>
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config-v2.filters">
    <term>
     <parameter>filters</parameter>
     <type>объект</type>
    </term>
    <listitem>
     <para>
      Список фильтров. Фильтры нужны для фильтрации списка серверов доступных
       для выполнения заданного запроса. Фильтры можно выстраивать цепочкой.
       Фильтры <literal>random</literal> и <literal>roundrobin</literal> заменяют директиву
       <link linkend="ini.mysqlnd-ms-plugin-config.pick"><literal>pick[]</literal></link>,
       ранее использовавшуюся для политик балансировки.
       Фильтр <literal>user</literal> заменяет функцию
       <function>mysqlnd_ms_set_user_pick_server</function>.
      </para>
      <para>
       Фильтры могут принимать параметры для уточнения своих действий.
      </para>
      <para>
       Если политики балансировки нагрузки не заданы, то плагин будет использовать
       <literal>random_once</literal>. Политика <literal>random_once</literal>
       берет случайный подчинённый сервер в момент запуска первого запроса на чтение.
       Для любых запросов, производящих только чтение, будет использоваться
       подчинённый сервер до момента завершения обработки PHP-скрипта.
       В случае, если в этой секции не заданы <literal>random</literal> или
       <literal>roundrobin</literal>, то балансировка нагрузки не будет использоваться.
      </para>
      <para>
       Если цепочка фильтров настроена таким образом, что фильтр возвращающий не более
       одного сервера является входом фильтра, которому необходимо получить более одного
       сервера, то плагин может выдать предупреждение при создании подключения.
       Предупреждение будет примерно такое: <literal>(mysqlnd_ms) Error while creating
       filter '%s' . Non-multi filter '%s' already created.</literal> Более того, для 
       соединения может быть установлена ошибка с номером <literal>2000</literal>, 
       SQL-состоянием <literal>HY000</literal> и сообщением, аналогичным предупреждению.
      </para>
      <para>
       <example>
        <title>Некорректная последовательность фильтров</title>
        <programlisting role="ini">
<![CDATA[
       {
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.78.136",
                "port": "3306"
            }
        },
        "filters": [
            "roundrobin",
            "random"
        ]
    }
}
]]>
        </programlisting>
        <programlisting role="php">
<![CDATA[
<?php
$link = new mysqli("myapp", "root", "", "test");
printf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error());
$link->query("SELECT 1 FROM DUAL");
?>
]]>
        </programlisting>
        &example.outputs;
        <screen>
<![CDATA[
PHP Warning:  mysqli::mysqli(): (HY000/2000): (mysqlnd_ms) Error while creating filter 'random' . Non-multi filter 'roundrobin' already created. Stopping in filter_warning.php on line 1
[2000] (mysqlnd_ms) Error while creating filter 'random' . Non-multi filter 'roundrobin' already created. Stopping
PHP Warning:  mysqli::query(): Couldn't fetch mysqli in filter_warning.php on line 3
]]>
        </screen>
       </example>
      </para>
     </listitem>
   </varlistentry>
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config-v2.filter-random">
    <term>
     Фильтр: <parameter>random</parameter>
     <type>объект</type>
    </term>
    <listitem>
     <para>
      Фильтр <literal>random</literal> работает как политики балансировки нагрузки, 
      как random и random once, устанавливаемые ранее с помощью
      <link linkend="ini.mysqlnd-ms-plugin-config.pick"><literal>pick[]</literal></link>.
     </para>
     <para>
      Политика random берет случайный сервер всякий раз, когда надо выполнить
       запрос на чтение. Политика random once выбирает один подчинённый сервер
       и использует его для запросов на чтение на протяжении выполнения PHP-скрипта.
       Если политики балансировки нагрузки не определены, то, по умолчанию,
       будет использоваться random once.
      </para>
      <para>
       Если фильтру <literal>random</literal> не передать ни одного аргумента, то
       будет выбрана политика балансировки random.
      </para>
      <para>
       <example>
        <title>Стратегия random с помощью фильтра <literal>random</literal></title>
        <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.78.136",
                "port": "3306"
            },
            "slave_1": {
                "host": "192.168.78.137",
                "port": "3306"
            }
        },
        "filters": [
            "random"
        ]
    }
}

]]>
        </programlisting>
       </example>
      </para>
      <para>
       Фильтру можно передать необязательный аргумент <literal>sticky</literal>.
       Если параметр <literal>sticky</literal> будет иметь значение 
       <literal>1</literal> (типа строка), то фильтр будет определять стратегию
       random once.
      </para>
      <para>
       <example>
        <title>Стратегия random once с помощью фильтра <literal>random</literal></title>
        <programlisting role="ini">
<![CDATA[
{
    "filters": {
        "random": {
            "sticky": "1"
        }
    }
}
]]>
        </programlisting>
       </example>
      </para>
      <para>
       Оба фильтра, <literal>random</literal> и <literal>roundrobin</literal>,
       поддерживают установку приоритета, веса сервера, начиная с
       PECL/mysqlnd_ms 1.4.0. Если в фильтре определён аргумент <literal>weight</literal>,
       он должен определять вес для всех серверов. При этом список подчинённых
       серверов в секции <literal>slave</literal> должен быть не анонимным, а именованным,
       как и в секции <literal>master</literal>. Имена должны использоваться 
       для определения весов конкретных серверов с помощью <literal>weight</literal>.
      </para>
      <para>
       <example>
        <title>Ошибка ссылки</title>
        <screen>
<![CDATA[
[E_RECOVERABLE_ERROR] mysqli_real_connect(): (mysqlnd_ms) Unknown server 'slave3' in 'random' filter configuration. Stopping in %s on line %d
]]>
        </screen>
       </example>
      </para>
      <para>
       Использование ошибочного имени в секции <literal>weight</literal> может привести к
       ошибке, показанной выше.
      </para>
      <para>
       Если секция <literal>weight</literal> отсутствует, то вес всех серверов
       считается за единицу.
      </para>
      <para>
       <example>
        <title>Задание <literal>весов</literal> для балансировки нагрузки</title>
        <programlisting role="ini">
<![CDATA[
{
   "myapp": {
       "master": {
           "master1":{
               "host":"localhost",
               "socket":"\/var\/run\/mysql\/mysql.sock"
           }
       },
       "slave": {
           "slave1": {
               "host":"192.168.2.28",
               "port":3306
           },
           "slave2": {
               "host":"192.168.2.29",
               "port":3306
           },
           "slave3": {
               "host":"192.0.43.10",
               "port":3306
           },
       },
       "filters": {
           "random": {
               "weights": {
                   "slave1":8,
                   "slave2":4,
                   "slave3":1,
                   "master1":1
               }
           }
       }
   }
}
]]>
        </programlisting>
       </example>
      </para>
      <para>
       В среднем, сервер с весом два будет выбираться в два раза чаще, чем сервер
       с весом один. Различные веса могут отражать производительность разных серверов,
       для задания предпочтения серверам с меньшими сетевыми задержками, или для
       настройки резервного сервера, который будет использоваться в случае отказа основного.
       В последнем случае имеет смысл задать резервному серверу очень маленький вес
       относительно остальных. К примеру, в приведённой выше конфигурации,
       сервер <literal>slave3</literal> будет принимать только 8 процентов 
       всех запросов, и если <literal>slave1</literal> и <literal>slave2</literal> 
       работают, он будет выбираться крайне редко. В случае отказа <literal>slave1</literal>
       и <literal>slave2</literal>, использование <literal>slave3</literal> возрастёт.
       Пожалуйста, перед тем как начать использовать веса таким образом,
       почитайте об обеспечении отказоустойчивости.
      </para>
      <para>
       Корректные значения весов лежат в диапазоне от 1 до 65535.
      </para>
      <para>
       Неизвестные аргументы будут тихо проигнорированы.
      </para>
      <para>
       The filter expects one or more servers as input. Outputs one server.
       A filter sequence such as
       <literal>random</literal>, <literal>roundrobin</literal> may
       cause a warning and an error message to be set on the connection
       handle when executing a statement.
      </para>
      <para>
       Список аргументов фильтра.
      </para>
      <informaltable>
       <tgroup cols="3">
        <colspec colwidth="1*"/>
        <colspec colwidth="7*"/>
        <colspec colwidth="2*"/>
        <thead>
         <row>
          <entry>Ключ</entry>
          <entry>Описание</entry>
          <entry>Версия</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry>
           <literal>sticky</literal>
          </entry>
          <entry>
           <para>
            Включает или отключает стратегию балансировки random once. См. выше.
           </para>
          </entry>
          <entry>Начиная с 1.2.0.</entry>
         </row>
         <row>
          <entry>
           <literal>weight</literal>
          </entry>
          <entry>
           <para>
            Назначение весов/приоритетов серверам
            при балансировке нагрузки. Описание см. выше.
           </para>
          </entry>
          <entry>Начиная с 1.4.0.</entry>
         </row>
        </tbody>
       </tgroup>
      </informaltable>
     </listitem>
   </varlistentry>
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config-v2.filter-roundrobin">
    <term>
     Фильтр: <parameter>roundrobin</parameter>
     <type>объект</type>
    </term>
    <listitem>
     <para>
      При использовании фильтра <literal>roundrobin</literal>, плагин
      последовательно перебирает список подчинённых серверов для выбора
      сервера, на котором будет выполнен запрос. Если плагин доходит до 
      конца списка, то перебор начинается с его начала.
     </para>
     <para>
      <example>
       <title><literal>roundrobin</literal> filter</title>
       <programlisting role="ini">
<![CDATA[
       {
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.78.136",
                "port": "3306"
            }
        },
        "filters": [
            "roundrobin"
        ]
    }
}
]]>
        </programlisting>
       </example>
      </para>
      <para>
       Ожидает один или более серверов на вход. Возвращает один сервер.
       Последовательность фильтров, такая как 
       <literal>roundrobin</literal>, <literal>random</literal> может
       установить ошибку для обработчика подключения во время
       выполнения запроса.
      </para>
      <para>
       Список аргументов фильтра.
      </para>
      <informaltable>
       <tgroup cols="3">
        <colspec colwidth="1*"/>
        <colspec colwidth="7*"/>
        <colspec colwidth="2*"/>
        <thead>
         <row>
          <entry>Ключ</entry>
          <entry>Описание</entry>
          <entry>Версия</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry>
           <literal>weight</literal>
          </entry>
          <entry>
           <para>
            Назначение весов/приоритетов серверам
            при балансировке нагрузки. Описание см.
            <link linkend="ini.mysqlnd-ms-plugin-config-v2.filter-random">выше</link>.
           </para>
          </entry>
          <entry>Начиная с 1.4.0.</entry>
         </row>
        </tbody>
       </tgroup>
      </informaltable>
     </listitem>
   </varlistentry>
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config-v2.filter-user">
    <term>
     Фильтр: <parameter>user</parameter>
     <type>объект</type>
    </term>
    <listitem>
     <para>
      Фильтр <literal>user</literal> заменяет функцию
      <function>mysqlnd_ms_set_user_pick_server</function>,
      которая была удалена в версии 1.1.0-beta. Фильтр устанавливает
      функцию обратного вызова, которая будет использоваться для
      выбора серверов и разделения операций записи/чтения.
     </para>
     <para>
      Встроенный в плагин механизм разделения чтения/записи может быть
       переопределён двумя способами. Самый простой способ - добавить в начало
       строки запроса SQL-хинт <constant>MYSQLND_MS_MASTER_SWITCH</constant>,
       <constant>MYSQLND_MS_SLAVE_SWITCH</constant> или
       <constant>MYSQLND_MS_LAST_USED_SWITCH</constant>. Использованием SQL-хинтов
       можно контролировать, например, будет ли запрос выполняться на основном сервере
       или на одном из подчинённых. С помощью SQL-хинтов невозможно однозначно
       указать конкретный подчинённый сервер для выполнения запроса.
      </para>
      <para>
       Полный контроль над процедурой выбора сервера даёт использование функции
       обратного вызова. Использование такой функции рекомендовано продвинутым
       пользователям, так как эта функция должна покрывать все возможные ситуации,
       в ином случае обрабатываемых плагином.
      </para>
      <para>
       Плагин вызывает функцию для выбора сервера из списков подчинённых и основных серверов.
       Функция должна проанализировать запрос и вернуть URI наиболее подходящего
       сервера для его выполнения.
      </para>
      <para>
       Если разрешены ленивые соединения и функция выберет подчинённый сервер, к 
       которому ещё не было установлено соединение и новое соединение завершится 
       с ошибкой, плагин вернёт ошибку до того, как с произойдёт следующая операция
       с этим соединением, например запуск запроса. Это накладывает на разработчика
       задачу обработки таких ошибок. К примеру, приложение может перезапустить
       запрос в надежде, что в этот раз функция обратного вызова вернёт другой сервер.
       Функция обратного вызова должна убедиться, что не вернёт сервер, соединение с 
       которым ранее завершилось ошибкой, или же изначально проверять доступность сервера,
       перед тем как вернуть его плагину, чтобы не свалиться в бесконечный цикл.
      </para>
      <para>
       <example>
        <title>Установка callback-функции</title>
        <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.78.136",
                "port": "3306"
            }
        },
        "filters": {
            "user": {
                "callback": "pick_server"
            }
        }
    }
}
]]>
        </programlisting>
       </example>
      </para>
      <para>
       Функция обратного вызова должны вернуть хост для выполнения запроса.
       URI хоста должно браться из списков подчинённых и основных серверов,
       переданных функции. Если функция вернёт значение, отсутствующее в этих
       списках, то плагин вызовет ошибку уровня <literal>E_RECOVERABLE_ERROR</literal>.
       Ошибка будет примерно такая
       <literal>  (mysqlnd_ms) User filter callback has returned an unknown server.
        The server 'server that is not in master or slave list' can neither be found
        in the master list nor in the slave list</literal>.
       Если приложение перехватит и проигнорирует эту ошибку, то для соединения 
       будет ошибка, например такая:
       <literal>(mysqlnd_ms) No connection selected by the last filter</literal> with
       the error code <literal>2000</literal> and the sqlstate <literal>HY000</literal>.
       Также может быть показано предупреждение.
      </para>
      <para>
       Задание в качестве функции обратного вызова несуществующей функции приведёт
       к ошибке уровня <literal>E_RECOVERABLE_ERROR</literal> при попытке её вызвать.
       Сообщение об ошибке будет примерно такое:
       <literal>(mysqlnd_ms) Specified callback (pick_server) is
        not a valid callback</literal>. Если приложение перехватит и проигнорирует эту 
       ошибку, то для соединения будет ошибка, например такая:
       <literal>(mysqlnd_ms) Specified callback (pick_server) is
        not a valid callback</literal> with the error code <literal>2000</literal>
       and the sqlstate <literal>HY000</literal>. 
       Также может быть показано предупреждение.
      </para>
      <para>
       Следующие параметры плагин передаёт функции обратного вызова.
      </para>
      <informaltable>
       <tgroup cols="3">
        <colspec colwidth="1*"/>
        <colspec colwidth="7*"/>
        <colspec colwidth="2*"/>
        <thead>
         <row>
          <entry>Параметр</entry>
          <entry>Описание</entry>
          <entry>Версия</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry>
           <literal>connected_host</literal>
          </entry>
          <entry>
           <para>
            URI текущего соединения.
           </para>
          </entry>
          <entry>Начиная с 1.1.0.</entry>
         </row>
         <row>
          <entry>
           <literal>query</literal>
          </entry>
          <entry>
           <para>
            Строка с SQL-запросом, который необходимо выполнить.
            </para>
          </entry>
          <entry>Начиная с 1.1.0.</entry>
         </row>
         <row>
          <entry>
           <literal>masters</literal>
          </entry>
          <entry>
           <para>
            Список основных серверов. Обратите внимание, что если настроена цепочка 
             фильтров, и этот фильтр не первый в списке, то этот список может 
             отличаться от списка в конфигурационном файле, так как предыдущие
             фильтры могли этот список уменьшить.
            </para>
          </entry>
          <entry>Начиная с 1.1.0.</entry>
         </row>
         <row>
          <entry>
           <literal>slaves</literal>
          </entry>
          <entry>
           <para>
            Список подчинённых серверов. Обратите внимание, что если настроена цепочка 
            фильтров, и этот фильтр не первый в списке, то этот список может 
             отличаться от списка в конфигурационном файле, так как предыдущие
             фильтры могли этот список уменьшить.
            </para>
          </entry>
          <entry>Начиная с 1.1.0.</entry>
         </row>
         <row>
          <entry>
           <literal>last_used_connection</literal>
          </entry>
          <entry>
           <para>
            URI сервера, на котором исполнялся последний запрос.
           </para>
          </entry>
          <entry>Начиная с 1.1.0.</entry>
         </row>
         <row>
          <entry>
           <literal>in_transaction</literal>
          </entry>
          <entry>
           <para>
            Логический флаг, определяющий, является ли запрос
             частью открытой транзакции. Если включён режим autocommit, то
             этот флаг будет &false;, иначе &true;.
            </para>
            <para>
             Определение транзакции базируется на мониторинге библиотеки mysqlnd
             на предмет вызовов <literal>set_autocommit</literal>.
             Более подробно читайте в разделе 
             <link linkend="mysqlnd-ms.pooling">пулы соединений и переключение</link>.
            </para>
          </entry>
          <entry>Начиная с 1.1.0.</entry>
         </row>
        </tbody>
       </tgroup>
      </informaltable>
      <para>
       <example>
        <title>Использование функции обратного вызова</title>
        <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            },
            "slave_1": {
                "host": "192.168.78.136",
                "port": "3306"
            }
        },
        "filters": {
            "user": {
                "callback": "pick_server"
            }
        }
    }
}
]]>
        </programlisting>
        <programlisting role="php">
<![CDATA[
<?php
function pick_server($connected, $query, $masters, $slaves, $last_used_connection, $in_transaction)
{
 static $slave_idx = 0;
 static $num_slaves = NULL;
 if (is_null($num_slaves))
  $num_slaves = count($slaves);

 /* по умолчанию: откат в встроеной в плагин логике */
 $ret = NULL;

 printf("Пользователь соединён с '%s'...\n", $connected);
 printf("... решаем где выполнять '%s'\n", $query);

 $where = mysqlnd_ms_query_is_select($query);
 switch ($where)
 {
  case MYSQLND_MS_QUERY_USE_MASTER:
   printf("... используем основной сервер\n");
   $ret = $masters[0];
   break;
  case MYSQLND_MS_QUERY_USE_SLAVE:
   /* SELECT или SQL-хинт для использования подчинённого */
   if (stristr($query, "FROM table_on_slave_a_only"))
   {
    /* таблица, которая находится только на первом подчинённом сервере */
    printf("... доступ к таблице возможен только на подчинённом сервере A\n");
    $ret = $slaves[0];
   }
   else
   {
    /* round robin */
    printf("... выполняем запрос на чтение на подчинённом сервере\n");
    $ret = $slaves[$slave_idx++ % $num_slaves];
   }
   break;
  case MYSQLND_MS_QUERY_LAST_USED:
   printf("... испольщзуем тот же сервер, что и для предыдущего запроса\n");
   $ret = $last_used_connection;
   break;
 }

 printf("... ret = '%s'\n", $ret);
 return $ret;
}

$mysqli = new mysqli("myapp", "root", "", "test");

if (!($res = $mysqli->query("SELECT 1 FROM DUAL")))
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
else
 $res->close();

if (!($res = $mysqli->query("SELECT 2 FROM DUAL")))
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
else
 $res->close();


if (!($res = $mysqli->query("SELECT * FROM table_on_slave_a_only")))
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
else
 $res->close();

$mysqli->close();
?>
]]>
        </programlisting>
        &example.outputs;
        <screen>
<![CDATA[
Пользователь соединён с 'myapp'...
... решаем где выполнять 'SELECT 1 FROM DUAL'
... выполняем запрос на чтение на подчинённом сервере
... ret = 'tcp://192.168.2.27:3306'
Пользователь соединён с 'myapp'...
... решаем где выполнять 'SELECT 2 FROM DUAL'
... some read-only query for a slave
... ret = 'tcp://192.168.78.136:3306'
Пользователь соединён с 'myapp'...
... решаем где выполнять 'SELECT * FROM table_on_slave_a_only'
... доступ к таблице возможен только на подчинённом сервере A
... ret = 'tcp://192.168.2.27:3306'
]]>
        </screen>
       </example>
      </para>
     </listitem>
   </varlistentry>
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config-v2.filter-user-multi">
    <term>
     Фильтр: <parameter>user_multi</parameter>
     <type>объект</type>
    </term>
    <listitem>
     <para>
      Фильтр <literal>user_multi</literal> отличается от <literal>user</literal>
      только в одном аспекте. Весь остальной синтаксис аналогичен.
      Фильтр <literal>user</literal> может выбрать и вернуть только один
      сервер. Цепочка фильтров на этом обычно заканчивается, так как 
      она должна сократить список серверов ровно до одного. Соответственно,
      после <literal>user</literal> остаётся ровно один сервер, на котором и запускается запрос.
     </para>
     <para>
      Фильтр <literal>user_multi</literal>, напротив, возвращает список подчинённых
      и основных серверов, который передаётся следующему фильтру в цепочке.
      Такой фильтр обычно ставится в начале цепочки фильтров. Другой фильтр, 
      возвращающий более одного сервера - это <literal>quality_of_service</literal>.
     </para>
     <para>
      Функция обратного вызова, заданная в <literal>user_multi</literal> должна
       вернуть массив с двумя элементами. В первом список выбранных основных серверов,
       а во втором - подчинённых серверов. Список должен содержать ключи подчинённых
       и основных серверов, присутствующие в переданных ему ранее списках. Следующий
       пример демонстрирует получения случайного списка подчинённых и основных серверов.
      </para>
      <para>
       <example>
        <title>Получение случайных подчинённых и основных серверов</title>
       <programlisting role="php">
<![CDATA[
<?php
function pick_server($connected, $query, $masters, $slaves, $last_used_connection, $in_transaction)
{
  $picked_masters = array()
  foreach ($masters as $key => $value) {
    if (mt_rand(0, 2) > 1)
      $picked_masters[] = $key;
  }
  $picked_slaves = array()
  foreach ($slaves as $key => $value) {
    if (mt_rand(0, 2) > 1)
      $picked_slaves[] = $key;
  }
  return array($picked_masters, $picked_slaves);
}
?>
]]>
       </programlisting>
       </example>
      </para>
      <para>
       В случае, если функция не вернёт списка серверов, плагин выдаст ошибку
       уровня <literal>E_RECOVERABLE</literal>. Ошибка будет примерно такая:
       <literal>(mysqlnd_ms) User multi
        filter callback has not returned a list of servers to use.
        The callback must return an array in %s on line %d</literal>. 
       В случае, если списки будут не пустыми, но будут содержать некорректные
       ключи серверов, то будет выдана ошибка уровня <literal>E_RECOVERABLE</literal>
       с примерно таким текстом: <literal>(mysqlnd_ms) User multi filter callback
       has returned an invalid list of servers to use.
       Server id is negative in %s on line %d</literal>, или похожая.
      </para>
      <para>
       Будет ли выдаваться ошибка в случае возврата пустых списков подчинённых или
       основных серверов, зависит от настроек. Если возвращён пустой список 
       основных серверов для запроса на запись, то плагин, скорее всего, вызовет
       ошибку типа <literal>(mysqlnd_ms) Couldn't find the appropriate
       master connection. 0 masters to choose from. Something is wrong in %s on line %d</literal>.
       Обычно именно такая ошибка уровня <literal>E_ERROR</literal> и произойдёт.
       В случае операции чтения и пустого списка подчинённых серверов, поведение
       будет определяться конфигурацией механизма защиты от отказов. Если допустим
       откат к основному серверу, то ошибок не будет. Если же откат к основному серверу запрещён, то
       будет ошибка типа <literal>(mysqlnd_ms) Couldn't find the appropriate
       slave connection. 0 slaves to choose from. Something is wrong in %s on line %d</literal>.
      </para>
     </listitem>
   </varlistentry>
   
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config-v2.filter-node-groups">
    <term>
     Фильтр: <parameter>node_groups</parameter>
     <type>объект</type>
    </term>
    <listitem>
     <para>
      Фильтр <literal>node_groups</literal> позволяет группировать узлы кластера
      и отправлять запрос на эти группы, например для поддержки партиционирования.
      Партиционирование данных может потребоваться в случае ручного шардирования,
      в кластерах типа primary copy с несколькими основными серверами или для 
      обхода узких мест в кластерах типа update everywhere, не имеющих
      собственных механизмов партиционирования. Соответственно, после этого фильтра
      необходимо применить другой фильтр, который выберет один сервер из возвращённого
      списка.
     </para>
     <informaltable>
      <tgroup cols="3">
       <colspec colwidth="1*"/>
       <colspec colwidth="7*"/>
       <colspec colwidth="2*"/>
       <thead>
        <row>
         <entry>Ключ</entry>
         <entry>Описание</entry>
         <entry>Версия</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>
          <literal>пользовательские имена групп узлов</literal>
         </entry>
         <entry>
          <para>
           Можно определить одну или более групп узлов кластера. Каждая такая
           группа должна иметь своё имя. Это имя используется в SQL-хинтах
           для принудительного задания группы серверов, на которых должен 
           выполняться запрос. Для запуска запроса на одном из серверов
           конкретной группы, SQL-запрос должен претворяться хинтом
           <literal>/*имя группы узлов*/</literal>.
           Обратите внимание, что вокруг <literal>имя группы узлов</literal>
           не должно быть пробелов. Поскольку
           <literal>имя группы узлов</literal> будет использоваться как есть вам
           качестве части SQL-хинта, вы должны избегать имён некорректных
           с точки зрения SQL.
          </para>
          <para>
           Каждое определение группы серверов должно содержать список
           <literal>основных</literal>-серверов.
           Также можно задавать список <literal>подчинённых</literal> серверов.
           В случае отсутствия <literal>основного</literal>-сервера в группе
           <literal>name_of_group</literal> может привести к ошибке уровня
           <constant>E_RECOVERABLE_ERROR</constant> с текстом
           <literal>(mysqlnd_ms) No masters configured in node group 'name_of_group' for 'node_groups' filter</literal>.
          </para>
          <para>
           Список подчинённых и основных серверов должен содержать сервера, которые
           присутствуют в 
           <link linkend="ini.mysqlnd-ms-plugin-config-v2.master">глобальном списке основных серверов</link>
           и <link linkend="ini.mysqlnd-ms-plugin-config-v2.slave">глобальном списке
           подчинённых серверов</link> соответственно. В случае если будет указан 
           неизвестный сервер, то будет выдана ошибка уровня 
           <constant>E_RECOVERABLE_ERROR</constant> с текстом
           <literal>(mysqlnd_ms) Unknown master 'server_alias_name' (section 'name_of_group')
            in 'node_groups' filter configuration</literal>.
          </para>
          <para>
           <example>
            <title>Ручное партиционирование</title>
            <programlisting role="ini">
<![CDATA[
 {
  "myapp": {
       "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.28",
                "port": 3306
            },
            "slave_1": {
                "host": "127.0.0.1",
                "port": 3311
            }
        },
        "filters": {
            "node_groups": {
                "Partition_A" : {
                    "master": ["master_0"],
                    "slave": ["slave_0"]
                }
            },
           "roundrobin": []
        }
    }
}
]]>
              </programlisting>
             </example>
           </para>
           <para>
            Обратите внимание, что если цепочка фильтров вернула пустой список 
             подчинённых серверов и использована конфигурационная директива
             <literal>mysqlnd_ms.multi_master=0</literal>, плагин может
             выдать предупреждение.
           </para>
          </entry>
          <entry>Начиная с 1.5.0.</entry>
         </row>
        </tbody>
       </tgroup>
      </informaltable>
     </listitem>
   </varlistentry>
   
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config-v2.filter-qos">
    <term>
     Фильтр: <parameter>quality_of_service</parameter>
     <type>объект</type>
    </term>
    <listitem>
     <para>
      Фильтр <literal>quality_of_service</literal> идентифицирует узлы кластера
      способные предоставить необходимый уровень сервиса. Это фильтр, который
      может вернуть ноль, один или несколько серверов. За ним обязательно 
      должен следовать фильтр, гарантированно возвращающий ровно один сервер.
     </para>
     <para>
      Фильтр <literal>quality_of_service</literal> появился в версии 1.2.0-alpha.
      В версиях 1.2, этот фильтр фокусируется на таком аспекте качества, как
      согласованность данных. Разные типы кластеров предоставляют разный уровень
      согласованности данных. К примеру, асинхронная репликация MySQL предоставляет
      не гарантированную согласованность. Подчинённый сервер может не отдать запрашиваемые 
      данные, либо данные на нем будут устаревшие, поскольку они на него ещё 
      не среплицировались. Обычно это допустимо. В других случаях, для корректной
      работы приложения, требуется более высокий уровень согласованности. Для
      таких случаев <literal>quality_of_service</literal> может отбросить сервера, 
      которые этого не гарантируют.
     </para>
     <para>
      Фильтр <literal>quality_of_service</literal> может быть удалён или 
      создан во время исполнения.Успешный вызов <function>mysqlnd_ms_set_qos</function>
      удаляет все существующие <literal>qos</literal> фильтры из списка фильтров и
      добавляет новый в самое начало. Все настройки, какие можно сделать с помощью
      <function>mysqlnd_ms_set_qos</function>, также можно сделать и в конфигурационном
      файле. Однако использование функции, безусловно, является наиболее распространённым 
      вариантом использования. Вместо установки уровней session_consistency и 
      strong_consistency, рекомендуется просто не указывать подчинённые сервера, а 
      только основные сервера. Использование пустого списка подчинённых серверов 
      короче и более читаемо. Единственный уровень сервиса, который имеет смысл 
      указывать в конфигурационном файле, это комбинация eventual_consistency
      и контроль максимальной задержки репликации подчинённого сервера.
     </para>
     <informaltable>
      <tgroup cols="3">
       <colspec colwidth="1*"/>
       <colspec colwidth="7*"/>
       <colspec colwidth="2*"/>
       <thead>
        <row>
         <entry>Ключ</entry>
         <entry>Описание</entry>
         <entry>Версия</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>
          <literal>eventual_consistency</literal>
         </entry>
         <entry>
          <para>
           Не гарантированная согласованность. Позволяет использовать
           любые подчинённые и основные сервера. данные могут быть устаревшими.
          </para>
          <para>
           Данный фильтр может принимать опциональный параметр <literal>age</literal>.
           Если параметр <literal>age</literal> задан, то плагин будет рассматривать
           достойными чтения только те подчинённые сервера, для которых репликация
           возвращает задержку подчинённого сервера меньшую или равную <literal>age</literal>.
           Задержка репликации измеряется с использованием <literal>SHOW SLAVE STATUS</literal>.
           Если плагин не может получить значение задержки репликации, то сервер
           будет исключён. Детали реализации и использования описаны в секции
           <link linkend="mysqlnd-ms.qos-consistency">концепции качества сервиса</link>.
          </para>
          <para>
           Обратите внимание, что если цепочка фильтров вернула пустой список 
           подчинённых серверов и использована конфигурационная директива
           <literal>mysqlnd_ms.multi_master=0</literal>, плагин может
           выдать предупреждение.
          </para>
          <para>
           <example>
            <title>Global limit on slave lag</title>
            <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            },
            "slave_1": {
                "host": "192.168.78.136",
                "port": "3306"
            }
        },
        "filters": {
            "quality_of_service": {
                "eventual_consistency": {
                    "age":123
                }
            }
        }
    }
}
]]>
              </programlisting>
             </example>
            </para>
          </entry>
          <entry>Начиная с 1.2.0.</entry>
         </row>
         <row>
          <entry>
           <literal>session_consistency</literal>
          </entry>
          <entry>
           <para>
            Согласованность на уровне сессии (гарантия чтения значений, которые вы 
            записали). Позволяет использовать все основные сервера и подчинённые
            сервера синхронизованные с основным сервером. Если не задано никаких 
            дополнительных параметров, то все подчинённые серверы будут
            исключены, так как надёжно определить то, что подчинённые сервера
            полностью синхронизированы с основным сервером - невозможно.
            Обратите внимание, что если цепочка фильтров вернула пустой список 
            подчинённых серверов и использована конфигурационная директива
             <literal>mysqlnd_ms.multi_master=0</literal>, плагин может
             выдать предупреждение.
            </para>
            <para>
             Временно согласованность на уровне сессии можно с помощью функции
             <function>mysqlnd_ms_set_qos</function>, что является альтернативой
             использованию <literal>master_on_write</literal>.
             <literal>master_on_write</literal> скорее всего, отправит больше запросов основному серверу,
             чем необходимо. Приложение сможет продолжить работу с более
             низким уровнем согласованности после выполнения критичных запросов.
            </para>
          </entry>
          <entry>Начиная с 1.1.0.</entry>
         </row>
         <row>
          <entry>
           <literal>strong_consistency</literal>
          </entry>
          <entry>
           <para>
            Сильная согласованность. Будут использованы только основной сервер.
           </para>
          </entry>
          <entry>Начиная с 1.2.0.</entry>
         </row>
        </tbody>
       </tgroup>
      </informaltable>
     </listitem>
   </varlistentry>
   
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config-v2.failover">
    <term>
     <parameter>failover</parameter>
     До версии (включая) 1.3.x: <type>строка</type>.
     Начиная с 1.4.0: <type>объект</type>.
    </term>
    <listitem>
     <para>
      Политика обработки отказов. Поддерживаемые политики:
       <literal>disabled</literal> (по умолчанию), <literal>master</literal>,
       <literal>loop_before_master</literal> (Начиная с 1.4.0).
      </para>
      <para>
       Если политики обработки отказов не настроены, то по умолчанию 
       никакой автоматической обработки отказов производиться не будет
       (<literal>failover=disabled</literal>). Всякий раз, когда
       плагин не может установить соединение с сервером, он выдаёт
       предупреждение и устанавливает для этого соединения код и сообщение
       об ошибке. После этого он возвращает ошибку приложению на обработку и,
       например, перепосылает последний запрос в надежде, что будет выбран 
       другой сервер.
      </para>
      <para>
       Обратите внимание, что логика обработки отказов по умолчанию применяется
       только при создании нового соединения. Если соединение было открыто, то 
       никаких попыток переподключения, в случае ошибки, производиться не будет.
       Если, к примеру, сервер, с которым установлено соединение, отключится, то,
       при попытке выполнить на нем запрос, никаких попыток восстановления 
       предпринято не будет. Вместо этого вернётся ошибка.
      </para>
      <para>
       Если используется <literal>failover=master</literal>, то плагин будет
       неявно переключаться на основной сервер, если он доступен. Пожалуйста
       внимательно почитайте документацию, где описаны все риски и подводные 
       камни использования <literal>failover=master</literal>.
      </para>
      <para>
       <example>
        <title>Откат к основному серверу в случае невозможности соединиться с
         подчинённым сервером (PECL/mysqlnd_ms &lt; 1.4.0)</title>
        <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.78.136",
                "port": "3306"
            }
        },
        "failover": "master"
    }
}
]]>
        </programlisting>
       </example>
      </para>
      <para>
       Начиная с PECL/mysqlnd_ms 1.4.0 ключ конфигурации failover должен содержать объект.
      </para>
      <para>
       <example>
        <title>Новый синтаксис, начиная с версии 1.4.0</title>
        <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.78.136",
                "port": "3306"
            }
        },
        "failover": {"strategy": "master" }
    }
}
]]>
        </programlisting>
       </example>
      </para>
      <informaltable>
       <tgroup cols="3">
        <colspec colwidth="1*"/>
        <colspec colwidth="7*"/>
        <colspec colwidth="2*"/>
        <thead>
         <row>
          <entry>Ключ</entry>
          <entry>Описание</entry>
          <entry>Версия</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry>
           <literal>strategy</literal>
          </entry>
          <entry>
           <para>
            Политика обработки отказов. Допустимые значения:
            <literal>disabled</literal> (default), <literal>master</literal>,
            <literal>loop_before_master</literal>
           </para>
           <para>
            Значение <literal>disabled</literal> запрещает автоматическую обработку отказов.
           </para>
           <para>
            Значение <literal>master</literal> говорит плагину, что, в случае 
            недоступности подчинённого сервера, необходимо переключиться на основному серверу.
            Если соединение с основным сервером вернуло ошибку, то плагин завершит
            цикл обработки ошибок и вернёт ошибку пользователю.
           </para>
           <para>
            Если используется <literal>loop_before_master</literal> и сделан запрос
            к подчинённому серверу, плагин попытается соединиться с другими 
            подчинёнными серверами и только в самом конце переключится на основной сервер.
            Если указано несколько основных серверов и разрешена конфигурация с
            несколькими основными серверами, то плагин будет пытаться соединиться со всеми ними
            по очереди и только потом вернёт ошибку.
           </para>
          </entry>
          <entry>Начиная с 1.4.0.</entry>
         </row>
         <row>
          <entry>
           <literal>remember_failed</literal>
          </entry>
          <entry>
           <para>
            Запоминать ошибки в течение всего времени исполнения PHP-скрипта.
            По умолчанию: <literal>false</literal>.
           </para>
           <para>
            Если установить как <literal>true</literal>, то плагин запомнит
            хосты, к которым не удалось подключиться, и в течение исполнения
            текущего скрипта больше не будет пытаться их использовать для 
            балансировки нагрузки.
           </para>
          </entry>
          <entry>
           Начиная с версии 1.4.0. Эта функциональность доступна только в сочетании с
           фильтрами балансировки нагрузки <literal>random</literal> и
           <literal>roundrobin</literal>. Рекомендуется использовать эту опцию.
          </entry>
         </row>
         <row>
          <entry>
           <literal>max_retries</literal>
          </entry>
          <entry>
           <para>
            Максимальное количество попыток коннекта перед тем, как отклонить хост.
             По умолчанию: <literal>0</literal> (нет ограничений).
            </para>
            <para>
             Эта настройка предназначена для предотвращения исключения хостов из
             списка используемых после первой ошибки соединения. Если установить
             <literal>n > 0</literal>, то плагин не будет убирать сервер из списка
             пока для него не будет предпринято заданное количество неудачных 
             соединений.
            </para>
          </entry>
          <entry>
           Начиная с 1.4.0. Эта функциональность доступна только в сочетании с
           фильтрами балансировки нагрузки <literal>random</literal> и
           <literal>roundrobin</literal>.
          </entry>
         </row>
        </tbody>
       </tgroup>
      </informaltable>
      <para>
       Установка <literal>failover</literal> любым значением, отличным от
       <literal>disabled</literal>, <literal>master</literal> или
       <literal>loop_before_master</literal>, не вызовет ошибок или
       предупреждений.
      </para>
     </listitem>
   </varlistentry>
   
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config-v2.lazy-connections">
    <term>
     <parameter>lazy_connections</parameter>
     <type>логическое</type>
    </term>
    <listitem>
     <para>
       Контролирует использование ленивых подключений. Ленивые подключения -
       это такие подключения, которые не устанавливаются, пока клиент не отправит
       первый запрос. Включены по умолчанию.
      </para>
      <para>
       Ленивые подключения крайне рекомендованы к использованию, поскольку
       позволяют сильно сократить количество открытых соединений.
       Если вы запретите ленивые соединения, то, например, настроив кластер из
       одного основного сервера и двух подчинённых серверов, вы получите три одновременно
       открытых соединения при первом же подключении к базе, хотя в вашем скрипте
       используется только подключение к основному серверу.
      </para>
      <para>
       Ленивые подключения не представляют опасности, если вы часто меняете 
       состояние подключения. Плагин не отправляет все изменения состояния во 
       все соединения из пула соединений. Небольшое количество изменений посылаются 
       только в открытые соединения. Ленивые соединения, открытые позже, не будут
       затронуты. Только небольшое количество настроек будут &quot;запоминаться&quot;
       и применяться к новым открытым ленивым соединениям.
      </para>
      <para>
       <example>
        <title>Запрещение ленивых соединений</title>
        <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.78.136",
                "port": "3306"
            }
        },
        "lazy_connections": 0
    }
}
]]>
        </programlisting>
       </example>
      </para>
      <para>
       Внимательно изучите документацию по <literal>server_charset</literal>,
       для того, чтобы избежать проблем с экранированием строк и с серверами,
       использующими другие настройки локали по умолчанию.
      </para>
     </listitem>
   </varlistentry>
   
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config-v2.server-charset">
    <term>
     <parameter>server_charset</parameter>
     <type>строка</type>
    </term>
    <listitem>
     <para>
      Эта настройка появилась в версии 1.4.0. Крайне рекомендуется её использовать
      при включённых ленивых подключениях.
     </para>
     <para>
      Настройка <literal>server_charset</literal> служит двум целям. Она используется
      как кодировка по умолчанию при экранировании строк до установления 
      соединения и помогает избежать подводных камней в гетерогенном 
      окружении, когда разные сервера используют разные кодировки по умолчанию.
     </para>
     <para>
       При выполнении экранирования строк учитывается кодировка соединений.
       Выключение экранирования строк невозможно до того, как соединение 
       будет открыто, и не станет известна кодировка соединения. Использование
       ленивых подключений задерживает реальное открытие соединение до
       момента отправки первого запроса.
      </para>
      <para>
       Приложения использующие ленивые подключения могут попытаться экранировать
       строки перед отправкой запроса. Фактически это обычное дело, когда
       строка запроса нуждается в экранировании. Однако, так как ленивое
       соединение ещё не открыто, то такое экранирование завершится с ошибкой.
       Плагин выдаст ошибку уровня <literal>E_WARNING</literal> с текстом 
       <literal>(mysqlnd_ms)
        string escaping doesn't work without established connection.
        Possible solution is to add server_charset to your configuration</literal>.
      </para>
      <para>
       Установка <literal>server_charset</literal> позволит плагину использовать
       заданную кодировку для экранирования строк до того, как ленивое соединение 
       будет реально установлено. Мало того, плагин будет принудительно использовать 
       эту кодировку когда соединение установлено.
      </para>
      <para>
       Принудительное использование настроенной кодировки для экранирования 
       позволит избежать подводных камней при использовании другой кодировки позже,
       после установки соединения. Это дополнительное преимущество, позволяющее
       не выравнивать настройки кодировки на всех используемых серверах. Не важно,
       какая кодировка настроена на серверах, плагин, по умолчанию, будет 
       использовать свою.
      </para>
      <para>
       Плагин не запрещает пользователю в любой момент поменять кодировку с
       помощью функции <function>set_charset</function> или соответствующего 
       SQL-запроса. Обратите внимание, что использование SQL не рекомендуется, 
       поскольку плагин не сможет его отследить. Пользователь может, к примеру, 
       изменить кодировку для ленивого соединения после экранирования, но до
       установления соединения. Кодировка, установленная пользователем, может быть
       использована для любого вложенного экранирования, до установления реального
       соединения. Соединение будет установлено с использованием заданной в 
       конфигурационном файле кодировки не взирая на кодировку сервера и предшествующие 
       действия пользователя. Если соединение уже было установлено, 
       <literal>set_charset</literal> больше не имеет смысла.
      </para>
      <para>
       <example>
        <title>Экранирование строк для ленивых подключений</title>
        <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.78.136",
                "port": "3306"
            }
        },
        "lazy_connections": 1,
        "server_charset" : "utf8mb4"
    }
}
]]>
        </programlisting>
        <programlisting role="php">
<![CDATA[
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
$mysqli->real_escape("это будет экранироваться с помощью настройки server_charset - utf8mb4");
$mysqli->set_charset("latin1");
$mysqli->real_escape("это будет экранироваться с помощью latin1");
/* server_charset implicitly set - utf8mb4 connection */
$mysqli->query("SELECT 'это соединение будет использовать server_charset' AS _msg FROM DUAL");
/* теперь используется latin1*/
$mysqli->set_charset("latin1");
?>
]]>
        </programlisting>
       </example>
      </para>
     </listitem>
   </varlistentry>
   
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config-v2.master-on-write">
    <term>
     <parameter>master_on_write</parameter>
     <type>логическое значение</type>
    </term>
    <listitem>
     <para>
       Если установлено, то плагин начнёт использовать основной сервер
       только после того, как на нем будет выполнен первый запрос.
       Приложение также сможет использовать подчинённые сервера,
       используя SQL-хинты.
      </para>
      <para>
       Эта настройка может помочь победить задержку репликации. Если, например, 
       будет запущен запрос <literal>INSERT</literal>, то, после него, все
       последующие запросы плагин будет отправлять на основной сервер,
       включая запросы типа <literal>SELECT</literal>. Это может
       помочь в случае, когда подчинённые сервера не успеют среплицировать
       результаты запроса <literal>INSERT</literal>.
      </para>
      <para>
       <example>
        <title>Обеспечение консистентного чтения</title>
        <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.78.136",
                "port": "3306"
            }
        },
        "master_on_write": 1
    }
}
]]>
        </programlisting>
       </example>
      </para>
      <para>
       Обратите внимание, что фильтр <literal>quality_of_service</literal>
       появился в версии 1.2.0-alpha. Он даёт возможность более тонко
       управлять <link linkend="mysqlnd-ms.qos-consistency">уровнем сервиса</link>,
       который вам нужен.
      </para>
      <para>
       Все настройки <link linkend="ini.mysqlnd-ms-plugin-config-v2.trx-stickiness">привязки транзакции
       к серверу</link>, включая <literal>trx_stickiness=on</literal>,
       перебиваются <literal>master_on_write=1</literal>.
      </para>
     </listitem>
   </varlistentry>
   
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config-v2.trx-stickiness">
    <term>
     <parameter>trx_stickiness</parameter>
     <type>строка</type>
    </term>
    <listitem>
     <para>
       Политики привязки транзакции к серверу. Поддерживаемые политики:
       <literal>disabled</literal> (по умолчанию), <literal>master</literal>.
      </para>
      <para>
       Эта настройка требует версии PHP 5.4.0 или выше. Если использовать с более ранними
       версиями PHP, то плагин выдаст предупреждение вида
       <literal>(mysqlnd_ms) trx_stickiness strategy is not supported before PHP 5.3.99</literal>.
      </para>
      <para>
       Если политика не определена, либо установлена как
       <literal>trx_stickiness=disabled</literal>, то плагин может
       балансировать нагрузку и переключаться между серверами в течение
       транзакции. Плагин не транзакционно-безопасен. Для предотвращения
       переключения соединения в ходе транзакции можно использовать SQL-хинты.
      </para>
      <para>
       Начиная с PHP 5.4.0, библиотека mysqlnd позволяет отслеживать изменение 
       состояния режима <literal>autocommit</literal>, путём перехвата
       вызовов функции <literal>set_autocommit()</literal>.
       Если задано <literal>set_stickiness=master</literal> и
       <literal>autocommit</literal> отключён расширением PHP MySQL путём
       вызова <literal>mysqlnd</literal> внутренней функции
       <literal>set_autocommit()</literal>, плагин понимает, что начата транзакция,
       и все последующие запросы будут выполняться на основном сервере, 
       пока не будет включён <literal>autocommit</literal>. Соответственно
       можно не использовать SQL-хинты.
      </para>
      <para>
       Например, для вызова внутренней функции библиотеки <literal>mysqlnd</literal>
       <literal>set_autocommit()</literal>, можно использовать
       <function>mysqli_autocommit</function>.
      </para>
      <para>
       Следует учесть, что даже с установкой <literal>trx_stickiness=master</literal>, 
       плагин не сможет перехватывать изменение режима <literal>autocommit</literal>,
       вызванное SQL-запросами, такими как <literal>SET AUTOCOMMIT=0</literal>
       или <literal>BEGIN</literal>.
      </para>
      <para>
       Начиная с PHP 5.5.0, библиотека mysqlnd содержит дополнительные вызовы C API для
       контроля транзакций. Уровень контроля совпадает с заданным SQL-запросом.
       <literal>mysqli</literal> API был изменён для использования этих вызовов.
       Начиная с версии 1.5.0, PECL/mysqlnd_ms может отслеживать не только
       <function>mysqli_autocommit</function>, но также <function>mysqli_begin</function>,
       <function>mysqli_commit</function> и <function>mysqli_rollback</function>. Это
       позволяет отслеживать границы транзакций и останавливать для них балансировку.
      </para>
      <para>
       <example>
        <title>Использование основного сервера для запуска транзакции</title>
        <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.78.136",
                "port": "3306"
            }
        },
        "trx_stickiness": "master"
    }
}
]]>
        </programlisting>
       </example>
      </para>
      <para>
       Начиная с версии 1.5.0, в рамках транзакции запрещён автоматическая обработка
       отказов. Если границы транзакции определены верно, разрешена привязка транзакции к 
       серверу и, в этот момент, сервер перестаёт отвечать, то плагин не будет
       пытаться переключиться на другой сервер, если явно не настроены политики
       обработки отказов. Пользователь должен обработать такие ошибки самостоятельно. 
       В зависимости от настроек, плагин может выдать ошибку уровня
       <literal>E_WARNING</literal> с текстом вроде такого:
       <literal>(mysqlnd_ms) Automatic failover is not permitted in the middle of a transaction</literal>.
       Эта ошибка может быть перебита другими ошибками, выданными
       функциями, исполняющими запрос, например
       <literal>(mysqlnd_ms) No connection selected by the last filter</literal>.
      </para>
      <para>
       <example>
        <title>Нет автоматического переключения при сбое, обработка ошибок</title>
        <programlisting role="php">
<![CDATA[
<?php
/* предположение: настроена автоматическая обработка ошибок */
$mysqli = new mysqli("myapp", "username", "password", "database");

/* переключаем внутреннее состояние плагина в in_trx = 1 */
$mysqli->autocommit(false);

/* предположение: сервер перестал отвечать */
if (!($res = $mysqli->query("SELECT 'Этот запрос не выполнился' AS _msg FROM DUAL"))) {
 /* обрабатываем ошибку транзакции, внутреннее состояние плагина всё ещё in_trx = 1 */
 printf("[%d] %s", $mysqli->errno, $mysqli->error);
 /*
  Если используется механизм определения транзакции на базе autocommit(),
  то НЕОБХОДИМО вызвать autocommit(true). В противном случае плагин
  будет думать, что продолжается текущая транзакция и переключиться на
  другой сервер не получится.
 */
 $mysqli->autocommit(true);
 /* Ну и теперь вы хотите начать новую транзакцию */
 $mysqli->autocommit(false);
}
/* с этого момента используем latin1 */
$mysqli->set_charset("latin1");
?>
]]>
        </programlisting>
       </example>
      </para>
      <para>
       Если сервер отказывает в середине транзакции, плагин будет
       игнорировать все попытки переключиться на другой сервер, пока
       транзакция не будет завершена. Напомним, что плагин контролирует 
       вызовы API для обнаружения границ транзакций. Таким образом,
       вам нужно, например, включить режим автокоммита для завершения 
       текущей транзакции для того, чтобы плагин включит балансировку
       нагрузки. Собственно вы можете сразу же начать новую транзакцию,
       снова отключив режим автоматического подтверждения.
      </para>
      <para>
       Если вы не будете обрабатывать ошибки и завершать некорректную транзакцию,
       то дальнейшие вызовы API могут привести к ошибкам, таким как
       <literal>Commands out of sync; you can't run this command now</literal>.
       Запомните - это очень важно, обрабатывать все ошибки.
      </para>
     </listitem>
   </varlistentry>
   
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config-v2.transient_error">
    <term>
     <parameter>transient_error</parameter>
     <type>объект</type>
    </term>
    <listitem>
     <para>
      Настройка появилась в версии 1.6.0.
     </para>
     <para>
       Узел кластера базы данных может вернуть ошибку, вызванную кратковременным сбоем.
       Клиент может повторить запрос на том же узле, переключиться на другой, или вообще
       отменить запрос. Для подобных ошибок вполне безопасно использовать для
       повторного запроса тот же сервер.
      </para>
      <para>
       <literal>PECL/mysqlnd_ms</literal> может выполнить повтор запроса
       от имени приложения.
       С помощью <literal>transient_error</literal> можно настроить плагин
       для повтора запроса, завершившегося с конкретными ошибками определённое 
       количество раз с паузой между попытками. Если в процессе повтора ошибка 
       пропадёт, то приложение этого даже не заметит. Если все попытки 
       завершились неудачей, то приложению будет возвращена ошибка.
      </para>
      <para>
       <example>
        <title>Цикл повторов исправляемых ошибок</title>
        <programlisting role="ini">
<![CDATA[
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.78.136",
                "port": "3306"
            }
       },
       "transient_error": {
          "mysql_error_codes": [
            1297
          ],
          "max_retries": 2,
          "usleep_retry": 100
       }
    }
}
]]>
        </programlisting>
       </example>
      </para>
      <informaltable>
       <tgroup cols="3">
        <colspec colwidth="1*"/>
        <colspec colwidth="7*"/>
        <colspec colwidth="2*"/>
        <thead>
         <row>
          <entry>Ключ</entry>
          <entry>Описание</entry>
          <entry>Версия</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry>
           <literal>mysql_error_codes</literal>
          </entry>
          <entry>
           <para>
            Список исправляемых кодов ошибок. Вы можете добавить любые коды ошибок
            в этот список. Допустимо считать исправляемой любую ошибку, а не
            только <literal>1297</literal>
            (<literal>HY000 (ER_GET_TEMPORARY_ERRMSG),
            Message: Got temporary error %d '%s' from %s</literal>).
            Перед добавлением других кодов, кроме <literal>1297</literal>, в список,
            убедитесь, что кластер поддерживает повтор такого запроса без
            нарушения состояния вашего приложения.
           </para>
          </entry>
          <entry>Начиная с 1.6.0.</entry>
         </row>
         <row>
          <entry>
           <literal>max_retries</literal>
          </entry>
          <entry>
           <para>
            Максимальное количество повторов перед отправкой ошибки пользователю.
           </para>
           <para>
            По умолчанию: <literal>1</literal>
           </para>
          </entry>
          <entry>Начиная с 1.6.0.</entry>
         </row>
         <row>
          <entry>
           <literal>usleep_retry</literal>
          </entry>
          <entry>
           <para>
            Задержка в миллисекундах между повторами.
            Это значение будет передано C-функции <function>usleep</function>.
           </para>
           <para>
            По умолчанию: <literal>100</literal>
           </para>
          </entry>
          <entry>Начиная с 1.6.0.</entry>
         </row>
        </tbody>
       </tgroup>
      </informaltable>
     </listitem>
   </varlistentry>
   
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config-v2.xa">
    <term>
     <parameter>xa</parameter>
     <type>объект</type>
    </term>
    <listitem>
     <para>
      Настройка появилась в версии 1.6.0.
     </para>
     <para>
      <note>
       <title>Экспериментальный функционал</title>
       <para>
         Эта функциональность в данный момент находится в разработке, так что
         при её использовании могут возникать проблемы и ограничения.
         Не используйте в промышленном окружении.
        </para>
       </note>
      </para>
      <variablelist>
       <varlistentry>
        <term>state_store</term>
        <listitem>
         <variablelist xml:id="ini.mysqlnd-ms-plugin-config-v2.xa.state-store">
          <varlistentry>
           <term>record_participant_credentials</term>
           <listitem>
            <para>
             Сохранять ли имя пользователя и пароль участника глобальной транзакции 
             в таблице участников. Если отключено, сборщик мусора, при подключении 
             к серверам будет использовать имя и пароль по умолчанию. Если вы 
             не используете разных пользователей для разных серверов MySQL, то
             спокойно можно использовать значения по умолчанию и не сохранять
             эту информацию в хранилище состояния.
            </para>
            <para>
             Обратите внимание, что при использовании этого функционала, имя и пароль
             пользователя в хранилище состояния MySQL будут храниться в текстовом виде.
             Вся ответственность за обеспечение безопасности этой информации лежит на вас.
            </para>
            <para>
             По умолчанию: <literal>false</literal>
            </para>
           </listitem>
          </varlistentry>
          <varlistentry>
           <term>participant_localhost_ip</term>
           <listitem>
            <para>
             Во время сбора мусора XA, плагин может найти сервер участник, для
             которого был был записан хост <literal>localhost</literal>. Если
             сбор мусора запустился на другом хосте, но хост сделал запись
             участника в хранилище состояния, то <literal>localhost</literal> 
             будет разрешаться как другой хост. Поэтому при записи имени
             хоста участника в хранилище состояния следует использовать
             не <literal>localhost</literal>, а актуальный IP-адрес 
             <literal>localhost</literal>.
            </para>
            <para>
             Установка <literal>participant_localhost_ip</literal> должна использоваться
             только если нельзя избежать использования <literal>localhost</literal>.
             Если смотреть только с точки зрения сбора мусора, желательно не
             настраивать соединения с сокетом, а использовать IP-адрес и порт.
            </para>
           </listitem>
          </varlistentry>
          <varlistentry>
           <term>mysql</term>
           <listitem>
            <para>
             В качестве хранилища состояния доступно только хранилище состояния MySQL.
            </para>
            <variablelist>
             <varlistentry>
              <term>global_trx_table</term>
              <listitem>
               <para>
                Имя таблицы MySQL, используемой для хранения состояния текущей или
                оборванной глобальной транзакции. Для создания таблицы используйте
                приведённый ниже SQL-запрос. Не забудьте заменить имя таблицы на то,
                которое будете использовать в настройках.
               </para>
               <para>
                По умолчанию: <literal>mysqlnd_ms_xa_trx</literal>
               </para>
               <para>
                <example>
                 <title>SQL-запрос для создания таблицы хранилища состояния транзакции</title>
                 <programlisting role="sql">
<![CDATA[
CREATE TABLE mysqlnd_ms_xa_trx (
  store_trx_id int(11) NOT NULL AUTO_INCREMENT,
  gtrid int(11) NOT NULL,
  format_id int(10) unsigned NOT NULL DEFAULT '1',
  state enum('XA_NON_EXISTING','XA_ACTIVE','XA_IDLE','XA_PREPARED','XA_COMMIT','XA_ROLLBACK') NOT NULL DEFAULT 'XA_NON_EXISTING',
  intend enum('XA_NON_EXISTING','XA_ACTIVE','XA_IDLE','XA_PREPARED','XA_COMMIT','XA_ROLLBACK') DEFAULT 'XA_NON_EXISTING',
  finished enum('NO','SUCCESS','FAILURE') NOT NULL DEFAULT 'NO',
  modified timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  started datetime DEFAULT NULL,
  timeout datetime DEFAULT NULL,
  PRIMARY KEY (store_trx_id),
  KEY idx_xa_id (gtrid,format_id,finished),
  KEY idx_state (state)
) ENGINE=InnoDB
]]>
                   </programlisting>
                  </example>
                 </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                <term>participant_table</term>
                <listitem>
                 <para>
                  Имя таблицы MySQL, используемой для хранения информации об участниках
                  текущей или оборванной глобальной транзакции. Для создания таблицы используйте
                  приведённый ниже SQL-запрос. Не забудьте заменить имя таблицы на то,
                    которое будете использовать в настройках.
                   </para>
                   <para>
                    Хранение имени и пароля пользователя контролируется настройкой
                    <literal>record_participant_credentials</literal>
                   </para>
                   <para>
                    По умолчанию: <literal>mysqlnd_ms_xa_participants</literal>
                   </para>
                   <example>
                    <title>SQL-запрос для создания таблицы хранилища участников транзакции</title>
                    <programlisting role="sql">
<![CDATA[
CREATE TABLE mysqlnd_ms_xa_participants (
  fk_store_trx_id int(11) NOT NULL,
  bqual varbinary(64) NOT NULL DEFAULT '',
  participant_id int(10) unsigned NOT NULL AUTO_INCREMENT,
  server_uuid varchar(127) DEFAULT NULL,
  scheme varchar(1024) NOT NULL,
  host varchar(127) DEFAULT NULL,
  port smallint(5) unsigned DEFAULT NULL,
  socket varchar(127) DEFAULT NULL,
  user varchar(127) DEFAULT NULL,
  password varchar(127) DEFAULT NULL,
  state enum('XA_NON_EXISTING','XA_ACTIVE','XA_IDLE','XA_PREPARED','XA_COMMIT','XA_ROLLBACK')
   NOT NULL DEFAULT 'XA_NON_EXISTING',
  health enum('OK','GC_DONE','CLIENT ERROR','SERVER ERROR') NOT NULL DEFAULT 'OK',
  connection_id int(10) unsigned DEFAULT NULL,
  client_errno smallint(5) unsigned DEFAULT NULL,
  client_error varchar(1024) DEFAULT NULL,
  modified timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (participant_id),
  KEY idx_xa_bqual (bqual),
  KEY idx_store_trx (fk_store_trx_id),
  CONSTRAINT mysqlnd_ms_xa_participants_ibfk_1 FOREIGN KEY (fk_store_trx_id)
    REFERENCES mysqlnd_ms_xa_trx (store_trx_id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB
]]>
                    </programlisting>
                   </example>
                  </listitem>
               </varlistentry>
               <varlistentry>
                <term>garbage_collection_table</term>
                <listitem>
                 <para>
                  Имя таблицы MySQL используемой для отслеживания и синхронизации запуска
                  сбора мусора. Для создания таблицы используйте
                  приведённый ниже SQL-запрос. Не забудьте заменить имя таблицы на то,
                   которое будете использовать в настройках.
                  </para>
                  <para>
                   По умолчанию: <literal>mysqlnd_ms_xa_gc</literal>
                  </para>
                  <example>
                   <title>SQL-запрос для создания таблицы хранилища информации о сборе мусора</title>
                   <programlisting role="sql">
<![CDATA[
CREATE TABLE mysqlnd_ms_xa_gc (
  gc_id int(10) unsigned NOT NULL AUTO_INCREMENT,
  gtrid int(11) NOT NULL,
  format_id int(10) unsigned NOT NULL DEFAULT '1',
  fk_store_trx_id int(11) DEFAULT NULL,
  modified timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  attempts smallint(5) unsigned NOT NULL DEFAULT '0',
  PRIMARY KEY (gc_id),
  KEY idx_store_trx (gtrid,format_id,fk_store_trx_id)
) ENGINE=InnoDB
]]>
                   </programlisting>
                  </example>
                 </listitem>
               </varlistentry>
               <varlistentry>
                <term>host</term>
                <listitem>
                 <para>
                  Имя хоста сервера MySQL.
                 </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                <term>user</term>
                <listitem>
                 <para>
                  Имя пользователя.
                 </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                <term>password</term>
                <listitem>
                 <para>
                  Пароль.
                 </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                <term>db</term>
                <listitem>
                 <para>
                  База данных, в которой располагаются таблицы сборщика мусора.
                  Обратите внимание, что таблицы сборщика мусора необходимо
                  создать до использования плагина. Таблицы не создаются
                  во время исполнения и сборщик мусора не сможет без них работать.
                 </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                <term>port</term>
                <listitem>
                 <para>
                  Порт сервера MySQL.
                 </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                <term>socket</term>
                <listitem>
                 <para>
                  Доменный сокет unix для сервера MySQL. Обратите внимание,
                  что если вы используете несколько серверов PHP, то любой
                  из них может попытаться выполнить сборку мусора и должен
                  иметь доступ к хранилищу состояния. В этом случае вы можете
                  настроить IP-адрес и порт для сервера MySQL, хранящего
                  состояние, чтобы все серверы PHP могли к нему обратиться.
                 </para>
                </listitem>
               </varlistentry>
              </variablelist>
             </listitem>
            </varlistentry>
         </variablelist>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>rollback_on_close</term>
        <listitem>
         <para>
          Производить ли автоматический откат открытой глобальной транзакции
          при закрытии соединения. Если включено, то поведение будет аналогично
          поведению с локальными транзакциями. Как только клиент потерял
          соединение, сервер откатит все открытые и не завершённые транзакции.
         </para>
         <para>
          По умолчанию: <literal>true</literal>
         </para>
        </listitem>
       </varlistentry>
       <varlistentry xml:id="ini.mysqlnd-ms-plugin-config-v2.xa.gc">
        <term>garbage_collection</term>
        <listitem>
         <variablelist>
          <varlistentry>
           <term>max_retries</term>
           <listitem>
            <para>
             Максимальное количество попыток запуска сборки мусора. 
             Допустимы значения в диапазоне от <literal>0</literal> до <literal>100</literal>.
             <literal>0</literal> означает отсутствие ограничений, только если
             ограничения не настроены в хранилище состояния. Ограничения 
             хранилища состояния, предположительно, значительно выше, чем <literal>100</literal>.
             Доступно с версии 1.6.0.
            </para>
            <para>
             Обратите внимание, что крайне важно завершить ошибочные
             XA-транзакции за разумное время, чтобы сервера участники 
             могли высвободить занятые ими ресурсы. Встроенный сборщик мусора
             не ожидает, что будет завершаться с ошибкой длительное время, пока
             сбойные сервера приходят в себя. Все ещё возможны ситуации, когда
             может потребоваться вмешательство человека для решения проблем
             сборщика мусора. В этом случае сперва надо убедиться, что
             ситуацию нельзя разрешить принудительным запуском 
             <function>mysqlnd_ms_xa_gc</function>, а только потом принимать
             более серьёзные меры.
            </para>
            <para>
             По умолчанию: <literal>5</literal>
            </para>
           </listitem>
          </varlistentry>
          <varlistentry>
           <term>probability</term>
           <listitem>
            <para>
             Вероятность сбора мусора.
             Допустимы значения от <literal>0</literal> до <literal>1000</literal>.
             Установка <literal>0</literal> запрещает автоматический фоновый
             сбор мусора. Помните, что даже установив <literal>0</literal>, вы сможете
             запускать сборку мусора самостоятельно с помощью
             <function>mysqlnd_ms_gc</function>.
             Доступно с версии 1.6.0.
            </para>
            <para>
             Автоматический сбор мусора для зависшей XA-транзакции возможен только
             если настроено хранение состояния. Хранилище состояния отвечает за
             отслеживание XA-транзакции. Основываясь на записях в хранилище состояния
             можно определить участников транзакции и выполнить на них откат.
            </para>
            <para>
             Сбор мусора запускается в качестве в процессе завершения обработки
             веб-запроса PHP, как только ваш скрипт завершил работу. Надо ли
             запускать сборщик мусора, определяется вычислением случайного
             числа между <literal>0</literal> и <literal>1000</literal>. Если число выше
             или равно настроенной вероятности, то сборка будет запущена.
            </para>
            <para>
             По умолчанию: <literal>5</literal>
            </para>
           </listitem>
          </varlistentry>
          <varlistentry>
           <term>max_transactions_per_run</term>
           <listitem>
            <para>
             Максимальное количество XA-транзакций, которые будут обработаны за
             один запуск сборки мусора.
             Допустимы значения от <literal>1</literal> до <literal>32768</literal>.
             Доступно с версии 1.6.0.
            </para>
            <para>
             Зачистка незавершённый XA-транзакций требует значительных затрат
             времени и ресурсов. Сборщик мусора должен соединиться с несколькими
             участниками незавершённой транзакции и выполнить определённые
             SQL-запросы для её отката.
            </para>
            <para>
             По умолчанию: <literal>100</literal>
            </para>
           </listitem>
          </varlistentry>
         </variablelist>
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
   </varlistentry>
   </variablelist>
   </para>
  </section>
  
  <section xml:id="mysqlnd-ms.plugin-ini-v1">
   <title xmlns="http://docbook.org/ns/docbook">Файл конфигурации плагина (&lt;= 1.0.x)</title>
   <note>
    <para>
     Все дальнейшие описания относятся к PECL/mysqlnd_ms &lt; 1.1.0-beta.
     Они не используются в более ранних версиях.
    </para>
   </note>
   <para>
    Плагин использует собственный файл конфигурации.
    Файл конфигурации содержит информацию о главном сервере репликации MySQL, 
    подчинённых серверах репликации MySQL, политике выбора сервера 
    (балансировка нагрузки), стратегии обработки отказов и использовании
    ленивых соединений.
   </para>
   <para>
    Для определения конфигурационного файла используется директива конфигурации PHP
    <link linkend="ini.mysqlnd-ms.ini-file"><literal>mysqlnd_ms.ini_file</literal></link>.
   </para>
   <para>
    Конфигурационный файл используйет стандартный формат <literal>php.ini</literal>.
    Он содержит одну или несколько секций. Каждая секция содержит свою порцию
    настроек. Глобальной секции с настройками по умолчанию нет.
   </para>
   <para>
    Приложения обращаются к секциям по их именам. Имена секций сравниваются с именем
    хоста (сервера) при использовании функций соединения с MySQL расширений
    <link linkend="ref.mysqli">mysqli</link>,
    <link linkend="ref.mysql">mysql</link> и
    <link linkend="ref.pdo-mysql">PDO_MYSQL</link>. В момент соединения
    плагин <link linkend="book.mysqlnd">mysqlnd</link> сравнивает имя хоста с
    именами секций конфигурационного файла. Если они совпадают, то используются
    настройки соответствующей секции.
   </para>
   <para>
    <example>
     <title>Пример использования имён секций</title>
     <programlisting role="ini">
<![CDATA[
[myapp]
master[] = localhost
slave[] = 192.168.2.27
slave[] = 192.168.2.28:3306
[localhost]
master[] = localhost:/tmp/mysql/mysql.sock
slave[] = 192.168.3.24:3305
slave[] = 192.168.3.65:3309
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* Все соединения будут сбалансированы по нагрузке */
$mysqli = new mysqli("myapp", "username", "password", "database");
$pdo = new PDO('mysql:host=myapp;dbname=database', 'username', 'password');
$mysql = mysql_connect("myapp", "username", "password");

$mysqli = new mysqli("localhost", "username", "password", "database");
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Имена секций являются строками. Вполне допустимо использовать имена
   <literal>192.168.2.1</literal>, <literal>127.0.0.1</literal> или
   <literal>localhost</literal>. Если, к примеру, приложение соединяется 
   с <literal>localhost</literal> и в файле конфигурации есть секция
   <literal>[localhost]</literal>, то семантика операции соединения изменится.
   Приложение больше не будет использовать БД запущенную только на сервере
   <literal>localhost</literal>, так как плагин запустит процесс балансировки
   нагрузки в соответствии с настройкой секции <literal>[localhost]</literal>.
   Это позволит включить балансировку нагрузки для приложения без 
   переписывания его кода.
  </para>
  <para>
   Директивы <literal>master[]</literal>, <literal>slave[]</literal>
   и <literal>pick[]</literal> используют спископодобный синтаксис.
   Директивы с таким синтаксисом могут встречаться в
   конфигурационном файле множество раз в одной секции. Плагин использует
   опции в том порядке, как они определены в файле конфигурации. Рассмотрим
   пример ниже. В нем заданы две директивы <literal>slave[]</literal> в
   секции <literal>[myapp]</literal>. И если для операций чтения настроена политика
   балансировки round-robin, то первый такой запрос будет отправлен серверу
   <literal>mysql_slave_1</literal>, потому что он первый в списке.
   Второй запрос будет направлен серверу <literal>mysql_slave_2</literal>, так
   как он второй в списке. И т.д. Таким образом, спископодобные директивы
   читаются в том порядке, как они определены в файле конфигурации.
  </para>
  <para>
   <example>
    <title>Спископодобный синтакцис</title>
    <programlisting role="ini">
<![CDATA[
[myapp]
master[] = mysql_master_server
slave[] = mysql_slave_1
slave[] = mysql_slave_2
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Ниже приведено краткое описание директив конфигурации, которые можно использовать.
  </para>
  <para>
   <variablelist>
    <varlistentry xml:id="ini.mysqlnd-ms-plugin-config.master">
     <term>
      <parameter>master[]</parameter>
      <type>строка</type>
    </term>
    <listitem>
     <para>
      URI основного сервера репликации MySQL. URI имеет следующий синтаксис
      <literal>hostname[:port|unix_domain_socket]</literal>.
     </para>
     <para>
      Плагин может работать только с одним основным сервером.
     </para>
     <para>
      Определение основного сервера является обязательным. Если его не указать, то
      плагин выдаст предупреждение такого вида
      <literal>(mysqlnd_ms) Cannot find master section in config</literal>.
      Furthermore the plugin may set an error code for the connection handle such as
      <literal>HY000/2000 (CR_UNKNOWN_ERROR)</literal>. Текст ошибки может отличаться
      в зависимости от ваших языковых настроек.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config.slave">
    <term>
     <parameter>slave[]</parameter>
     <type>строка</type>
     </term>
     <listitem>
      <para>
       URI одного или нескольких подчинённых серверов. URI имеет следующий синтаксис
       <literal>hostname[:port|unix_domain_socket]</literal>.
      </para>
      <para>
       Плагин может работать с одним и более подчинёнными серверами.
      </para>
      <para>
       Определение хотя бы одного подчинённого сервера является обязательным.
       Если его не указать, то плагин выдаст предупреждение такого вида
       <literal>(mysqlnd_ms) Cannot find slaves section in config</literal>.
       Furthermore the plugin may set an error code for the connection handle such as
       <literal>HY000/2000 (CR_UNKNOWN_ERROR)</literal>. Текст ошибки может отличаться
       в зависимости от ваших языковых настроек.
      </para>
     </listitem>
   </varlistentry>
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config.pick">
    <term>
     <parameter>pick[]</parameter>
     <type>строка</type>
    </term>
    <listitem>
     <para>
      Политики балансировки нагрузки (выбора сервера). Поддерживаемые политики:
      <literal>random</literal>, <literal>random_once</literal> (по умолчанию),
      <literal>roundrobin</literal>, <literal>user</literal>.
     </para>
     <para>
      Если политики не определены, то будет использоваться
      <literal>random_once</literal>. Политика <literal>random_once</literal>
      выбирает один подчинённый сервер при первом запросе на чтение и использует
      его для таких запросов до конца работы скрипта.
     </para>
     <para>
      Политика <literal>random</literal> выбирает случайный подчинённый сервер
      для каждого нового запроса на чтение.
      </para>
      <para>
       Если настроена политика <literal>roundrobin</literal>, плагин
      перебирает подчинённые сервера по очереди, начиная с первого в списке и,
      когда доходит до конца списка, переходит в его начало.
      </para>
      <para>
       Установка более одной политики балансировки будет работать только
       для политики <literal>user</literal> и функции
       <function>mysqlnd_ms_set_user_pick_server</function>. Если определённая
       пользователем функция обратного вызова не смогла выбрать сервер, то
       плагин перейдёт к использованию второй сконфигурированной политики
       балансировки.
      </para>
     </listitem>
   </varlistentry>
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config.failover">
    <term>
     <parameter>failover</parameter>
     <type>строка</type>
    </term>
    <listitem>
     <para>
      Политика обработки отказов. Допустимые политики:
      <literal>disabled</literal> (по умолчанию), <literal>master</literal>.
     </para>
     <para>
      Если политика обработки отказов не определена, то никакой
       автоматической обработки отказов происходить не будет
       (<literal>failover=disabled</literal>). 
       Всякий раз, когда плагин не может подключиться к серверу, он будет выдавать
       предупреждение и устанавливать код ошибки и сообщение для соединения.
       Соответственно обработка ошибки, к примеру перезапуск последнего запроса
       на другом сервере, ложится на плечи приложения.
      </para>
      <para>
       Если используется <literal>failover=master</literal>, плагин будет неявно
       откатываться к подчинённому, если он есть. Пожалуйста, изучите
       документацию для понимания всех потенциальных рисков использования 
       <literal>failover=master</literal>.
      </para>
     </listitem>
   </varlistentry>
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config.lazy-connections">
    <term>
     <parameter>lazy_connections</parameter>
     <type>логическое</type>
    </term>
    <listitem>
     <para>
      Контролирует использование ленивых подключений. Ленивые подключения -
      это такие подключения, которые не устанавливаются пока клиент не пошлёт
      первый запрос. Включены по умолчанию.
      </para>
      <para>
       Ленивые подключения крайне рекомендованы к использованию, поскольку
       позволяют сильно сократить количество открытых соединений.
       Если вы запретите ленивые соединения, то, например, настроив кластер из
       одного основного сервера и двух подчинённых серверов, вы получите три одновременно
       открытых соединения при первом же подключении к базе, хотя в вашем скрипте
       используется только подключение к основному серверу.
      </para>
      <para>
       Леничные подключения не представляют опасности, если вы часто меняете 
       состояние подключения. Плагин не отправляет все изменения состояния во 
       все соединения из пула соединений. Небольшое количество изменений посылаются 
       только в открытые соединения. Ленивые соединения, открытые позже, не будут
       затронуты. Только небольшое количество настроек будут &quot;запоминаться&quot;
       и применяться к новым открытым ленивым соединениям.
      </para>
     </listitem>
   </varlistentry>
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config.master-on-write">
    <term>
     <parameter>master_on_write</parameter>
     <type>логическое</type>
    </term>
    <listitem>
     <para>
      Если установлено, то плагин начнёт использовать основной сервер
      только после того, как на нем будет выполнен первый запрос.
      Приложение также сможет использовать подчинённые сервера
      используя SQL-хинты.
      </para>
      <para>
       Эта настройка может помочь победить задержку репликации. Если, например, 
       будет запущен запрос <literal>INSERT</literal>, то, после него, все
       последующие запросы плагин будет отправлять на основной сервер,
       включая запросы типа <literal>SELECT</literal>. Это может
       помочь в случае, когда подчинённые сервера не успеют среплицировать
       результаты запроса <literal>INSERT</literal>.
      </para>
     </listitem>
   </varlistentry>
   <varlistentry xml:id="ini.mysqlnd-ms-plugin-config.trx-stickiness">
    <term>
     <parameter>trx_stickiness</parameter>
     <type>строка</type>
    </term>
    <listitem>
     
      <para>
       Политики привязки транзакции к серверу. Поддерживаемые политики:
       <literal>disabled</literal> (по умолчанию), <literal>master</literal>.
      </para>
      <para>
       Эксперементальная функциональность.
      </para>
      <para>
       Эта настройка требует версии PHP 5.4.0 или выше. Если использовать с более ранними
       версиями PHP, то плагин выдаст предупреждение вида
       <literal>(mysqlnd_ms) trx_stickiness strategy is not supported before PHP 5.3.99</literal>.
      </para>
      <para>
       Если политика не определена, либо установлена как
       <literal>trx_stickiness=disabled</literal>, то плагин может
       балансировать нагрузку и переключаться между серверами в течение
       транзакции. Плагин не транзакционно-безопасен. Для предотвращения
       переключения соединения в ходе транзакции можно использовать SQL-хинты.
      </para>
      <para>
       Начиная с PHP 5.4.0, библиотека mysqlnd позволяет отслеживать изменение 
       состояния режима <literal>autocommit</literal>, путём перехвата
       вызовов функции <literal>trx_autocommit()</literal>.
       Если задано <literal>set_stickiness=master</literal> и
       <literal>autocommit</literal> отключён расширением PHP MySQL путём
       вызова <literal>mysqlnd</literal> внутренней функции
       <literal>trx_autocommit()</literal>, плагин понимает, что начата транзакция,
       и все последующие запросы будут выполняться на основном сервере, 
       пока не будет включён <literal>autocommit</literal>. Соответственно
       можно не использовать SQL-хинты.
      </para>
      <para>
       Например, для вызова внутренней функции библиотеки <literal>mysqlnd</literal>
       <literal>trx_autocommit()</literal>, можно использовать
       <function>mysqli_autocommit</function>.
      </para>
      <para>
       Следует учесть, что даже с установкой <literal>trx_stickiness=master</literal>, 
       плагин не сможет перехватывать изменение режима <literal>autocommit</literal>,
       вызванное SQL-запросами, такими как <literal>SET AUTOCOMMIT=0</literal>.
      </para>
     </listitem>
   </varlistentry>
   </variablelist>
  </para>
  </section>
  
  <section xml:id="mysqlnd-ms.testing">
   <title xmlns="http://docbook.org/ns/docbook">Тестирование</title>
   <note>
    <para>
     Секция применима к mysqlnd_ms 1.1.0 или выше, не не к 1.0.
    </para>
   </note>
   <para>
    Набор тестов PECL/mysqlnd_ms содержится в директории <filename>tests/</filename>
    в исходных кодах расширения. Там содержатся стандартные тесты phpt,
    которые описаны на сайте PHP Quality Assurance Teams.
   </para>
   <para>
    Запуск тестов требует наличия от одного до четырёх серверов MySQL. Некоторые тесты
    вообще не соединяются с MySQL. Другим нужен один сервер. Некоторым два. В определённых
    случаях два сервера используются для эмуляции репликации. В других случаях
    требуются настроенные подчинённый и основной сервер репликации. Тесты попытаются
    определить, сколько всего и каким образом настроено серверов. Если конфигурация
    не подходящая, то соответствующие тесты будут автоматически пропущены.
   </para>
   <para>
    Перед запуском тестов отредактируйте <filename>tests/config.inc</filename> для
    настройки тестовых серверов MySQL.
   </para>
   <para>
    Наиболее простая конфигурация.
    <programlisting>
<![CDATA[
 putenv("MYSQL_TEST_HOST=localhost");
 putenv("MYSQL_TEST_PORT=3306");
 putenv("MYSQL_TEST_USER=root");
 putenv("MYSQL_TEST_PASSWD=");
 putenv("MYSQL_TEST_DB=test");
 putenv("MYSQL_TEST_ENGINE=MyISAM");
 putenv("MYSQL_TEST_SOCKET=");

 putenv("MYSQL_TEST_SKIP_CONNECT_FAILURE=1");
 putenv("MYSQL_TEST_CONNECT_FLAGS=0");
 putenv("MYSQL_TEST_EXPERIMENTAL=0");

 /* эмуляция кластера репликации */
 putenv("MYSQL_TEST_EMULATED_MASTER_HOST=". getenv("MYSQL_TEST_HOST"));
 putenv("MYSQL_TEST_EMULATED_SLAVE_HOST=". getenv("MYSQL_TEST_HOST"));

 /* реальный кластер репликации */
 putenv("MYSQL_TEST_MASTER_HOST=". getenv("MYSQL_TEST_EMULATED_MASTER_HOST"));
 putenv("MYSQL_TEST_SLAVE_HOST=". getenv("MYSQL_TEST_EMULATED_SLAVE_HOST"));
]]>
   </programlisting>
  </para>
  <para>
   <literal>MYSQL_TEST_HOST</literal>, <literal>MYSQL_TEST_PORT</literal> и
   <literal>MYSQL_TEST_SOCKET</literal> определяют имя хоста,
   TCP/IP порт и сокет Unix для тестового сервера по умолчанию.
   <literal>MYSQL_TEST_USER</literal> и <literal>MYSQL_TEST_PASSWD</literal>
   содержат имя пользователя и пароль для подключения к
   <literal>MYSQL_TEST_DB</literal>. Все настроенные сервера должны иметь 
   одинаковых пользователя и его пароль.
  </para>
  <para>
   Можно использовать любой синтаксис <literal>host</literal>, <literal>host:port</literal> или <literal>host:/path/to/socket</literal>.
   <programlisting>
<![CDATA[
putenv("MYSQL_TEST_SLAVE_HOST=192.168.78.136:3307"));
putenv("MYSQL_TEST_MASTER_HOST=myserver_hostname:/path/to/socket"));
]]>
    </programlisting>
  </para>
  </section>
  
  <section xml:id="mysqlnd-ms.debugging">
   <title xmlns="http://docbook.org/ns/docbook">Отладка и диагностика</title>
   <para>
    Для отладки PECL/mysqlnd_ms можно использовать лог отладки mysqlnd.
    О том, как mysqlnd PECL/mysqlnd_ms добавляет записи в лог библиотеки
    mysqlnd, читайте тут
    <link linkend="ini.mysqlnd.debug"><literal>mysqlnd.debug</literal></link>.
   </para>
   <para>
    Пример настроек для активации записи в лог отладки:
    <programlisting>
<![CDATA[
mysqlnd.debug=d:t:x:O,/tmp/mysqlnd.trace
]]>
   </programlisting>
   <note>
    <para>
     Эта возможность доступна только совместно с отладочной сборкой PHP. 
     Работает в Microsoft Windows если используется отладочная сборка PHP,
     собранная в Microsoft Visual C версии 9 и выше.
   </para>
   </note>
  </para>
  <para>
   Лог отладки показывает вызовы функций библиотеки mysqlnd и плагина
   PECL/mysqlnd_ms одинаково. Вызовы библиотеки mysqlnd обычно идут с префиксами
   <literal>mysqlnd_</literal>. Вызовы PECL/mysqlnd начинаются с
   <literal>mysqlnd_ms</literal>.
  </para>
  <para>
   Пример записи в отладочный лог (соединение):
   <programlisting>
<![CDATA[
[...]
>mysqlnd_connect
| info : host=myapp user=root db=test port=3306 flags=131072
| >mysqlnd_ms::connect
| | >mysqlnd_ms_config_json_section_exists
| | | info : section=[myapp] len=[5]
| | | >mysqlnd_ms_config_json_sub_section_exists
| | | | info : section=[myapp] len=[5]
| | | | info : ret=1
| | | <mysqlnd_ms_config_json_sub_section_exists
| | | info : ret=1
| | <mysqlnd_ms_config_json_section_exists
[...]
]]>
   </programlisting>
  </para>
  <para>
   Отладочный лог полезен не только разработчикам плагина, но и обычным
   пользователям для поиска ошибок. Например если приложение некорректно
   обрабатывает ошибки или не может самостоятельно их логировать, то
   разбор этого лога может помочь. Но помните, что использование этого
   лога для отладки ошибок приложения - это самое крайнее средство. Запись
   отладочного лога на диск - это медленная операция, которая может негативно
   сказаться на скорости работы приложения.
  </para>
  <para>
   Пример лога с ошибкой соединения:
   <programlisting>
<![CDATA[
[...]
| | | | | | | info : adding error [Access denied for user 'root'@'localhost' (using password: YES)] to the list
| | | | | | | info : PACKET_FREE(0)
| | | | | | | info : PACKET_FREE(0x7f3ef6323f50)
| | | | | | | info : PACKET_FREE(0x7f3ef6324080)
| | | | | | <mysqlnd_auth_handshake
| | | | | | info : switch_to_auth_protocol=n/a
| | | | | | info : conn->error_info.error_no = 1045
| | | | | <mysqlnd_connect_run_authentication
| | | | | info : PACKET_FREE(0x7f3ef63236d8)
| | | | | >mysqlnd_conn::free_contents
| | | | | | >mysqlnd_net::free_contents
| | | | | | <mysqlnd_net::free_contents
| | | | | | info : Freeing memory of members
| | | | | | info : scheme=unix:///tmp/mysql.sock
| | | | | | >mysqlnd_error_list_pdtor
| | | | | | <mysqlnd_error_list_pdtor
| | | | | <mysqlnd_conn::free_contents
| | | | <mysqlnd_conn::connect
[...]
]]>
   </programlisting>
  </para>
  <para>
   Лог трассировки также может быть полезен для проверки корректности
   поведения самого PECL/mysqlnd_ms. К примеру для проверки, какой сервер
   был выбран для выполнения запроса, и почему.
  </para>
  <para>
   Пример лога трассировки (выбор сервера):
   <programlisting>
<![CDATA[
[...]
>mysqlnd_ms::query
| info : query=DROP TABLE IF EXISTS test
| >_mysqlnd_plugin_get_plugin_connection_data
| | info : plugin_id=5
| <_mysqlnd_plugin_get_plugin_connection_data
| >mysqlnd_ms_pick_server_ex
| | info : conn_data=0x7fb6a7d3e5a0 *conn_data=0x7fb6a7d410d0
| | >mysqlnd_ms_select_servers_all
| | <mysqlnd_ms_select_servers_all
| | >mysqlnd_ms_choose_connection_rr
| | | >mysqlnd_ms_query_is_select
[...]
| | | <mysqlnd_ms_query_is_select
[...]
| | | info : Init the master context
| | | info : list(0x7fb6a7d3f598) has 1
| | | info : Using master connection
| | | >mysqlnd_ms_advanced_connect
| | | | >mysqlnd_conn::connect
| | | | | info : host=localhost user=root db=test port=3306 flags=131072 persistent=0 state=0
]]>
   </programlisting>
  </para>
  <para>
   В этом примере был выполнен запрос <literal>DROP TABLE IF EXISTS test</literal>.
   Обратите внимание, что SQL-запрос был записан в лог. Возможно вам придётся
   озаботится ограничением доступа к этому логу для сокрытия секретной информации.
  </para>
  <para>
   Для запроса использовалась политика балансировки round robin, как видно
   из имени функции <literal>>mysqlnd_ms_choose_connection_rr</literal>.
   Он был послан на основной сервер
   <literal>host=localhost user=root db=test port=3306 flags=131072 persistent=0 state=0</literal>.
  </para>
  </section>
  
  <section xml:id="mysqlnd-ms.monitoring">
   <title xmlns="http://docbook.org/ns/docbook">Мониторинг</title>
   <para>
    Работу плагина можно мониторить с помощью лога трассировки mysqlnd,
    статистики mysqlnd, статистики плагина mysqlnd_ms plugin и прочих внешних 
    инструментов. Использование лога трассировки рекомендуется использовать только 
    в целях отладки. Для стандартного мониторинга рекомендуется использовать
    статистику плагина.
   </para>
   <para>
    Запись лога трассировки - это медленная операция. При использовании внешних инструментов
    не забудьте прочитать документацию по ним для понимания возможного воздействия
    на производительность и списка собираемых метрик. Довольно часто внешние
    инструменты позволяют увидеть стек вызовов. Обычно стек вызовов и лог
    трассировки более трудны для восприятия, чем статистика предоставляемая плагином.
   </para>
   <para>
    Статистика позволяет увидеть, как часто используются определённые типы серверов
    кластера (подчинённый или основной), почему используется тот или иной сервер,
    использовались ли ленивые подключения и производились ли инъекции идентификатора
    глобальной транзакции. Предоставляемая информация позволяет пользователю
    проанализировать действия плагина по выбору серверов и запланировать использование
    кластерных ресурсов. Статистику можно получить с помощью функции
    <function>mysqlnd_ms_get_stats</function>. Список доступных метрик смотрите на
    странице посвящённой описанию этой функции.
   </para>
   <para>
    Статистика собирается для каждого процесса PHP. В зависимости от модели
    развёртывания, один процесс PHP может обслуживать как один, так и несколько
    пользовательских запросов. Если используется модель CGI, то один процесс PHP
    обслуживает ровно один пользовательский запрос. Для FastCGI или для модуля
    веб-сервера, один процесс PHP, обычно, обслуживает несколько запросов.
    Аналогично и для веб-серверов использующих потоки. Обратите внимание, что
    работающие параллельно потоки могут параллельно обновлять статистику. Таким 
    образом, при использовании многопоточной модели развёртывания PHP, статистику
    могут одновременно обновлять несколько пользовательских запросов, и это
    следует помнить при её анализе.
  </para>
  <para>
   <example>
    <title>Проверка активности плагина в однопоточной модели развёртывания</title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_ms.enable=1
mysqlnd_ms.collect_statistics=1
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* Балансировка нагрузки происходит согластно настройкам для секции "myapp" (не показаны) */
$mysqli = new mysqli("myapp", "username", "password", "database");
if (mysqli_connect_errno())
  /* Тут бы, конечно, ошибку обработать... Ну да ладно. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

$stats_before = mysqlnd_ms_get_stats();
if ($res = $mysqli->query("SELECT 'Read request' FROM DUAL")) {
  var_dump($res->fetch_all());
}
$stats_after = mysqlnd_ms_get_stats();
if ($stats_after['use_slave'] <= $stats_before['use_slave']) {
  echo "Согласно статистике, запрос на чтение выполнялся не на подчинённом сервере!";
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Статистика агрегируется для всех действий плагина и всех подключений, обрабатываемых 
   плагином. Определить, сколько конкретно было обработано подключений невозможно.
  </para>
  <para>
   С помощью функции <function>register_shutdown_function</function> или настройки PHP
   <literal>auto_append_file</literal> можно легко настроить запись статистической
   информации в, например, файл, по завершению работы скрипта. Или не писать в файл, а
   посылать во внешнюю систему мониторинга.
  </para>
  <para>
   <example>
    <title>Запись статистики в процессе остановки</title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_ms.enable=1
mysqlnd_ms.collect_statistics=1
error_log=/tmp/php_errors.log
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
function check_stats() {
  $msg = str_repeat("-", 80) . "\n";
  $msg .= var_export(mysqlnd_ms_get_stats(), true) . "\n";
  $msg .= str_repeat("-", 80) . "\n";
  error_log($msg);
}
register_shutdown_function("check_stats");
?>
]]>
    </programlisting>
   </example>
  </para>
  </section>
 </section>
 
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
