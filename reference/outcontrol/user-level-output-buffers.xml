<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 7610e990293c87168d026ad078d8272e643e2c23 Maintainer: sergey Status: ready -->
<!-- Reviewed: no -->
<chapter xml:id="outcontrol.user-level-output-buffers" xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude">
 <section>
  <title>Пользовательские буферы вывода</title>
  <para>
   Пользовательские буферы вывода разрешено запускать, манипулировать ими
   и завершать из PHP-кода.
   Каждый из этих буферов включает в себя буфер вывода
   и связанную с ним функцию обработчика вывода.
  </para>
 </section>

 <section>
  <title>Какой вывод буферизуется?</title>
  <para>
   Пользовательские буферы вывода PHP после запуска полностью буферизуют вывод
   до тех пор, пока они не будут выключены или скрипт не завершит работу.
   Вывод в контексте пользовательского буфера вывода PHP —
   это всё что PHP отобразил или отправил обратно в браузер.
   С практической точки зрения, вывод — это данные ненулевой длины, которые:
   <itemizedlist>
    <xi:include xpointer="xmlns(db=http://docbook.org/ns/docbook) xpointer(id('outputcontrol.what-is-output')/*)"><xi:fallback/></xi:include>
   </itemizedlist>
  </para>
  <note>
   <simpara>
    Data that is written directly to <literal>stdout</literal>
    or passed to an SAPI function with a similar functionality
    will not be captured by user-level output buffers.
    This includes
    writing data to <literal>stdout</literal> with <function>fwrite</function>
    or sending headers using <function>header</function>
    or <function>setcookie</function>.
   </simpara>
  </note>
 </section>

 <section>
  <title>Turning Output Buffering On</title>
  <para>
   Output buffering can be turned on by using
   the <function>ob_start</function> function or by setting
   the <link linkend="ini.output-buffering">output_buffering</link>
   and <link linkend="ini.output-handler">output_handler</link>
   &php.ini; settings.
   While both can create output buffers,
   <function>ob_start</function> is more flexible
   as it accepts user-defined functions as output handlers
   and the operations allowed on the buffer (flush, clean, remove)
   can be set as well.
   Buffers started with <function>ob_start</function> will be active
   from the line the function was called,
   while those started with
   <link linkend="ini.output-buffering">output_buffering</link>
   will be buffering output from the first line of the script.
  </para>
  <para>
   PHP is also shipped with a built-in <literal>"URL-Rewriter"</literal>
   output handler which starts its own output buffer and only allows
   up to two instances of it running at any time
   (one for user-level URL-rewriting
   and one for transparent session id support).
   These buffers can be started by calling
   the <function>output_add_rewrite_var</function> function
   and/or by enabling the
   <link linkend="ini.session.use-trans-sid">session.use_trans_sid</link>
   &php.ini; setting.
  </para>
  <para>
   The bundled <literal>zlib</literal> extension has its own
   output buffer which can be enabled by using the
   <link linkend="ini.zlib.output-compression">zlib.output_compression</link>
   &php.ini; setting.
  </para>
  <note>
  <para>
   If an uncaught exception is thrown in an output handler during shutdown,
   the handler is terminated and neither the contents of the buffer
   nor the error message is flushed.
  </para>
  <note>
   <simpara>
    If a handler throws an exception
    its <constant>PHP_OUTPUT_HANDLER_DISABLED</constant> status flag is set.
   </simpara>
  </note>
 </section>

 <section>
  <title>Errors Raised In Output Handlers</title>
  <para>
   If a non-fatal error is raised in an output handler
   the program continues execution.
  </para>
  <para>
   If the non-fatal error is raised in a handler invoked by
   <function>ob_flush</function>, <function>ob_end_flush</function>
   or <function>ob_get_flush</function>,
   the buffer flushes certain data depending on the return value of the handler.
   If the handler returns &false; the buffer and the error message are flushed.
   If the returns anything else the handler return value is flushed
   but not the error message.
  </para>
  <note>
   <simpara>
    If a handler returns &false;
    its <constant>PHP_OUTPUT_HANDLER_DISABLED</constant> status flag is set.
   </simpara>
  </note>
  <para>
   If a fatal error is raised in an output handler
   the program terminates and the handler is invoked
   by the shutdown process after which the error message is flushed.
  </para>
  <para>
   If the fatal error is raised in a handler
   invoked by <function>ob_flush</function>,
   <function>ob_end_flush</function> or <function>ob_get_flush</function>,
   the contents of the buffers are flushed before the error message.
  </para>
  <para>
   If a fatal error is raised in an output handler during shutdown
   the program terminates without flushing the buffer or the error message.
  </para>
 </section>

 <section>
  <title>Output In Output Handlers</title>
  <para>
   In specific circumstances, output produced in the handler is flushed
   along with the contents of the buffer.
   This output is not appended to the buffer and is not part of the string
   returned by <function>ob_get_flush</function>.
  </para>
  <para>
   During flush operations (calling <function>ob_flush</function>,
   <function>ob_end_flush</function>, <function>ob_get_flush</function>
   and during shutdown)
   if the return value of a handler is &false;
   the contents of the buffer are flushed followed by the output.
   If the handler is not invoked during shutdown
   the handler throwing an exception or <function>exit</function> being called
   results in the same behavior.
  </para>
  <note>
   <simpara>
    If a handler returns &false;
    its <constant>PHP_OUTPUT_HANDLER_DISABLED</constant> status flag is set.
   </simpara>
  </note>
 </section>

 <section>
  <title>Output Handler Status Flags</title>
  <para>
   The
   <link linkend="outcontrol.constants.flags-returned-by-handler">
    handler status flags
   </link> of the buffer's <literal>flags</literal> bitmask
   are set every time to the output handler is invoked
   and are part of the <literal>flags</literal> returned by
   <function>ob_get_status</function>.
   If the handler successfully executes and does not return &false;,
   <constant>PHP_OUTPUT_HANDLER_STARTED</constant> and
   <constant>PHP_OUTPUT_HANDLER_PROCESSED</constant> is set.
   If the handler returns &false; or throws and exception while executing,
   <constant>PHP_OUTPUT_HANDLER_STARTED</constant> and
   <constant>PHP_OUTPUT_HANDLER_DISABLED</constant> is set.
  </para>
  <note>
   <simpara>
    If the <constant>PHP_OUTPUT_HANDLER_DISABLED</constant> of a handler is set,
    the handler will not be invoked by calling
    <function>ob_end_clean</function>, <function>ob_end_flush</function>,
    <function>ob_get_clean</function>, <function>ob_get_flush</function>
    or during PHP's shutdown process.
    This flag has no effect on when calling <function>ob_clean</function>
    or <function>ob_flush</function>.
   </simpara>
  </note>
 </section>

</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
