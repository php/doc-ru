<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: ed9c01378f221478d0c4ec634cdb27003330c18b Maintainer: aur Status: ready -->
<!-- Reviewed: yes Maintainer: Alexandra Moskaleva -->
<!-- $Revision$ -->
<chapter xml:id="session.security" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Безопасность сессий</title>
 <para>
  Внешние ссылки: <link xlink:href="&url.session-fixation;">Атака "Фиксация сессии"</link>
 </para>
 <para>
  Работа с HTTP сессиями является основой web безопасности. 
  Все улучшения должны применяться только убедившись в безопасности сессий.
  Разработчик должен включать и использовать соответствующие настройки 
  соответствующим образом.
 </para>

 <itemizedlist>
  <listitem>
   <simpara>
    <link linkend="ini.session.cookie-lifetime">session.cookie_lifetime</link>=0.
    У 0 есть специальное значение. Он указывает браузерам не хранить cookie
    в постоянном хранилище. Тогда, при завершении работы браузера,
    cookie с сессионным ID сразу же удаляется. Если разработчик устанавливает
    значение отличное от нуля - это может позволить другим пользователям
    воспользоваться этим сессионным ID. Большинство приложений должны использовать
    значение "0". Если требуется функционал автоматической аутотентификации,
    необходимо реализовать отдельный безопасный функционал. Не используйте для этого
    сессионный ID.
   </simpara>
  </listitem>

  <listitem>
   <simpara>
    <link linkend="ini.session.use-cookies">session.use_cookies</link>=On и
    <link linkend="ini.session.use-only-cookies">session.use_only_cookies</link>=On.
    Не смотря на то, что у HTTP cookie есть некоторые проблемы, cookie являются
    предпочтительным способом управления сессионным ID. Если возможно, то используте 
    только cookie для этих целей. Большинство приложений должны их использовать.
   </simpara>
  </listitem>

  <listitem>
   <simpara>
    <link linkend="ini.session.use-strict-mode">session.use_strict_mode</link>=On.
    Запрещает сессионному модулю использовать неинициализированный сессионный ID.
    Другими словами, сессионный модуль принимает только допустимые ID,
    созданные им же. Он отбрасывает ID, задаваемые пользователем.
    Внедрение сессионного ID может осуществляться cookie-инъекцией 
    через JavaScript. При включенной прозрачной обработке сессии,
    сессионный ID может быть внедрен через строку запроса или 
    параметр формы. Нет причин принимать созданные пользователем сессионные ID,
    большинство приложений не должны принимать их.
   </simpara>
  </listitem>

  <listitem>
   <simpara>
    <link linkend="ini.session.cookie-httponly">session.cookie_httponly</link>=On.
    Запрещает доступ к сессионной cookie для JavaScript. Эта опция
    предотвращает кражу cookie с помощью JavaScript инъекции. Можно
    использовать сессионный ID как защитный ключ CSRF, но не рекомендуется.
    Например, HTML может быть сохранен и отправлен другому пользователю. 
    Разработчик не должен записывать сессионный ID внутри web-страницы для повышения безопасности.
    Почти все приложения должны использовать аттрибут httponly для сессионной cookie.
   </simpara>
  </listitem>

  <listitem>
   <simpara>
    <link linkend="ini.session.cookie-secure">session.cookie_secure</link>=On.
    Позволяет получать доступ к cookie сессионной ID только при использовании
    протокола HTTPS. Если ваш сайт использует только протокол HTTPS, вам необходимо включить 
    эту опцию. Для таких сайтов нужно также рассматривать использование HSTS.
   </simpara>
  </listitem>

  <listitem>
   <simpara>
    <link linkend="ini.session.gc-maxlifetime">session.gc_maxlifetime</link>=[наименьшее возможное].
    Сборка мусора производится с некоторой вероятностью. Поэтому эта опция не гарантирует
    удаление старых сессий. Некоторые модули обработки сохранения сессий не
    используют эту опцию. Обратитесь к документации по обработке
    сохранения сессий. Хотя разработчик и не может полагаться на эту опцию,
    тем не менее рекомендуется установить эту опцию с наименьшим возможным значением.
    Задайте <link linkend="ini.session.gc-probability">session.gc_probability</link> и
    <link linkend="ini.session.gc-divisor">session.gc_divisor</link>
    так, чтобы истекшие сессии удалялись с необходимой частотой. 
    Если требуется функционал автоматической аутотентификации, необходимо реализовать 
    отдельный безопасный функционал. Не используйте для этого
    сессионный ID.
   </simpara>
  </listitem>

  <listitem>
   <simpara>
    <link linkend="ini.session.use-trans-sid">session.use_trans_sid</link>=Off.
    Использование прозрачного управления сессионным ID не рекомендуется.
    Вы можете использовать его, если необходимо. Однако, отключение прозрачного
    управления повышает безопасность сессий в целом, убирая возможность
    инъекции сессионного ID и его кражи.
   </simpara>
  </listitem>

  <listitem>
   <simpara>
    <link linkend="ini.session.referer-check">session.referer_check</link>=[your originating URL]
    Если <link linkend="ini.session.use-trans-sid">session.use_trans_sid</link>
    включен, то рекомендуется использовать эту опцию, если это возможно.
    Это уменьшает риск для инъекции сессионного ID. Если ваш сайт
    находится по адресу http://example.com/, то установите этой опции значение http://example.com/. 
    Обратите внимание, что при использовании HTTPS, браузер не отправляет 
    referrer заголовок. Таким образом, этот параметр не является достаточно 
    надежным показателем безопасности.
   </simpara>
  </listitem>

  <listitem>
   <simpara>
    <link linkend="ini.session.cache-limiter">session.cache_limiter</link>=nocache.
    Убедитесь, что HTTP контент не закэширован для аутотентификационной сессии.
    Допускается кешировать только неконфиденциальный контент. Иначе
    содержимым могут воспользоваться. Можно использовать значение "private",
    если HTTP контент не содержит чувствительные к безопасности данные. Учтите, что
    "private" может оставлять конфиденциальные данные в общем кэше клиентов.
    Значение "public" можно использовать только, если HTTP контент вообще не содержит
    никаких конфиденциальных данных.
   </simpara>
  </listitem>

  <listitem>
   <simpara>
    <link linkend="ini.session.hash-function">session.hash_function</link>="sha256".
    Более сложная хэш функция будет создавать более сложный сессионный ID.
    Хотя хэш коллизии почти не происходят и с MD5 хэшом, тем не менее
    разработчику лучше использовать функции SHA-2 или новее. Разработчики
    также могут использовать сложные функции sha384 и sha512
   </simpara>
  </listitem>
 </itemizedlist>
 
 <para>
  Модуль сессии не позволяет гарантировать, что хранимая информация доступна
  только пользователю, который создал сессию. Необходимо принять дополнительные
  меры по защите конфиденциальности сессии, основываясь на ассоциированных с ней данных.
 </para>

 <para>
  Оценка важности данных, передаваемых в рамках сессии, важна для выбора мер по
  защите этой информации -- обычно это приводит к ухудшению удобства для
  конечного пользователя. Например, если необходимо защитить пользователя от
  простейших методов социальной инженерии, следует включить
  <literal>session.use_only_cookies</literal>. В данном случае со стороны
  пользовательского ПО обязательна поддержка cookie, иначе механизм сессий не
  будет работать.
 </para>

 <para>
  Существует несколько способов утечки существующего идентификатора сессии
  третьим лицам. Такая утечка позволяет злоумышленнику получить доступ ко всем
  данным, ассоциированным с конкретным идентификатором сессии. Во-первых,
  передача идентификатора сессии в URL. При переходе на внешний сайт
  идентификатор сессии пользователя и адрес ресурса могут попасть в статистику
  переходов данного сайта. Во-вторых, при более активной атаке возможно
  прослушивание сетевого трафика злоумышленником. Если канал передачи данных не
  зашифрован, идентификаторы сессии будут переданы в виде простого текста. В
  таком случае решением является обязательное использование SSL пользователями
  при доступе к сайту. Для этих целей следует применять HSTS.
 </para>

 <para>
  С версии PHP 5.5.2 доступна опция  <link linkend="ini.session.use-strict-mode">session.use_strict_mode</link>. 
  При ее включении и при условии, что модуль сохранения сессий ее поддерживает,
  неинициализированный сессионный ID отвергается и создается новый.
  Это защищает от атак, которые принуждают пользователя использовать
  заранее извесный ID. Ататкующий может размещать ссылки или отправлять письма,
  которые содержат сессионный ID. Например http://example.com/page.php?PHPSESSID=123456789 .
  Если опция <link linkend="ini.session.use-trans-sid">session.use_trans_sid</link> включена, то
  жертва откроет сессию с этим идентификатором. Опция <link linkend="ini.session.use-strict-mode">session.use_strict_mode</link> уменьшает этот риск.
 </para>

 <para>
  Даже при уменьшении риска с помощью <link linkend="ini.session.use-strict-mode">session.use_strict_mode</link>
  атакующий все еще может заставить пользователя использовать
  уже инициализированную сессию, созданную атакующим.
  Атакующий создает ее до атаки и поддерживает ее существование.
 </para>

 <para>
  Cookie с сессионным ID должна устанавливаться с указанием domain, path, httponly и secure. 
  Их приоритетность определяется браузерами.
  Опираясь на эту приоритетность, атакующий может может установить сессионный ID, который 
  будет использоваться бесконечно. Применение <link linkend="ini.session.use-only-cookies">session.use_only_cookies</link>
  не решает эту проблему. <link linkend="ini.session.use-strict-mode">session.use_strict_mode</link>
  уменьшает риск. <link linkend="ini.session.use-strict-mode">session.use_strict_mode</link>=On,
  не допускает использование неинициализированных сессионных ID.
  Сессионный модуль создает новый ID каждый раз, как получает 
  неизвестный ID. Это может привести к DoS атаке на жертву, но
  это лучше, чем компрометация аккаунта.
 </para>

 <para>
  Использование <link linkend="ini.session.use-strict-mode">session.use_strict_mode</link>
  полезно, но не достаточно для аутентификационной сессии.
  Разработчик должен использовать также функцию <function>session_regenerate_id</function>
  для аутентификации. Функцию <function>session_regenerate_id</function> нужно
  вызывать до записи информации об аутетификации в $_SESSION.
  Только в этом случае функция <function>session_regenerate_id</function> гарантирует, что
  только новая сессия содержит данные аутетификации, так как 
  во время процесса аутотентификации могут возникнуть ошибки и данные 
  могли бы остаться в старой сессии.
 </para>

 <para>
  Вызов функции <function>session_regenerate_id</function> может 
  привести к персональной DoS атаке как и при use_strict_mode=On. 
  Однако, DoS лучше, чем компрометация аккаунта. Пересоздание сессионного ID 
  должно происходить хотя бы при аутентификации пользователя.
  Пересоздание ID уменьшает риск кражи сессии, поэтому рекомендуется
  периодически выполнять его. Разработчик не должен пологаться
  на устаревание сессионного ID. Атакующий может обращаться с сессионным
  ID жертвы периодически для предотвращения его истекания. 
  Разработчик должен самостоятельно реализовать функционал для 
  истекания старых сессий.
 </para>

 <para>
  Обратите внимание, что <function>session_regenerate_id</function> по умолчанию 
  не удаляет старые сесии. Старая аутетифицированная сессия может оставаться доступной.
  Если разработчик хочет предотвратить дальнейшее использование старой сессии,
  то он должен уничтожать сессию, установив <parameter>delete_old_session</parameter>
  в &true;. Однако, незамедлительное удаление старых сессий может привести
  к неожиданным побочным эффектам. Сессия может быть утеряна в случае
  нескольких конкурентных соединений к web-приложению и/или если сетевое
  соединение нестабильно. Вместо незамедлительного удаления вы можете установить 
  маленькое значение времени истекания для $_SESSION. Если пользователь
  обращется с устаревшей сессией, отклоните его запрос.
 </para>

 <para>
  <link linkend="ini.session.use-only-cookies">session.use_only_cookies</link>
  и правильное использование <function>session_regenerate_id</function> могут
  привести к персональной DoS. Если такое происходит, то вы можете попросить
  пользователя удалить cookie и предупредить его о возможных проблемах
  с безопасностью. Атакующий может устанавливать вредные cookie через уязвимость
  в web-приложении (т.е. JavaScript инъекция), уязвимость в браузерном плагине и т.д.
 </para>

 <para>
  Разработчикам не рекомендуется использовать долгоживущие сессионные ID
  для автоматического входа пользователей из-за повышения риска
  кражи сессий. Автоматический вход должен реализовываться самим
  разработчиком. Используйте одноразовые хэш ключи безопасности как
  ключи для автоматического входа через cookie. Используте хэши
  сложнее чем SHA-2, т.е. SHA-256 и сложнее с использованием случайных данных
  из /dev/urandom и т.д. Если пользователь не аутентифицирован, проверьте
  верный или нет у него одноразовый хэш.
  Если ключ верен, аутентифицируйте пользователя и задайте новый одноразовый хэш.
  Ключ для автоматического входа является долгоживущим ключем, этот ключ
  должен быть максимально защищенным. Используйте аттрибуты path/httponly/secure
  для защиты cookie. Разработчик должен реализовать функционал, который
  может выключать автоматический вход и удалять ненужные ключи из cookie.
 </para>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

