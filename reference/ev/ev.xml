<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 8cb9d7813bde97cf284728199d1d66d1cfea1f34 Maintainer: rjhdby Status: ready -->
<!-- Reviewed: no -->
<!-- $Revision$ -->
<phpdoc:classref xml:id="class.ev" xmlns:phpdoc="http://php.net/ns/phpdoc" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude">
 <title>Класс Ev</title>
 <titleabbrev>Ev</titleabbrev>
 <partintro>
  <!-- {{{ Ev intro -->
  <section xml:id="ev.intro">
   &reftitle.intro;
   <para>
    Класс EV является статическим классом, обеспечивая доступ к циклу
    по умолчанию и некоторым распространенным операциям.
   </para>
  </section>
  <!-- }}} -->
  <section xml:id="ev.synopsis">
   &reftitle.classsynopsis;
   
   <!-- {{{ Synopsis -->
   <classsynopsis>
    <ooclass>
     <classname>Ev</classname>
    </ooclass>
    <!-- {{{ Class synopsis -->
    <classsynopsisinfo>
     <ooclass>
      <modifier>final</modifier>
      <classname>Ev</classname>
     </ooclass>
    </classsynopsisinfo>
    <!-- }}} -->
    <classsynopsisinfo role="comment">Константы</classsynopsisinfo>
    <!--{{{-->
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.flag-auto">Ev::FLAG_AUTO</varname>
     <initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.flag-noenv">Ev::FLAG_NOENV</varname>
     <initializer>16777216</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.flag-forkcheck">Ev::FLAG_FORKCHECK</varname>
     <initializer>33554432</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.flag-noinotify">Ev::FLAG_NOINOTIFY</varname>
     <initializer>1048576</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.flag-signalfd">Ev::FLAG_SIGNALFD</varname>
     <initializer>2097152</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.flag-nosigmask">Ev::FLAG_NOSIGMASK</varname>
     <initializer>4194304</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.run-nowait">Ev::RUN_NOWAIT</varname>
     <initializer>1</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.run-once">Ev::RUN_ONCE</varname>
     <initializer>2</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.break-cancel">Ev::BREAK_CANCEL</varname>
     <initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.break-one">Ev::BREAK_ONE</varname>
     <initializer>1</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.break-all">Ev::BREAK_ALL</varname>
     <initializer>2</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.minpri">Ev::MINPRI</varname>
     <initializer>-2</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.maxpri">Ev::MAXPRI</varname>
     <initializer>2</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.read">Ev::READ</varname>
     <initializer>1</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.write">Ev::WRITE</varname>
     <initializer>2</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.timer">Ev::TIMER</varname>
     <initializer>256</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.periodic">Ev::PERIODIC</varname>
     <initializer>512</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.signal">Ev::SIGNAL</varname>
     <initializer>1024</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.child">Ev::CHILD</varname>
     <initializer>2048</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.stat">Ev::STAT</varname>
     <initializer>4096</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.idle">Ev::IDLE</varname>
     <initializer>8192</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.prepare">Ev::PREPARE</varname>
     <initializer>16384</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.check">Ev::CHECK</varname>
     <initializer>32768</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.embed">Ev::EMBED</varname>
     <initializer>65536</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.custom">Ev::CUSTOM</varname>
     <initializer>16777216</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.error">Ev::ERROR</varname>
     <initializer>2147483648</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.backend-select">Ev::BACKEND_SELECT</varname>
     <initializer>1</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.backend-poll">Ev::BACKEND_POLL</varname>
     <initializer>2</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.backend-epoll">Ev::BACKEND_EPOLL</varname>
     <initializer>4</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.backend-kqueue">Ev::BACKEND_KQUEUE</varname>
     <initializer>8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.backend-devpoll">Ev::BACKEND_DEVPOLL</varname>
     <initializer>16</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.backend-port">Ev::BACKEND_PORT</varname>
     <initializer>32</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.backend-all">Ev::BACKEND_ALL</varname>
     <initializer>63</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
     <modifier>const</modifier>
     <type>integer</type>
     <varname linkend="ev.constants.backend-mask">Ev::BACKEND_MASK</varname>
     <initializer>65535</initializer>
    </fieldsynopsis>
    <!--}}}-->
    <classsynopsisinfo role="comment">&Methods;</classsynopsisinfo>
    <xi:include xpointer="xmlns(db=http://docbook.org/ns/docbook) xpointer(id('class.ev')/db:refentry/db:refsect1[@role='description']/descendant::db:methodsynopsis[1])" />
   </classsynopsis>
   <!-- }}} -->
  </section>
  <!-- {{{ Ev constants -->
  <section xml:id="ev.constants">
   &reftitle.constants;
   
   <para xml:id="ev.constants.loop-flags">
    Флаги, передаваемые при создании цикла:
    <!--{{{-->
    <variablelist>
     <varlistentry xml:id="ev.constants.flag-auto">
      <term>
       <constant>Ev::FLAG_AUTO</constant>
      </term>
      <listitem>
       <para>
        задает флагам значение по умолчанию 
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.flag-noenv">
      <term>
       <constant>Ev::FLAG_NOENV</constant>
      </term>
      <listitem>
       <para>
        Если этот флаг используется (или программа запускает setuid или setgid), то
        <literal>libev</literal> не смотрит на переменную окружения
        <varname>LIBEV_FLAGS</varname>. В противном случае (по умолчанию), если найден
        <varname>LIBEV_FLAGS</varname>, то он полностью переопределяет флаги. 
        Полезно для тестов производительности и поиска ошибок.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.flag-forkcheck">
      <term>
       <constant>Ev::FLAG_FORKCHECK</constant>
      </term>
      <listitem>
       <para>
        Заставляет libev проверять ветвление в каждой итерации, вместо вызова
        <methodname>EvLoop::fork</methodname> вручную. Это работает путем вызова
        <literal>getpid()</literal> на каждой итерации цикла, и, таким образом, это может
        замедлить работу цикла событий с большим количеством итераций цикла, но обычно не
        сильно. Этот флаг не может быть переопределен или указан в переменной среды
        <varname>LIBEV_FLAGS</varname>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.flag-noinotify">
      <term>
       <constant>Ev::FLAG_NOINOTIFY</constant>
      </term>
      <listitem>
       <para>
        Если этот флаг указан, то <literal>libev</literal>
        не будет пытаться использовать API <literal>inotify</literal> для своих наблюдателей
        <link xlink:href="http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#code_ev_stat_code_did_the_file_attri">ev_stat</link>
        Флаг может быть полезным для сохранения файловых дескрипторов inotify,
        в противном случае каждый цикл использующий наблюдателей <literal>ev_stat</literal>,
        будет потреблять один дескриптор <literal>inotify</literal>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.flag-signalfd">
      <term>
       <constant>Ev::FLAG_SIGNALFD</constant>
      </term>
      <listitem>
       <para>
        Если этот флаг указан,то <literal>libev</literal>
        будет пытаться использовать API <literal>signalfd</literal>
        для своих наблюдателей
        <link xlink:href="http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#code_ev_signal_code_signal_me_when_a">ev_signal</link>
        (и
        <link xlink:href="http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#code_ev_child_code_watch_out_for_pro">ev_child</link>). 
        Это API передает сигналы синхронно, что делает его быстрее и, возможно, позволит
        получить данные из очереди сигналов, а также позволяет упростить обработку сигналов 
        с помощью потоков, поскольку сигналы корректно блокируются в потоках.
        <literal>Signalfd</literal> не используется по умолчанию.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.flag-nosigmask">
      <term>
       <constant>Ev::FLAG_NOSIGMASK</constant>
      </term>
      
      <listitem>
       <para>
        Если указан этот флаг, то <literal>libev</literal>
        будет избегать изменения маски сигнала. В частности, это применяется чтобы перед 
        получением сигнала убедиться, что он разблокирован.
       </para>
       <para>
        Такое поведение полезно для обработки пользовательских сигналов или обработки
        сигналов только определенных потоков.
       </para>
     </listitem>
    </varlistentry>
    </variablelist>
   </para>
   <!--}}}-->
   <para xml:id="ev.constants.run-flags">
    Флаги, передаваемые в <methodname>Ev::run</methodname>,
    или <methodname>EvLoop::run</methodname>
    <!--{{{-->
    <variablelist>
     <varlistentry xml:id="ev.constants.run-nowait">
      <term>
       <constant>Ev::RUN_NOWAIT</constant>
      </term>
      <listitem>
       <para>
        Означает, что цикл событий будет искать и обрабатывать новые события, а также любые
        ожидающие выполнения события из них, но не будет ждать и блокировать процесс
        в случае, если не было никаких событий и завершится после одной итерации цикла.
        Это иногда полезно для опроса и обработки новых событий во время выполнения
        длительных вычислений, сохраняя при этом возможность взаимодействия с программой. 
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.run-once">
      <term>
       <constant>Ev::RUN_ONCE</constant>
      </term>
      <listitem>
       <para>
        Означает, что цикл событий будет искать новые события (ожидая, в случае необходимости)
        и обрабатывать эти и любые уже ожидающие события из них.
        Он будет блокировать процесс, пока не поступит по крайней мере одно новое событие
        (это может быть внутреннее событие libev, поэтому нет никакой гарантии, что будет 
        вызвана заданная callback-функция) и завершится после одной итерации цикла.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   <!--}}}-->
   <para xml:id="ev.constants.break-flags">
    Флаги, передаваемые в
    <methodname>Ev::stop</methodname>
    , или
    <methodname>EvLoop::stop</methodname>
    <!--{{{-->
    <variablelist>
     <varlistentry xml:id="ev.constants.break-cancel">
      <term>
       <constant>Ev::BREAK_CANCEL</constant>
      </term>
      <listitem>
       <para>
        Отмена операции прерывания.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.break-one">
      <term>
       <constant>Ev::BREAK_ONE</constant>
      </term>
      <listitem>
       <para>
        Возвращает самый глубокий запрос
        <methodname>Ev::run</methodname>
        (или
        <methodname>EvLoop::run</methodname>
        ).
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.break-all">
      <term>
       <constant>Ev::BREAK_ALL</constant>
      </term>
      <listitem>
       <para>
        Завершает все вложенные вызовы
        <methodname>Ev::run</methodname>
        (или
        <methodname>EvLoop::run</methodname>
        ).
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   <!--}}}-->
   <para xml:id="ev.constants.watcher-pri">
    Приоритеты наблюдателей:
    <!--{{{-->
    <variablelist>
     <varlistentry xml:id="ev.constants.minpri">
      <term>
       <constant>Ev::MINPRI</constant>
      </term>
      <listitem>
       <para>
        Минимально допустимый приоритет наблюдателя.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.maxpri">
      <term>
       <constant>Ev::MAXPRI</constant>
      </term>
      <listitem>
       <para>
        Максимально допустимый приоритет наблюдателя.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   <!--}}}-->
   <para xml:id="ev.constants.watcher-revents">
    Битовые маски (полученных) событий:
    <!--{{{-->
    <variablelist>
     <varlistentry xml:id="ev.constants.read">
      <term>
       <constant>Ev::READ</constant>
      </term>
      <listitem>
       <para>
        Дескриптор файла в наблюдателе
        <classname>EvIo</classname>
        доступен для чтения.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.write">
      <term>
       <constant>Ev::WRITE</constant>
      </term>
      <listitem>
       <para>
        Дескриптор файла в наблюдателе
        <classname>EvIo</classname>
        доступен для записи.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.timer">
      <term>
       <constant>Ev::TIMER</constant>
      </term>
      <listitem>
       <para>       
        <classname>EvTimer</classname>
        наблюдает за превышением лимита времени.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.periodic">
      <term>
       <constant>Ev::PERIODIC</constant>
      </term>
      <listitem>
       <para>
        <classname>EvPeriodic</classname>
        наблюдает за превышением лимита времени.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.signal">
      <term>
       <constant>Ev::SIGNAL</constant>
      </term>
      <listitem>
       <para>
        Указанный в
        <methodname>EvSignal::__construct</methodname>
        сигнал получен.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.child">
      <term>
       <constant>Ev::CHILD</constant>
      </term>
      <listitem>
       <para>
        <parameter>pid</parameter>
        указанный в
        <methodname>EvChild::__construct</methodname>
        получен и статус изменен.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.stat">
      <term>
       <constant>Ev::STAT</constant>
      </term>
      <listitem>
       <para>
        Путь, указанный в наблюдателе
        <classname>EvStat</classname>
        поменял свои аттрибуты.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.idle">
      <term>
       <constant>Ev::IDLE</constant>
      </term>
      <listitem>
       <para>
        Наблюдатель <classname>EvIdle</classname>
        работает, когда остальные наблюдатели ничего не делают.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.prepare">
      <term>
       <constant>Ev::PREPARE</constant>
      </term>
      <listitem>
       <para>
        Все наблюдатели 
        <classname>EvPrepare</classname>
        вызваны ровно перед стартом
        <methodname>Ev::run</methodname>
        таким образом, наблюдатели
        <classname>EvPrepare</classname>
        являются последними вызванными наблюдателями перед тем, как
        цикл событий заснет или опросит новые события.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.check">
      <term>
       <constant>Ev::CHECK</constant>
      </term>
      <listitem>
       <para>
        Все наблюдатели 
        <classname>EvCheck</classname>
        помещены в очередь сразу после того, как
        <methodname>Ev::run</methodname>
        собрал новые события, но до того, как они вызовут какую либо callback-функцию
        для полученных событий.
        Таким образом, наблюдатели 
        <classname>EvCheck</classname>
        будут вызваны раньше, чем любые другие наблюдатели с таким же
        либо более низким приоритетом в этой итерации цикла событий.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.embed">
      <term>
       <constant>Ev::EMBED</constant>
      </term>
      <listitem>
       <para>
        Встроенный цикл событий, заданный в наблюдателе
        <classname>EvEmbed</classname>
        требует к себе внимания.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.custom">
      <term>
       <constant>Ev::CUSTOM</constant>
      </term>
      <listitem>
       <para>
        Никогда не посылается (или иным образом используется) библиотекой
        <literal>libev</literal>
        самостоятельно, но может свободно использоваться пользователями
        <literal>libev</literal>
        для сигнализирующих наблюдателей (т.е. с помощью
        <methodname>EvWatcher::feed</methodname>
        ).
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.error">
      <term>
       <constant>Ev::ERROR</constant>
      </term>
      <listitem>
       <para>
        Произошла неизвестная ошибка и наблюдатель будет остановлен.
        Может произойти из-за некорректного запуска наблюдателя, потому, что
        <literal>libev</literal>
        исчерпал лимит по памяти, из-за закрытого дескриптора файла или по
        какой либо еще причине.
        <literal>Libev</literal>
        считает, что эти ошибки приложения. 
        Также читайте раздел
        <link xlink:href="http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#ANATOMY_OF_A_WATCHER_CONTENT">АНАТОМИЯ НАБЛЮДАТЕЛЕЙ</link>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   <!--}}}-->
   <para xml:id="ev.constants.watcher-backends">
    Флаги бэкенда:
    <!--{{{-->
    <variablelist>
     <varlistentry xml:id="ev.constants.backend-select">
      <term>
       <constant>Ev::BACKEND_SELECT</constant>
      </term>
      <listitem>
       <para>
        <literal>выбор бекенда - select(2)</literal>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.backend-poll">
      <term>
       <constant>Ev::BACKEND_POLL</constant>
      </term>
      <listitem>
       <para>
        <literal>опрос бэкенда - poll(2)</literal>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.backend-epoll">
      <term>
       <constant>Ev::BACKEND_EPOLL</constant>
      </term>
      <listitem>
       <para>
        Специфичный для Linux бэкенд
        <literal>epoll(7)</literal>
        для ядер до и после 2.6.9
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.backend-kqueue">
      <term>
       <constant>Ev::BACKEND_KQUEUE</constant>
      </term>
      <listitem>
       <para>
        <literal>kqueue</literal> -
        бэкенд используемый в большинстве систем BSD.
        Наблюдатель <classname>EvEmbed</classname>
        может быть использован для всавки одного цикла (с бэкендом kqueue) в
        другой. Например, можно попытаться создать цикл событий с
        бэкендом <literal>kqueue</literal>
        и использовать его только для сокетов.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.backend-devpoll">
      <term>
       <constant>Ev::BACKEND_DEVPOLL</constant>
      </term>
      <listitem>
       <para>
        Бэкенд Solaris 8. Пока не реализован.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.backend-port">
      <term>
       <constant>Ev::BACKEND_PORT</constant>
      </term>
      <listitem>
       <para>
        Механизм порта событий с хорошим масштабированием в Solaris 10.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.backend-all">
      <term>
       <constant>Ev::BACKEND_ALL</constant>
      </term>
      <listitem>
       <para>
        Пробовать все бэкенды (кроме испорченных).
        Не рекомендуется использовать напрямую.
        Тут необходимо использовать побитовые операции
        (т.е.
        <constant>Ev::BACKEND_ALL</constant>
        &amp; ~
        <constant>Ev::BACKEND_KQUEUE</constant>
        ). Использовать
        <methodname>Ev::recommendedBackends</methodname>
        , или не задавать никакого бэкенда вообще.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry xml:id="ev.constants.backend-mask">
      <term>
       <constant>Ev::BACKEND_MASK</constant>
      </term>
      <listitem>
       <para>
        Не бэкенд, но маска для выбора всех бит бэкендов из значения
        <parameter>flags</parameter>, для
        исключения каких либо бэкендов.
        (т.е. когда модифицируете переменную окружения
        <varname>LIBEV_FLAGS</varname>).
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   <!--}}}-->
   <note xmlns="http://docbook.org/ns/docbook">
    <para>
     Для цикла по умолчанию, во время фазы инициализации 
     модуля <literal>Ev</literal>, регистрируется вызов 
     <link xlink:href="http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#FUNCTIONS_CONTROLLING_EVENT_LOOPS_CO">ev_loop_fork</link>
     с помощью <literal>pthread_atfork</literal> (если таковой имеется).
    </para>
   </note>
   <note xmlns="http://docbook.org/ns/docbook">
    <para>
     Есть методы, позволяющие получить доступ к <emphasis>циклу событий по 
     умолчанию</emphasis> в классе <classname>Ev</classname> (например,
     <methodname>Ev::iteration</methodname>, <methodname>Ev::depth</methodname> 
     и т.д.). Для <emphasis>пользовательских циклов</emphasis> (созданных с помощью 
     <methodname>EvLoop::__ construct</methodname>) эти значения могут быть доступны
     через соответствующие свойства и методы класса <classname>EvLoop</classname>.
    </para>
    <para>
     Экземпляр цикла событий по умолчению может быть извлечен с
     помощью метода <methodname>EvLoop::defaultLoop</methodname>.
    </para>
   </note>
  </section>
  <!-- }}} -->
 </partintro>
 
 &reference.ev.entities.ev;
 
</phpdoc:classref>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
