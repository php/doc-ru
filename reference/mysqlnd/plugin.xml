<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 9598935f21bc472f22383fb989625f0b22785331 Maintainer: rjhdby Status: ready -->
<!-- Reviewed: no -->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="mysqlnd.plugin">
 <title>API интеграции плагинов в драйвер MySQL Native Driver</title>
 <simpara>
  Драйвер MySQL Native Driver, или <literal>mysqlnd</literal>, предоставляет API, через который плагины встраиваются
  в драйвер.
  Плагины драйвера <literal>mysqlnd</literal>
  работают на уровне между PHP-приложениями и MySQL-сервером, аналогично
  приложению MySQL Proxy, которое также работает между клиентскими приложениями и сервером MySQL.
  Плагины драйвера <literal>mysqlnd</literal> выполняют типовые
  задачи MySQL Proxy наподобие балансировки нагрузки, мониторинга и оптимизации
  быстродействия. Из-за другой архитектуры и места обработки запросов
  плагины драйвера <literal>mysqlnd</literal> не содержат недочётов MySQL Proxy наподобие
  единой точки отказа, не требуют установки отдельного прокси-сервера
  и изучения нового языка программирования Lua.
 </simpara>
 <simpara>
  Плагин <literal>mysqlnd</literal> расширяет функции драйвера
  <literal>mysqlnd</literal>. Плагин умеет перехватывать вызовы функций
  драйвера <literal>mysqlnd</literal> из MySQL-модулей PHP наподобие
  <literal>ext/mysql</literal>, <literal>ext/mysqli</literal> и <literal>PDO_MYSQL</literal>.
  Поэтому плагинам драйвера <literal>mysqlnd</literal> доступен перехват каждого запроса,
  который модули выполнили из клиентского приложения.
 </simpara>
 <simpara>
  Плагины умеют перехватывать или подменять вызовы внутренних функций драйвера <literal>mysqlnd</literal>.
  API не ограничивает модификацию таблиц внутренних функций драйвера <literal>mysqlnd</literal>
  и разрешает перенаправлять вызовы конкретных функций драйвера <literal>mysqlnd</literal>
  из <literal>mysqlnd</literal>-модулей на функции <literal>mysqlnd</literal>-плагина.
  Управление таблицей внутренних функций
  драйвера <literal>mysqlnd</literal> даёт плагинам максимум гибкости.
 </simpara>
 <simpara>
  Плагины драйвера <literal>mysqlnd</literal> — фактически PHP-модули на языке C,
  которые работают через API интеграции <literal>mysqlnd</literal>-плагинов
  в PHP-драйвер MySQL Native Driver, или <literal>mysqlnd</literal>.
  Плагины на 100 % прозрачны
  для PHP-приложений. Приложение не требуется изменять, поскольку плагины работают
  на другом уровне. С точки зрения поведения, <literal>mysqlnd</literal>-плагин
  работает на уровень ниже <literal>mysqlnd</literal>-драйвера, поскольку переопределяет поведение драйвера.
 </simpara>
 <simpara>
  Следующий список приводит примеры практических задач,
  которые решают посредством плагинов драйвера <literal>mysqlnd</literal>.
 </simpara>
 <itemizedlist>
  <listitem>
   <simpara>
    Балансировка нагрузки
   </simpara>
   <itemizedlist>
    <listitem>
     <simpara>
      Разделение чтения и записи. Пример —
      модуль PECL/mysqlnd_ms (Master Slave). Модуль разделяет
      запросы на чтение и запись для настройки репликации.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Отказоустойчивость
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Циклическое распределение запросов по принципу Round-Robin для равномерной нагрузки, распределение на наименее загруженный сервер
     </simpara>
    </listitem>
   </itemizedlist>
  </listitem>
  <listitem>
   <simpara>
    Мониторинг
   </simpara>
   <itemizedlist>
    <listitem>
     <simpara>
      Логирование запросов
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Анализ запросов
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Аудит запросов. Пример —
      модуль PECL/mysqlnd_sip (SQL Injection Protection, защита
      от SQL-инъекций). Модуль инспектирует запросы
      и выполняет только те, которые соответствуют набору правил.
     </simpara>
    </listitem>
   </itemizedlist>
  </listitem>
  <listitem>
   <simpara>
    Производительность.
   </simpara>
   <itemizedlist>
    <listitem>
     <simpara>
      Кеширование. Пример —
      модуль PECL/mysqlnd_qc (Query Cache, кеширование запросов).
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Ограничение числа запросов
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Шардирование. Пример — модуль PECL/mysqlnd_mc
      (Multi Connect). Модуль пытается разбить запрос
      SELECT на n частей через SELECT ... LIMIT part_1,
      SELECT LIMIT part_n. Модуль отправляет запросы
      на отдельные MySQL-серверы и объединяет результаты на клиенте.
     </simpara>
    </listitem>
   </itemizedlist>
  </listitem>
 </itemizedlist>
 <simpara>
  <emphasis role="bold">Доступные плагины драйвера MySQL Native Driver</emphasis>
 </simpara>
 <simpara>
  Репозитории PECL уже содержит ряд mysqlnd-плагинов, включая следующие:
 </simpara>
 <itemizedlist>
  <listitem>
   <simpara>
    <emphasis role="bold">mysqlnd_mc</emphasis> — Multi
    Connect, разбивка запросов по шардам.
   </simpara>
  </listitem>
  <listitem>
   <simpara>
    <emphasis role="bold">mysqlnd_ms</emphasis> — Master
    Slave, разделение запросов на чтение и запросов на запись.
   </simpara>
  </listitem>
  <listitem>
   <simpara>
    <emphasis role="bold">mysqlnd_qc</emphasis> — Query
    Cache, кеширование результатов запросов.
   </simpara>
  </listitem>
  <listitem>
   <simpara>
    <emphasis role="bold">mysqlnd_pscache</emphasis> —
    Prepared Statement Handle Cache, обработка
    кеширования подготовленных запросов.
   </simpara>
  </listitem>
  <listitem>
   <simpara>
    <emphasis role="bold">mysqlnd_sip</emphasis> — SQL
    Injection Protection, защита от SQL-инъекций.
   </simpara>
  </listitem>
  <listitem>
   <simpara>
    <emphasis role="bold">mysqlnd_uh</emphasis> — User
    Handler, обработка пользователей.
   </simpara>
  </listitem>
 </itemizedlist>
 <section xml:id="mysqlnd.plugin.mysql-proxy">
  <title>Сравнение плагинов mysqlnd с MySQL Proxy</title>
  <simpara>
   Плагины <literal>mysqlnd</literal> и приложение MySQL Proxy — разные
   технологии с разными подходами. Оба инструмента решают
   стандартные задачи наподобие балансировки
   нагрузки, мониторинга и улучшения производительности.
   Важное отличие состоит в том, что приложение MySQL Proxy работает
   со всеми MySQL-клиентами, тогда как плагины
   <literal>mysqlnd</literal> работают только с PHP-приложениями.
  </simpara>
  <simpara>
   Как PHP-модуль, плагин <literal>mysqlnd</literal> устанавливается
   на сервер PHP-приложений вместе с остальными компонентами
   PHP-дистрибутива. MySQL Proxy запускают на сервере
   приложений PHP или устанавливают на отдельной машине
   для поддержки множественных серверов PHP-приложений.
  </simpara>
  <simpara>
   Установка MySQL Proxy на сервере приложений даёт два преимущества:
  </simpara>
  <orderedlist>
   <listitem>
    <simpara>
     Отсутствие единой точки отказа
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Лёгкость в горизонтальном масштабировании и масштабировании за счёт клиента
    </simpara>
   </listitem>
  </orderedlist>
  <simpara>
   Приложение MySQL Proxy и плагины <literal>mysqlnd</literal>
   легко решают проблемы, которые иначе
   потребовали бы изменений в текущих приложениях.
  </simpara>
  <simpara>
   Тем не менее, MySQL Proxy содержит и ряд недостатков:
  </simpara>
  <itemizedlist>
   <listitem>
    <simpara>
     MySQL Proxy — новый элемент и технология, которую потребуется изучить и установить.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     MySQL Proxy требует знания скриптового языка Lua.
    </simpara>
   </listitem>
  </itemizedlist>
  <simpara>
   Приложения MySQL Proxy настраиваются под конкретные задачи средствами языков C и Lua.
   Lua — предпочтительный скриптовый язык для MySQL
   Proxy. Для большей части PHP-экспертов Lua новый
   язык, который потребуется изучать. Плагин
   драйвера <literal>mysqlnd</literal> пишут на C
   или на PHP через модуль <link xlink:href="&url.pecl.package;mysqlnd_uh">PECL/mysqlnd_uh</link>.
  </simpara>
  <simpara>
   MySQL Proxy работает как демон — фоновый процесс. MySQL Proxy может вспомнить ранее
   принятые решения, так как все состояние может быть сохранено. Однако плагины
   <literal>mysqlnd</literal> привязаны к жизненному циклу PHP, базирующемуся на
   запросах. Также MySQL Proxy может разделять единожды полученный результат между
   разными серверами приложений. Плагины <literal>mysqlnd</literal> для решения этой
   задачи должны использовать какое-нибудь постоянное хранилище, для сохранения
   результатов между запросами. Например, для этого может быть использован другой демон,
   такой как Memcache. Так что в этом случае MySQL Proxy работает явно лучше.
  </simpara>
  <simpara>
   MySQL Proxy работает поверх сетевых протоколов. С помощью
   MySQL Proxy вы можете разобрать и подвергнуть инженерному
   анализу протокол MySQL Client Server. Что-либо поменять
   можно только манипулируя протоколом обмена. Если протокол
   вдруг поменяется (что бывает крайне редко), скрипты
   MySQL Proxy потребуется переписывать.
  </simpara>
  <simpara>
   Плагины <literal>Mysqlnd</literal> работают поверх C API,
   который дублирует клиент <literal>libmysqlclient</literal>. Этот API-интерфейс языка C по сути обычная обёртка вокруг
   протокола MySQL Client Server. Вы можете перехватывать каждый
   вызов API-интерфейса C. PHP использует API-интерфейс C, фактически можно
   перехватывать вообще каждый вызов PHP, без программирования на уровне протокола обмена.
  </simpara>
  <simpara>
   <literal>Mysqlnd</literal> реализует протокол обмена.
   Таким образом, плагины могут перехватывать, исследовать, менять
   и даже целиком заменять протокол связи. Хотя
   обычно ничего этого не требуется.
  </simpara>
  <simpara>
   Плагины позволяют вам использовать два уровня (C API и
   протокол обмена), в этом они гораздо гибче, чем MySQL
   Proxy. Если плагин <literal>mysqlnd</literal> реализован с
   использованием C API, изменения протокола обмена не
   потребуют изменения плагина.
  </simpara>
 </section>
 <section xml:id="mysqlnd.plugin.obtaining">
  <title>Получение API плагинов mysqlnd</title>
  <simpara>
   API плагинов <literal>mysqlnd</literal> является частью
   стандартного модуля <literal>ext/mysqlnd</literal>.
   API плагинов <literal>mysqlnd</literal> начали разрабатывать
   в декабре 2009 года. Он разрабатывался как часть
   репозитория исходных кодов PHP и, соответственно,
   доступен через публичный репозиторий Git либо через
   загрузку снапшота исходных кодов.
  </simpara>
  <simpara>
   Разработчики плагинов узнают версию <literal>mysqlnd</literal> путём доступа
   к <literal>MYSQLND_VERSION</literal> — строка в формате <quote>mysqlnd 8.3.17</quote>,
   или через <literal>MYSQLND_VERSION_ID</literal> — числовое представление версии
   наподобие 50007. Разработчики вычисляют номер версии из этого числа следующим способом:
  </simpara>
  <table xml:id="mysqlnd.plugin.version-id">
   <title>Таблица расчёта MYSQLND_VERSION_ID</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Версия (часть)</entry>
      <entry>Пример</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>Major*10000</entry>
      <entry>5*10000 = 50000</entry>
     </row>
     <row>
      <entry>Minor*100</entry>
      <entry>0*100 = 0</entry>
     </row>
     <row>
      <entry>Patch</entry>
      <entry>7 = 7</entry>
     </row>
     <row>
      <entry>MYSQLND_VERSION_ID</entry>
      <entry>50007</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <simpara>
   Разработчики отслеживают версию драйвера
   <literal>mysqlnd</literal> на предмет совместимости и версионного тестирования,
   поскольку версии <literal>mysqlnd</literal> иногда изменяется
   в процессе работы над плагином.
  </simpara>
 </section>
 <section xml:id="mysqlnd.plugin.architecture">
  <title>Архитектура плагинов MySQL Native Driver </title>
  <simpara>
   В секции рассматривается архитектура плагинов
   драйвера <literal>mysqlnd</literal>.
  </simpara>
  <simpara>
   <emphasis role="bold">Обзор MySQL Native Driver</emphasis>
  </simpara>
  <simpara>
   Перед началом разработки плагинов для драйвера
   <literal>mysqlnd</literal> полезно узнать,
   как организован сам драйвер <literal>mysqlnd</literal>.
   <literal>Mysqlnd</literal> состоит из следующих модулей:
  </simpara>
  <table xml:id="mysqlnd.plugin.orgchart">
   <title>Организационная схема mysqlnd, помодульно</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Модули статистики</entry>
      <entry>mysqlnd_statistics.c</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>Соединение</entry>
      <entry>mysqlnd.c</entry>
     </row>
     <row>
      <entry>Результирующий набор</entry>
      <entry>mysqlnd_result.c</entry>
     </row>
     <row>
      <entry>Метаданные результирующего набора</entry>
      <entry>mysqlnd_result_meta.c</entry>
     </row>
     <row>
      <entry>Оператор</entry>
      <entry>mysqlnd_ps.c</entry>
     </row>
     <row>
      <entry>Сеть</entry>
      <entry>mysqlnd_net.c</entry>
     </row>
     <row>
      <entry>Протокол обмена</entry>
      <entry>mysqlnd_wireprotocol.c</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <simpara>
   <emphasis role="bold">Объектно-ориентированная парадигма C</emphasis>
  </simpara>
  <simpara>
   На уровне кода, <literal>mysqlnd</literal> использует
   паттерн C для реализации объектно-ориентированного подхода.
  </simpara>
  <simpara>
   В C объекты описывают используя <literal>struct</literal>.
   Члены структуры являются свойствами объекта.
   Члены структуры, указывающие на функции, являются
   методами.
  </simpara>
  <simpara>
   В отличие от таких языков как C++ или Java, в C нет фиксированных правил наследования.
   Однако существуют некоторые договорённости, которым необходимо следовать,
   но это мы обсудим позже.
  </simpara>
  <simpara>
   <emphasis role="bold">Жизненный цикл PHP</emphasis>
  </simpara>
  <simpara>
   При рассмотрении жизненного цикла PHP существует два основных цикла:
  </simpara>
  <itemizedlist>
   <listitem>
    <simpara>
     Цикл старта и остановки движка PHP
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Цикл обработки запроса
    </simpara>
   </listitem>
  </itemizedlist>
  <simpara>
   При старте движка PHP, первым делом вызывается функция
   инициализации модулей (MINIT) для каждого зарегистрированного модуля. Это
   позволяет каждому модулю установить переменные и выделить ресурсы,
   которые будут задействованы все время жизни процесса
   движка PHP. Когда движок PHP выключается, он вызывает
   функцию остановки модулей (MSHUTDOWN) для каждого модуля.
  </simpara>
  <simpara>
   На протяжении жизненного цикла движка PHP, он принимает некоторое количество
   запросов. Каждый запрос порождает новый жизненный цикл. На каждый запрос, движок PHP
   вызывает функцию инициализации для каждого модуля. Модуль может предпринять
   выставление переменных и выделение ресурсов, требуемых для обслуживания запроса.
   По окончании жизни запроса, движок вызывает функцию остановки запроса (RSHUTDOWN)
   для каждого модуля, что позволяет им произвести необходимые чистки.
  </simpara>
  <simpara>
   <emphasis role="bold">Как работает плагин</emphasis>
  </simpara>
  <simpara>
   Плагин <literal>mysqlnd</literal> работает перехватывая
   вызовы модулей, использующих <literal>mysqlnd</literal>,
   к <literal>mysqlnd</literal>. Это достигается подменой
   таблицы функций <literal>mysqlnd</literal> на созданную
   плагином.
  </simpara>
  <simpara>
   Следующий код демонстрирует замену таблицы функций
   <literal>mysqlnd</literal>:
  </simpara>
  <programlisting>
<![CDATA[
/* хранилище оригинальной таблицы */
struct st_mysqlnd_conn_methods org_methods;

void minit_register_hooks(TSRMLS_D) {
  /* активная таблица функций */
  struct st_mysqlnd_conn_methods * current_methods
    = mysqlnd_conn_get_methods();

  /* бэкап оригинальной таблицы */
  memcpy(&org_methods, current_methods,
    sizeof(struct st_mysqlnd_conn_methods);

  /* установка новых методов */
  current_methods->query = MYSQLND_METHOD(my_conn_class, query);
}
]]>
  </programlisting>
  <simpara>
   Манипуляцией с таблицей функций соединения необходимо
   заниматься на этапе инициализации модуля (MINIT). Таблица
   функций — глобальный разделяемый ресурс.
   В многопоточном окружении, со сборкой TSRM, манипуляция
   глобальным разделяемым ресурсом на этапе обработки
   запроса вызовет конфликты.
  </simpara>
  <note>
   <simpara>
    Не используйте логику, которая связана
    с фиксированным размером при манипуляции с таблицей
    функций <literal>mysqlnd</literal>. Всегда добавляйте
    новые методы в конец таблицы, так как сама таблица может
    в будущем в любой момент измениться.
   </simpara>
  </note>
  <simpara>
   <emphasis role="bold">Вызов родительских методов</emphasis>
  </simpara>
  <simpara>
   Если записи оригинальной таблицы функций сохранились,
   остаётся возможность вызвать оригинальный метод — родительский.
  </simpara>
  <simpara>
   В отдельных случаях, например, для <literal>Connection::stmt_init()</literal>, жизненно
   важно сначала вызвать родительский метод, и только потом делать
   что-либо в новом методе.
  </simpara>
  <programlisting>
<![CDATA[
MYSQLND_METHOD(my_conn_class, query)(MYSQLND *conn,
  const char *query, unsigned int query_len TSRMLS_DC) {

  php_printf("my_conn_class::query(query = %s)\n", query);

  query = "SELECT 'query rewritten' FROM DUAL";
  query_len = strlen(query);

  return org_methods.query(conn, query, query_len); /* возврат с вызовом родителя */
}
]]>
  </programlisting>
  <simpara>
   <emphasis role="bold">Расширение свойств</emphasis>
  </simpara>
  <simpara>
   Объекты <literal>mysqlnd</literal> представлены как C struct.
   Невозможно добавить члена в C struct во время исполнения.
   Пользователи объектов <literal>mysqlnd</literal> не могут
   просто добавить свойства объекту.
  </simpara>
  <simpara>
   Произвольные данные (свойства) могут быть добавлены к
   объекту <literal>mysqlnd</literal> с использованием
   соответствующей функции из семейства
   <literal>mysqlnd_plugin_get_plugin_&lt;object&gt;_data()</literal>.
   При размещении объекта <literal>mysqlnd</literal>
   резервируется место в конце объекта для удержания
   <literal>void *</literal> указателя на произвольные данные.
   <literal>mysqlnd</literal> резервирует место для одного
   <literal>void *</literal> указателя на плагин.
  </simpara>
  <simpara>
   В следующей таблице показано, как вычислить положение указателя для конкретного плагина:
  </simpara>
  <table xml:id="mysqlnd.plugin.pointercalc">
   <title>Расчёт указателя для mysqlnd</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Адрес памяти</entry>
      <entry>Содержимое</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>0</entry>
      <entry>Начало объекта mysqlnd (C struct)</entry>
     </row>
     <row>
      <entry>n</entry>
      <entry>Конец объекта mysqlnd (C struct)</entry>
     </row>
     <row>
      <entry>n + (m x sizeof(void*))</entry>
      <entry>void* для данных объекта плагина номер m</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <simpara>
   Если вы планируете делать подкласс от одного из конструкторов объекта
   <literal>mysqlnd</literal>, которые разрешены, имейте это в виду!
  </simpara>
  <simpara>
   Следующий код демонстрирует расширение свойств:
  </simpara>
  <programlisting>
<![CDATA[
/* Любые данные, которые мы хотим добавить */
typedef struct my_conn_properties {
  unsigned long query_counter;
} MY_CONN_PROPERTIES;

/* идентификатор плагина */
unsigned int my_plugin_id;

void minit_register_hooks(TSRMLS_D) {
  /* получаем уникальный идентификатор плагина */
  my_plugin_id = mysqlnd_plugin_register();
  /* snip - see Extending Connection: methods */
}

static MY_CONN_PROPERTIES** get_conn_properties(const MYSQLND *conn TSRMLS_DC) {
  MY_CONN_PROPERTIES** props;
  props = (MY_CONN_PROPERTIES**)mysqlnd_plugin_get_plugin_connection_data(
    conn, my_plugin_id);
  if (!props || !(*props)) {
    *props = mnd_pecalloc(1, sizeof(MY_CONN_PROPERTIES), conn->persistent);
    (*props)->query_counter = 0;
  }
  return props;
}
]]>
  </programlisting>
  <simpara>
   Разработчик плагина отвечает за управление памятью данных плагина.
  </simpara>
  <simpara>
   Рекомендуется использовать управление памятью <literal>mysqlnd</literal> для данных
   плагина. Эти функции именуются используя такие соглашения:
   <literal>mnd_*loc()</literal>. Управление памятью <literal>mysqlnd</literal> имеет
   ряд полезных свойств, таких как использование отладочного
   модуля управления памятью в неотладочных сборках.
  </simpara>
  <table xml:id="mysqlnd.plugin.subclass">
   <title>Когда и как создавать подкласс</title>
   <tgroup cols="4">
    <thead>
     <row>
      <entry/>
      <entry>Когда создавать подкласс?</entry>
      <entry>Каждый экземпляр имеет свою собственную таблицу функций?</entry>
      <entry>Как создавать подкласс?</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>Соединение (MYSQLND)</entry>
      <entry>MINIT</entry>
      <entry>Нет</entry>
      <entry>mysqlnd_conn_get_methods()</entry>
     </row>
     <row>
      <entry>Результирующий набор (MYSQLND_RES)</entry>
      <entry>MINIT or later</entry>
      <entry>Да</entry>
      <entry>mysqlnd_result_get_methods() или методом объекта,
       манипулирующим таблицей функций</entry>
     </row>
     <row>
      <entry>Результирующий набор (MYSQLND_RES_METADATA)</entry>
      <entry>MINIT</entry>
      <entry>Нет</entry>
      <entry>mysqlnd_result_metadata_get_methods()</entry>
     </row>
     <row>
      <entry>Оператор (MYSQLND_STMT)</entry>
      <entry>MINIT</entry>
      <entry>Нет</entry>
      <entry>mysqlnd_stmt_get_methods()</entry>
     </row>
     <row>
      <entry>Сеть (MYSQLND_NET)</entry>
      <entry>MINIT или позже</entry>
      <entry>Да</entry>
      <entry>mysqlnd_net_get_methods() или методом объекта,
       манипулирующим таблицей функций</entry>
     </row>
     <row>
      <entry>Протокол обмена (MYSQLND_PROTOCOL)</entry>
      <entry>MINIT или позже</entry>
      <entry>Да</entry>
      <entry>mysqlnd_protocol_get_methods() или методом
       объекта, манипулирующим таблицей функций</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <simpara>
   Вы не должны манипулировать таблицей функций после
   MINIT, если это прямо не разрешено в таблице выше.
  </simpara>
  <simpara>
   Некоторые классы содержат указатель на таблицу функций методов. Все экземпляры
   подобных классов должны делить одну и ту же таблицу функций. Для того, чтобы избежать
   хаоса, особенно в многопоточном окружении, управлять такими таблицами функций стоит
   только во время MINIT.
  </simpara>
  <simpara>
   Прочие классы используют копии глобально разделённых таблиц функций. Таблица функций
   создаётся одновременно с объектом. Каждый объект использует свою таблицу. Это даёт вам
   две возможности: вы можете управлять таблицей функций по умолчанию для объекта во
   время MINIT, а также вы можете изменять методы объекта не затрагивая другие
   экземпляры этого же класса.
  </simpara>
  <simpara>
   Преимущество разделяемой таблицы функций в производительности, так как нет нужды
   копировать таблицу функций отдельно для каждого объекта.
  </simpara>
  <table xml:id="mysqlnd.plugin.constatus">
   <title>Статус конструктора</title>
   <tgroup cols="4">
    <thead>
     <row>
      <entry>Тип</entry>
      <entry>Размещение, создание, сброс</entry>
      <entry>Может быть изменено?</entry>
      <entry>Вызывающий</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>Connection (MYSQLND)</entry>
      <entry>mysqlnd_init()</entry>
      <entry>Нет</entry>
      <entry>mysqlnd_connect()</entry>
     </row>
     <row>
      <entry>Результирующий набор (MYSQLND_RES)</entry>
      <entry><simpara>
       Размещение:
       </simpara>
       <itemizedlist>
        <listitem>
         <simpara>
          Connection::result_init()
         </simpara>
        </listitem>
       </itemizedlist>
       <simpara>
        Сброс и повторная инициализация во время:
       </simpara>
       <itemizedlist>
        <listitem>
         <simpara>
          Result::use_result()
         </simpara>
        </listitem>
        <listitem>
         <simpara>
          Result::store_result
         </simpara>
        </listitem>
       </itemizedlist></entry>
      <entry>Да, но вызовите родителя!</entry>
      <entry><itemizedlist>
       <listitem>
        <simpara>
         Connection::list_fields()
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         Statement::get_result()
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         Statement::prepare() (Только метаданные)
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         Statement::resultMetaData()
        </simpara>
       </listitem>
       </itemizedlist></entry>
     </row>
     <row>
      <entry>Метаданные результирующего набора (MYSQLND_RES_METADATA)</entry>
      <entry>Connection::result_meta_init()</entry>
      <entry>Да, но вызовите родителя!</entry>
      <entry>Result::read_result_metadata()</entry>
     </row>
     <row>
      <entry>Оператор (MYSQLND_STMT)</entry>
      <entry>Connection::stmt_init()</entry>
      <entry>Да, но вызовите родителя!</entry>
      <entry>Connection::stmt_init()</entry>
     </row>
     <row>
      <entry>Сеть (MYSQLND_NET)</entry>
      <entry>mysqlnd_net_init()</entry>
      <entry>Нет</entry>
      <entry>Connection::init()</entry>
     </row>
     <row>
      <entry>Протокол обмена (MYSQLND_PROTOCOL)</entry>
      <entry>mysqlnd_protocol_init()</entry>
      <entry>Нет</entry>
      <entry>Connection::init()</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <simpara>
   Настоятельно рекомендуется не заменять конструктор
   целиком. Конструкторы производят выделение памяти.
   Выделение памяти жизненно необходимо для API плагинов
   <literal>mysqlnd</literal> и для логики объекта
   <literal>mysqlnd</literal>. Если вам не страшны
   предупреждения и хотите сильно поменять конструктор, то
   хотя бы вызовите родительский конструктор прежде, чем что-либо делать.
  </simpara>
  <simpara>
   Несмотря на предупреждения, это бывает полезным для конструктора подкласса.
   Конструкторы — отличное место для изменения таблицы функций для объектов,
   которые не работают с разделённой таблицу, например,
   результирующий набор, сеть, протокол обмена.
  </simpara>
  <table xml:id="mysqlnd.plugin.deststatus">
   <title>Статус уничтожения</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry/>
      <entry>Производный метод должен вызвать родительский?</entry>
      <entry>Деструктор</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>Соединение</entry>
      <entry>да, после выполнения метода</entry>
      <entry>free_contents(), end_psession()</entry>
     </row>
     <row>
      <entry>Результирующий набор</entry>
      <entry>да, после выполнения метода</entry>
      <entry>free_result()</entry>
     </row>
     <row>
      <entry>Метаданные результирующего набора</entry>
      <entry>да, после выполнения метода</entry>
      <entry>free()</entry>
     </row>
     <row>
      <entry>Оператор</entry>
      <entry>да, после выполнения метода</entry>
      <entry>dtor(), free_stmt_content()</entry>
     </row>
     <row>
      <entry>Сеть</entry>
      <entry>да, после выполнения метода</entry>
      <entry>free()</entry>
     </row>
     <row>
      <entry>Протокол обмена</entry>
      <entry>да, после выполнения метода</entry>
      <entry>free()</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <simpara>
   Деструкторы являются подходящим местом, чтобы освободить ресурсы, занимаемые
   свойствами
   <literal>mysqlnd_plugin_get_plugin_<replaceable>&lt;object&gt;</replaceable>_data()</literal>.
  </simpara>
  <simpara>
   Перечисленные деструкторы могут не совпадать с актуальными методами
   <literal>mysqlnd</literal> для очистки самого объекта. Однако они являются самым лучшим
   местом, куда вы можете вклиниться для очистки данных своего плагина. Так же как и
   с конструкторами, вы можете полностью переопределить эти методы, но делать это не
   рекомендуется. Если вам необходимо вставить в каждый из перечисленных методов
   очистку данных своего плагина, то необходимо обеспечить запуск родительских
   методов <literal>mysqlnd</literal>.
  </simpara>
  <simpara>
   Для плагинов рекомендуют метод — выполнить код очистки данных плагина
   и сразу после этого вызывать родительский метод.
  </simpara>
 </section>
 <section xml:id="mysqlnd.plugin.api">
  <title>API плагинов mysqlnd</title>
  <simpara>
   API-интерфейс плагинов <literal>mysqlnd</literal> поддерживает следующие функции:
  </simpara>
  <itemizedlist>
   <listitem>
    <simpara>
     mysqlnd_plugin_register()
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     mysqlnd_plugin_count()
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     mysqlnd_plugin_get_plugin_connection_data()
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     mysqlnd_plugin_get_plugin_result_data()
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     mysqlnd_plugin_get_plugin_stmt_data()
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     mysqlnd_plugin_get_plugin_net_data()
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     mysqlnd_plugin_get_plugin_protocol_data()
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     mysqlnd_conn_get_methods()
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     mysqlnd_result_get_methods()
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     mysqlnd_result_meta_get_methods()
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     mysqlnd_stmt_get_methods()
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     mysqlnd_net_get_methods()
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     mysqlnd_protocol_get_methods()
    </simpara>
   </listitem>
  </itemizedlist>
  <simpara>
   Нет стандартных определений того, что такое плагин и как он работает.
  </simpara>
  <simpara>
   Часто встречающиеся в плагинах компоненты:
  </simpara>
  <itemizedlist>
   <listitem>
    <simpara>
     Менеджер плагина
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     API плагина
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Сервисы приложения (или модули)
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     API сервисов приложения (или API модулей)
    </simpara>
   </listitem>
  </itemizedlist>
  <simpara>
   Концепция плагина <literal>mysqlnd</literal> эксплуатирует эту функциональность и,
   кроме того, радует нас открытой архитектурой.
  </simpara>
  <simpara>
   <emphasis role="bold">Нет запретов </emphasis>
  </simpara>
  <simpara>
   Плагин имеет полный доступ ко всем внутренностям <literal>mysqlnd</literal>.
   Нет ограничений или запретов, связанных с безопасностью. Все что угодно можно
   переписать для реализации дружественных или враждебных алгоритмов, так что
   рекомендуется ставить плагины только из доверенных источников.
  </simpara>
  <simpara>
   Как обсуждалось выше, плагины могут свободно использовать указатели. Эти указатели
   ничем не ограничены и могут указывать на данные другого плагина. Простейшая
   арифметическая операция позволит получить доступ к данным другого плагина.
  </simpara>
  <simpara>
   Рекомендуется писать сотрудничающие плагины, которые могут работать сообща с другими
   плагинами и всегда вызывать родительские методы. Плагины никогда не должны вести себя
   враждебно к самому <literal>mysqlnd</literal>.
  </simpara>
  <table xml:id="mysqlnd.plugin.chaining">
   <title>Проблемы: пример сотрудничества и построения цепочки</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Модуль</entry>
      <entry>Указатель mysqlnd.query()</entry>
      <entry>Стек вызова, если вызывается родитель</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>ext/mysqlnd</entry>
      <entry>mysqlnd.query()</entry>
      <entry>mysqlnd.query</entry>
     </row>
     <row>
      <entry>ext/mysqlnd_cache</entry>
      <entry>mysqlnd_cache.query()</entry>
      <entry><orderedlist>
       <listitem>
        <simpara>
         mysqlnd_cache.query()
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         mysqlnd.query
        </simpara>
       </listitem>
       </orderedlist></entry>
     </row>
     <row>
      <entry>ext/mysqlnd_monitor</entry>
      <entry>mysqlnd_monitor.query()</entry>
      <entry><orderedlist>
       <listitem>
        <simpara>
         mysqlnd_monitor.query()
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         mysqlnd_cache.query()
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         mysqlnd.query
        </simpara>
       </listitem>
       </orderedlist></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <simpara>
   В этом сценарии загружены плагины кеша (<literal>ext/mysqlnd_cache</literal>) и
   мониторинга (<literal>ext/mysqlnd_monitor</literal>).
   Оба наследуют класс <literal>Connection::query()</literal>. регистрация плагинов
   происходит на этапе <literal>MINIT</literal> в соответствии с описанной
   выше логикой. PHP, по умолчанию, вызывает модули в алфавитном порядке.
   Плагины не знают друг о друге и не накладывают каких-либо зависимостей.
  </simpara>
  <simpara>
   По умолчанию, плагины вызывают родительский метод query из своей, переопределённой,
   версии этого метода.
  </simpara>
  <simpara>
   <emphasis role="bold">Резюме по модулю PHP</emphasis>
  </simpara>
  <simpara>
   Повторение пройденного материала на примере поведения плагина
   <literal>ext/mysqlnd_plugin</literal>, использующего API плагинов
   <literal>mysqlnd</literal> для PHP:
  </simpara>
  <itemizedlist>
   <listitem>
    <simpara>
     Любое приложение PHP, использующее MySQL пытается установить соединение по
     адресу 192.168.2.29
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Приложение использует одно из следующих модулей <literal>ext/mysql</literal>,
     <literal>ext/mysqli</literal> или <literal>PDO_MYSQL</literal>. Все
     три модуля используют <literal>mysqlnd</literal> для соединения с 192.168.2.29.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <literal>Mysqlnd</literal> вызывает метод соединения, который наследуется
     плагином <literal>ext/mysqlnd_plugin</literal>.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <literal>ext/mysqlnd_plugin</literal> вызывает зарегистрированный
     пользователем метод <literal>proxy::connect()</literal>.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Этот метод подменяет IP адрес соединения с 192.168.2.29
     на 127.0.0.1 и возвращает установленное <literal>parent::connect()</literal> соединение.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <literal>ext/mysqlnd_plugin</literal> делает то же самое, что и
     <literal>parent::connect(127.0.0.1)</literal>, вызывая оригинальный метод
     <literal>mysqlnd</literal> для соединения.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <literal>ext/mysqlnd</literal> устанавливает соединение и возвращает его
     <literal>ext/mysqlnd_plugin</literal>.
     <literal>ext/mysqlnd_plugin</literal>, в свою очередь, передаёт его дальше.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Без разницы, какой модуль был использован, он всё равно получит
     соединение к 127.0.0.1. После этого, модуль возвращает это соединение
     приложению. Круг замкнулся.
    </simpara>
   </listitem>
  </itemizedlist>
 </section>
 <section xml:id="mysqlnd.plugin.developing">
  <title>Начинаем разработку плагина mysqlnd</title>
  <simpara>
   Важно помнить, что плагин <literal>mysqlnd</literal> сам по себе
   является модулем PHP.
  </simpara>
  <simpara>
   Следующий пример показывает базовую структуру функции MINIT,
   использующуюся в типичном плагине <literal>mysqlnd</literal>:
  </simpara>
  <programlisting>
<![CDATA[
/* my_php_mysqlnd_plugin.c */

 static PHP_MINIT_FUNCTION(mysqlnd_plugin) {
  /* глобальные переменные, ini-настройки, ресурсы, классы */

  /* регистрируем плагин mysqlnd */
  mysqlnd_plugin_id = mysqlnd_plugin_register();

  conn_m = mysqlnd_get_conn_methods();
  memcpy(org_conn_m, conn_m,
    sizeof(struct st_mysqlnd_conn_methods));

  conn_m->query = MYSQLND_METHOD(mysqlnd_plugin_conn, query);
  conn_m->connect = MYSQLND_METHOD(mysqlnd_plugin_conn, connect);
}
]]>
  </programlisting>
  <programlisting>
<![CDATA[
/* my_mysqlnd_plugin.c */

 enum_func_status MYSQLND_METHOD(mysqlnd_plugin_conn, query)(/* ... */) {
  /* ... */
}
enum_func_status MYSQLND_METHOD(mysqlnd_plugin_conn, connect)(/* ... */) {
  /* ... */
}
]]>
  </programlisting>
  <simpara>
   <emphasis role="bold">Анализ задачи: от C до пользовательского пространства</emphasis>
  </simpara>
  <programlisting>
<![CDATA[
 class proxy extends mysqlnd_plugin_connection {
  public function connect($host, ...) { .. }
}
mysqlnd_plugin_set_conn_proxy(new proxy());
]]>
  </programlisting>
  <simpara>
   Процесс:
  </simpara>
  <orderedlist>
   <listitem>
    <simpara>
     PHP: пользователь регистрирует callback-функцию плагина
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     PHP: пользователь вызывает PHP MySQL API для соединения с MySQL
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     C: ext/*mysql* вызывает метод mysqlnd
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     C: mysqlnd обрывается в ext/mysqlnd_plugin
    </simpara>
   </listitem>
   <listitem>
    <para>
     C: ext/mysqlnd_plugin
     <orderedlist>
      <listitem>
       <simpara>
        Вызывает пользовательскую callback-функцию
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Или оригинальный метод <literal>mysqlnd</literal>, если она не задана
       </simpara>
      </listitem>
     </orderedlist>
    </para>
   </listitem>
  </orderedlist>
  <simpara>
   Вам необходимо выполнить следующие действия:
  </simpara>
  <orderedlist>
   <listitem>
    <simpara>
     Создайте в С класс "mysqlnd_plugin_connection"
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Примите и зарегистрируйте прокси объект с помощью
     "mysqlnd_plugin_set_conn_proxy()"
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Вызовите прокси методы пространства пользователя из C (оптимизация -
     zend_interfaces.h)
    </simpara>
   </listitem>
  </orderedlist>
  <simpara>
   Методы объекта пространства пользователя должны быть вызваны с помощью
   <literal>call_user_function()</literal> или на уровень ниже, с помощью
   <literal>zend_call_method()</literal>.
  </simpara>
  <simpara>
   <emphasis role="bold">Оптимизация: вызывайте методы из С с помощью
    zend_call_method </emphasis>
  </simpara>
  <simpara>
   Следующий кусок кода демонстрирует прототип функции
   <literal>zend_call_method</literal>, взятый из
   <filename>zend_interfaces.h</filename>.
  </simpara>
  <programlisting>
<![CDATA[
 ZEND_API zval* zend_call_method(
  zval **object_pp, zend_class_entry *obj_ce,
  zend_function **fn_proxy, char *function_name,
  int function_name_len, zval **retval_ptr_ptr,
  int param_count, zval* arg1, zval* arg2 TSRMLS_DC
);
]]>
  </programlisting>
  <simpara>
   API движка Zend поддерживает только два аргумента. Иногда требуется больше. Например:
  </simpara>
  <programlisting>
<![CDATA[
 enum_func_status (*func_mysqlnd_conn__connect)(
  MYSQLND *conn, const char *host,
  const char * user, const char * passwd,
  unsigned int passwd_len, const char * db,
  unsigned int db_len, unsigned int port,
  const char * socket, unsigned int mysql_flags TSRMLS_DC
);
]]>
  </programlisting>
  <simpara>
   Для обхода этой проблемы вам необходимо сделать копию
   <literal>zend_call_method()</literal> и добавить необходимые параметры.
   Вы можете сделать это создав набор макросов
   <literal>MY_ZEND_CALL_METHOD_WRAPPER</literal>.
  </simpara>
  <simpara>
   <emphasis role="bold">Обращение к пространству пользователя  PHP</emphasis>
  </simpara>
  <simpara>
   Этот кусок кода демонстрирует оптимизированный метод вызова функций пространства
   пользователя из С:
  </simpara>
  <programlisting>
<![CDATA[
/* my_mysqlnd_plugin.c */

MYSQLND_METHOD(my_conn_class, connect)
(
    MYSQLND *conn, const char *host /* ... */ TSRMLS_DC)
{
    enum_func_status ret = FAIL;
    zval *global_user_conn_proxy = fetch_userspace_proxy();
    if (global_user_conn_proxy)
    {
        /* Вызов прокси пространства пользователя */
        ret = MY_ZEND_CALL_METHOD_WRAPPER(global_user_conn_proxy, host, /*...*/);
    }
    else
    {
        /* или оригинальный метод mysqlnd = ничего не делать, быть прозрачным */
        ret = org_methods.connect(conn, host, user, passwd,
                                  passwd_len, db, db_len, port,
                                  socket, mysql_flags TSRMLS_CC);
    }
    return ret;
}
]]>
  </programlisting>
  <simpara>
   <emphasis role="bold">Обращение к пространству пользователя: простые аргументы
   </emphasis>
  </simpara>
  <programlisting>
<![CDATA[
/* my_mysqlnd_plugin.c */

 MYSQLND_METHOD(my_conn_class,connect)(
  /* ... */, const char *host, /* ...*/) {
  /* ... */
  if (global_user_conn_proxy) {
    /* ... */
    zval* zv_host;
    MAKE_STD_ZVAL(zv_host);
    ZVAL_STRING(zv_host, host, 1);
    MY_ZEND_CALL_METHOD_WRAPPER(global_user_conn_proxy, zv_retval, zv_host /*, ...*/);
    zval_ptr_dtor(&zv_host);
    /* ... */
  }
  /* ... */
}
]]>
  </programlisting>
  <simpara>
   <emphasis role="bold">Обращение к пространству пользователя: структуры как аргументы
   </emphasis>
  </simpara>
  <programlisting>
<![CDATA[
/* my_mysqlnd_plugin.c */

MYSQLND_METHOD(my_conn_class, connect)
(
    MYSQLND *conn, /* ...*/)
{
    /* ... */
    if (global_user_conn_proxy)
    {
        /* ... */
        zval *zv_conn;
        ZEND_REGISTER_RESOURCE(zv_conn, (void *)conn, le_mysqlnd_plugin_conn);
        MY_ZEND_CALL_METHOD_WRAPPER(global_user_conn_proxy, zv_retval, zv_conn, zv_host /*, ...*/);
        zval_ptr_dtor(&zv_conn);
        /* ... */
    }
    /* ... */
}
]]>
  </programlisting>
  <simpara>
   первый аргумент многих методов <literal>mysqlnd</literal> — «объекты» С.
   Например, первый аргумент метода connect() — указатель
   на <literal>MYSQLND</literal>. Структура MYSQLND —
   объект соединения <literal>mysqlnd</literal>.
  </simpara>
  <simpara>
   Указатель на объект соединения <literal>mysqlnd</literal> сравнивают со стандартным
   обработчиком файлового ввода-вывода. Так же как и он, объект соединения
   <literal>mysqlnd</literal> связывают с пространством пользователя
   через PHP-тип resource.
  </simpara>
  <simpara>
   <emphasis role="bold">Из C в пространство пользователя и обратно</emphasis>
  </simpara>
  <programlisting>
<![CDATA[
<?php

class proxy extends mysqlnd_plugin_connection
{
    public function connect($conn, $host, ...)
    {
        /* До внедрения */
        printf("Подключение к = '%s'\n", $host);
        debug_print_backtrace();
        return parent::connect($conn);
    }

    public function query($conn, $query)
    {
        /* После внедрения */
        $ret = parent::query($conn, $query);
        printf("Запрос = '%s'\n", $query);
        return $ret;
    }
}

mysqlnd_plugin_set_conn_proxy(new proxy());
]]>
  </programlisting>
  <simpara>
   Пользователи PHP должны иметь возможность вызывать родительские
   реализации переопределённых методов.
  </simpara>
  <simpara>
   В результате наследования возможно «уточнить» только выбранные
   методы и вы можете выбрать, когда выполнять ваш код, до или после родительского.
  </simpara>
  <simpara>
   <emphasis role="bold">Встроенный класс:
    mysqlnd_plugin_connection::connect() </emphasis>
  </simpara>
  <programlisting>
<![CDATA[
/*  my_mysqlnd_plugin_classes.c */

PHP_METHOD("mysqlnd_plugin_connection", connect)
{
    /* ... упрощённый! ... */
    zval *mysqlnd_rsrc;
    MYSQLND *conn;
    char *host;
    int host_len;
    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rs",
                              &mysqlnd_rsrc, &host, &host_len) == FAILURE)
    {
        RETURN_NULL();
    }
    ZEND_FETCH_RESOURCE(conn, MYSQLND * conn, &mysqlnd_rsrc, -1,
                        "Mysqlnd Connection", le_mysqlnd_plugin_conn);
    if (PASS == org_methods.connect(conn, host, /* simplified! */ TSRMLS_CC))
        RETVAL_TRUE;
    else
        RETVAL_FALSE;
}
]]>
  </programlisting>
 </section>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
