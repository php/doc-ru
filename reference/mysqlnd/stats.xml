<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 40667918dcff1d5c9f7ecdc88b5caca24ba0686c Maintainer: rjhdby Status: ready -->
<!-- Reviewed: no -->
<!-- $Revision$ -->
<chapter xml:id="mysqlnd.stats" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Статистика</title>
 <para>
  <emphasis role="bold">Использование статистических данных</emphasis>
 </para>
 <para>
  MySQL Native Driver поддерживает сбор статистики по взаимодействию
  клиента с сервером. Статистика собирается с двух основных точек:
 </para>
 <itemizedlist>
  <listitem>
   <para>
    Клиентская статистика
   </para>
  </listitem>
  <listitem>
   <para>
    Статистика соединения
   </para>
  </listitem>
 </itemizedlist>
 <para>
  Если вы используете модуль <literal>mysqli</literal>, эта статистика
  доступна с помощью двух функций, обращающихся к API:
 </para>
 <itemizedlist>
  <listitem>
   <para>
    <function>mysqli_get_client_stats</function>
   </para>
  </listitem>
  <listitem>
   <para>
    <function>mysqli_get_connection_stats</function>
   </para>
  </listitem>
 </itemizedlist>
 <note>
  <para>
   Статистика агрегируется со всех модулей, использующих MySQL Native
   Driver. К примеру, если подключить и <literal>ext/mysql</literal>
   и <literal>ext/mysqli</literal> через MySQL Native Driver, как вызовы
   функций <literal>ext/mysql</literal> так и <literal>ext/mysqli</literal>
   будут внесены в общую статистику. Возможность разделить статистику
   в зависимости от использованного модуля отсутствует. Вы можете
   сконфигурировать драйвера PDO MySQL, <literal>ext/mysql</literal> и
   <literal>ext/mysqli</literal> для опционального использования
   MySQL Native Driver. При этом все три модуля будут изменять статистику.
  </para>
 </note>
 <para>
  <emphasis role="bold">Доступ к клиентской статистике</emphasis>
 </para>
 <para>
  Для получения клиентской статистике необходимо выполнить функцию
  <function>mysqli_get_client_stats</function>. Функция вызывается без параметров.
 </para>
 <para>
  Функция возвращает ассоциативный массив, использующий в качестве ключей
  названия метрик статистики и в качестве значения этих метрик, собственно, значения.
 </para>
 <para>
  Также клиентская статистика доступна с помощью функции
  <function>phpinfo</function>.
 </para>
 <para>
  <emphasis role="bold">Доступ к статистике соединения</emphasis>
 </para>
 <para>
  Для получения статистики соединения, выполните функцию
  <function>mysqli_get_connection_stats</function>, передав в качестве
  параметра ресурс соединения.
 </para>
 <para>
  Функция возвращает ассоциативный массив, использующий в качестве ключей
  названия метрик статистики и в качестве значения этих метрик, собственно, значения.
 </para>
 <para>
  <emphasis role="bold">Буферизованные и небуферизованные результирующие наборы</emphasis>
 </para>
 <para>
  Результирующие наборы могут быть буферизованными и небуферизованными.
  При использовании настроек по умолчанию, <literal>ext/mysql</literal> и
  <literal>ext/mysqli</literal> работают с буферизованными результирующими
  наборами при использовании нормальных (не подготовленных) запросов.
  Буферизованные результирующие наборы кешируются на стороне клиента.
  После выполнения запроса, все результаты передаются на клиента, где
  сохраняются в кеше. Преимущество буферизованных запросов в том, что
  сразу высвобождаются серверные ресурсы, связанные с хранением результирующего
  набора.
 </para>
 <para>
  Небуферизованные результирующие наборы, с другой стороны,
  сохраняются на сервере гораздо дольше. Если вы хотите сократить потребление
  памяти на клиенте, но при этом нагрузить сервер, используйте небуферизованные
  результирующие наборы. Если узким местом в вашей системе является сервер
  баз данных, то вам стоит задуматься о скорейшем перемещении результатов
  на клиента. Обычно клиенты масштабируются гораздо легче, чем сервера БД.
  <quote>Нагрузка</quote> ложится не только на память, но и
  на прочие ресурсы, которые должна поддерживать база данных для обслуживания
  соединения, такие как открытые файловые дескрипторы и нити исполнения.
 </para>
 <para>
  Подготовленные запросы по умолчанию используют небуферизованные
  результирующие наборы. В любом случае, вы можете использовать
  функцию <function>mysqli_stmt_store_result</function> для буферизации результатов.
 </para>
 <para>
  <emphasis role="bold">Статистика возвращаемая MySQL Native Driver</emphasis>
 </para>
 <para>
  Следующая таблица демонстрирует список возвращаемой
  функциями <function>mysqli_get_client_stats</function> и
  <function>mysqli_get_connection_stats</function> статистики.
 </para>
 <table xml:id="mysqlnd.stats.returns">
  <title>Статистика mysqlnd: Сеть</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Метрика</entry>
     <entry>Область применения</entry>
     <entry>Описание</entry>
     <entry>Замечания</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>bytes_sent</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество байт переданных от PHP на сервер MySQL</entry>
     <entry>Может использоваться для проверки эффективности протокола сжатия</entry>
    </row>
    <row>
     <entry><literal>bytes_received</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество байт полученных от сервера MySQL</entry>
     <entry>Может использоваться для проверки эффективности протокола сжатия</entry>
    </row>
    <row>
     <entry><literal>packets_sent</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество пакетов посланных от клиента серверу MySQL</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола</entry>
    </row>
    <row>
     <entry><literal>packets_received</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество пакетов принятых клиентом от сервера MySQL</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола</entry>
    </row>
    <row>
     <entry><literal>protocol_overhead_in</literal></entry>
     <entry>Соединение</entry>
     <entry>накладные расходы клиент-серверного протокола MySQL в байтах для входящего трафика.
      на данный момент только заголовок пакета (4 байта) считается за накладные расходы.
      protocol_overhead_in = packets_received * 4</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола</entry>
    </row>
    <row>
     <entry><literal>protocol_overhead_out</literal></entry>
     <entry>Соединение</entry>
     <entry>MySQL Client Server protocol overhead in bytes for outgoing traffic.
      Currently only the Packet Header (4 bytes) is considered as
      overhead. protocol_overhead_out = packets_sent * 4</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола</entry>
    </row>
    <row>
     <entry><literal>bytes_received_ok_packet</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество байт принятых ОК-пакетов клиент-серверного протокола MySQL.
      OK-пакеты могут содержать статусные сообщения. Длина статусных сообщений может
      меняться, следовательно размер ОК-пакетов не фиксирована.</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>packets_received_ok</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество принятых OK-пакетов</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>bytes_received_eof_packet</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество байт принятых EOF-пакетов. Размер EOF-пакета может изменяться
      в зависимости от версии сервера. Также, EOF-пакеты могут использоваться как
      транспорт для сообщений об ошибках.</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>packets_received_eof</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество принятых EOF-пакетов. Как и для прочей статистики
      по пакетам, это число может увеличиваться каждый раз, когда PHP не получает
      ожидаемый пакет, а, к примеру, получает сообщение об ошибке.</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>bytes_received_rset_header_packet</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество байт принятых заголовочных пакетов результирующих наборов.
      Размер пакетов зависит от полезной нагрузки (<literal>LOAD LOCAL INFILE</literal>,
      <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>SELECT</literal>, сообщение об ошибке).
     </entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>packets_received_rset_header</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество пакетов заголовков результирующих наборов.</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>bytes_received_rset_field_meta_packet</literal></entry>
     <entry>Соединение</entry>
     <entry>Общий размер в байтах полученных пакетов с метаданными результирующих наборов
      (информации о столбцах). Естественно размер каждого пакета индивидуален.
      Эти пакеты могут выступать транспортом для ошибок и EOF-пакетов в случае COM_LIST_FIELDS.</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>packets_received_rset_field_meta</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество полученных пакетов с метаданными результирующих наборов
      (информации о столбцах).</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>bytes_received_rset_row_packet</literal></entry>
     <entry>Соединение</entry>
     <entry>Общий размер в байтах полученных пакетов с данными результирующего набора.
      Эти пакеты могут служить транспортом для ошибок и в качестве EOF-пакетов.
      Вы можете вычислить количество ошибок и EOF-пакетов отняв
      <literal>rows_fetched_from_server_normal</literal> и
      <literal>rows_fetched_from_server_ps</literal> от
      <literal>bytes_received_rset_row_packet</literal>.</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>packets_received_rset_row</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество пакетов с данными результирующих наборов и их суммарный объем в байтах.</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>bytes_received_prepare_response_packet</literal></entry>
     <entry>Соединение</entry>
     <entry>Общий размер в байтах ОК-пакетов инициализации подготовленных запросов.
      (инициализирующие пакеты подготовленных запросов). Эти пакеты могут выступать транспортом
      для ошибок. Размер пакета зависит от версии Mysql: 9 байт для MySQL4.1 и 12 байт начиная с 5.0.
      Нет надёжного способа узнать количество ошибок. Вы можете определить, что случилась
      ошибка, если, например, вы работаете с MySQL 5.0 или новее, а
      <literal>bytes_received_prepare_response_packet</literal> !=
      <literal>packets_received_prepare_response</literal> * 12. Также смотрите
      <literal>ps_prepared_never_executed</literal>, <literal>ps_prepared_once_executed</literal>.
     </entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>packets_received_prepare_response</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество полученных ОК-пакетов для инициализации подготовленных запросов.</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>bytes_received_change_user_packet</literal></entry>
     <entry>Соединение</entry>
     <entry>Общий размер в байтах полученных пакетов COM_CHANGE_USER.
      Пакеты могут служить транспортом для ошибок и EOF-пакетов.</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>packets_received_change_user</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество принятых пакетов COM_CHANGE_USER</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>packets_sent_command</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество команд посланных от PHP серверу MySQL.
      Возможность узнать, какие конкретно и в каких количествах посылались команды отсутствует.
      Лучшее, для чего вы можете использовать эту метрику, это проверять,
      что посылает команды серверу MySQL и поддержка MySQL в PHP не запрещена.
      Также отсутствует возможность определить количество ошибок, возникших
      при отправке этих команд. Единственная опознаваемая ошибка - это
      command_buffer_too_small (смотрите ниже).</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола</entry>
    </row>
    <row>
     <entry><literal>bytes_received_real_data_normal</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество байт полезной нагрузки извлечённой клиентом PHP из
      <literal>mysqlnd</literal> с использованием текстового протокола.</entry>
     <entry>Это актуальный размер данных содержащихся в результирующем наборе,
      которые клиент PHP уже загрузил.
      Обратите внимание, что хоть возможно <literal>mysqlnd</literal> забрал и полный
      результирующий набор с сервера MySQL, но в этой метрике учитываются только данные
      уже полученные клиентом PHP от <literal>mysqlnd</literal>.
      К примеру, следующий код увеличит значение метрики:
      <programlisting>
<![CDATA[
$mysqli = new mysqli();
$res = $mysqli->query("SELECT 'abc'");
$res->fetch_assoc();
$res->close();
]]>
      </programlisting>
      <para>
       Каждая операция извлечения увеличивает это число.
      </para>

      <para>
       Статистика не изменится, если результирующий набор был только буферизован,
       но не извлечён, как в этом примере:
      </para>
      <programlisting>
<![CDATA[
$mysqli = new mysqli();
$res = $mysqli->query("SELECT 'abc'");
$res->close();
]]>
      </programlisting>
     </entry>
    </row>
    <row>
     <entry><literal>bytes_received_real_data_ps</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество байт полезной нагрузки, извлечённой клиентом PHP из
      <literal>mysqlnd</literal> используя подготовленные запросы.</entry>
     <entry>Это размер только тех данных, которые были извлечены клиентом PHP.
      Значение метрики не будет увеличиваться если клиент PHP не будет запрашивать эти данные.
      Обратите внимание, что хоть возможно <literal>mysqlnd</literal> забрал и полный
      результирующий набор с сервера MySQL, но в этой метрике учитываются только данные
      уже полученные клиентом PHP от <literal>mysqlnd</literal>.
      Также смотрите <literal>bytes_received_real_data_normal</literal>.
     </entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 <para>
  <emphasis role="bold">Результирующий набор</emphasis>
 </para>
 <table xml:id="mysqlnd.stats.results">
  <title>Статистика mysqlnd: результирующий набор</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Метрика</entry>
     <entry>Область применения</entry>
     <entry>Описание</entry>
     <entry>Замечания</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>result_set_queries</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество запросов, по которым был создан результирующий набор.
      Пример запросов, создающих результирующий набор: <literal>SELECT</literal>, <literal>SHOW</literal>.
      Статистика не будет увеличиваться в случае ошибки чтения заголовочного
      пакета результирующего набора.</entry>
     <entry>Вы можете использовать эту метрику, как опосредованный счётчик выполненных запросов,
      например для обнаружения клиента, создающего большую нагрузку на БД.</entry>
    </row>
    <row>
     <entry><literal>non_result_set_queries</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество запросов, по которым не был создан результирующий набор.
      Пример запросов, не создающих результирующий набор:
      <literal>INSERT</literal>, <literal>UPDATE</literal>,
      <literal>LOAD DATA</literal>.
      Статистика не будет увеличиваться в случае ошибки чтения заголовочного
      пакета результирующего набора.</entry>
     <entry>Вы можете использовать эту метрику, как опосредованный счётчик выполненных запросов,
      например для обнаружения клиента, создающего большую нагрузку на БД.</entry>
    </row>
    <row>
     <entry><literal>no_index_used</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество запросов, создающих результирующий набор, но не использовавших
      индексы (также смотрите опцию запуска mysqld –log-queries-not-using-indexes).
      Если вы хотите получать отчёты о подобных запросах, вы можете
      использовать mysqli_report(MYSQLI_REPORT_INDEX) для того, чтобы
      ext/mysqli выбрасывал исключение. Если вы предпочитаете просто предупреждение,
      используйте mysqli_report(MYSQLI_REPORT_INDEX ^ MYSQLI_REPORT_STRICT).</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>bad_index_used</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество запросов, создающих результирующий набор, но не использовавших
      хорошие индексы (также смотрите опцию запуска mysqld –log-slow-queries).</entry>
     <entry>Если вы хотите получать отчёты о подобных запросах, вы можете
      использовать mysqli_report(MYSQLI_REPORT_INDEX)для того, чтобы
      ext/mysqli выбрасывал исключение. Если вы предпочитаете просто предупреждение,
      используйте mysqli_report(MYSQLI_REPORT_INDEX ^ MYSQLI_REPORT_STRICT)</entry>
    </row>
    <row>
     <entry><literal>slow_queries</literal></entry>
     <entry>Соединение</entry>
     <entry>SQL-запросы, выполнявшиеся дольше чем <literal>long_query_time</literal>
      секунд и потребовавшие перебора более чем <literal>min_examined_row_limit</literal>
      строк.</entry>
     <entry>Не извлекается с помощью <function>mysqli_report</function></entry>
    </row>
    <row>
     <entry><literal>buffered_sets</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество буферизированных результирующих наборов возвращённых
      <quote>нормальными</quote> запросами.
      <quote>Нормальные</quote>, здесь и дальше значит <quote>не подготовленные</quote>.</entry>
     <entry>Примеры вызовов API, буферизующих результирующий набор на клиенте:
      <function>mysql_query</function>,
      <function>mysqli_query</function>,
      <function>mysqli_store_result</function>,
      <function>mysqli_stmt_get_result</function>. Буферизация результирующего
      набора на клиенте гарантирует, что серверные ресурсы будут освобождены
      так быстро, как возможно и делает позиционирование более простым.
      Плохая новость в том, что это будет стоит дополнительного расхода памяти на клиенте.
      Обратите внимание, что mysqlnd (в отличие от клиентской библиотеки MySQL) зависит
      от ограничений PHP на память, поскольку использует внутренний менеджер памяти
      PHP. Это является одной из причин, почему <function>memory_get_usage</function>
      при использовании mysqlnd показывает большие значение, чем при использовании
      клиентской библиотеки MySQL. <function>memory_get_usage</function> не замеряет
      потребление памяти клиентской библиотекой MySQL, поскольку он
      не использует внутренний менеджер памяти PHP.</entry>
    </row>
    <row>
     <entry><literal>unbuffered_sets</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество небуферизованных результирующих наборов возвращённых нормальными
      (не подготовленными) запросами.</entry>
     <entry>Примеры вызовов API, не буферизующих результирующий набор на клиенте:
      <function>mysqli_use_result</function></entry>
    </row>
    <row>
     <entry><literal>ps_buffered_sets</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество буферизованных результирующих наборов возвращённых
      подготовленными запросами. По умолчанию, подготовленные запросы
      не буферизируются.</entry>
     <entry>Примеры вызовов API, буферизующих результирующий набор на клиенте:
      <literal>mysqli_stmt_store_result</literal></entry>
    </row>
    <row>
     <entry><literal>ps_unbuffered_sets</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество небуферизованных результирующих наборов возвращённых
      подготовленными запросами.</entry>
     <entry>По умолчанию, подготовленные запросы
      не буферизируются.</entry>
    </row>
    <row>
     <entry><literal>flushed_normal_sets</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество результирующих наборов возвращённых нормальными (не подготовленными)
      запросами с непрочитанными данными, которые были обнулены прозрачно для вас.
      Подобное происходит только с небуферизированными результирующими наборами.</entry>
     <entry>Небуферизированные результирующие наборы должны быть полностью извлечены,
      прежде чем будет возможно запустить новый запрос в том же соединении с MySQL, в противном
      случае произойдёт ошибка. Если приложение не извлекло все строки небуферизированного
      результирующего набора, mysqlnd принудительно извлечёт его, чтобы освободить ресурсы
      сервера. Также смотрите <literal>rows_skipped_normal</literal> и
      <literal>rows_skipped_ps</literal>. Возможные причины, ведущие к принудительному обнулению:
      <itemizedlist>
       <listitem>
        <para>
         Ошибка клиентского приложения
        </para>
       </listitem>
       <listitem>
        <para>
         Клиент перестал извлекать записи, так как нашёл, что искал, но
         результирующий набор ещё не был извлечён до конца
        </para>
       </listitem>
       <listitem>
        <para>
         Аварийное завершение клиентского приложения
        </para>
       </listitem>
      </itemizedlist></entry>
    </row>
    <row>
     <entry><literal>flushed_ps_sets</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество результирующих наборов возвращённых подготовленными
      запросами с непрочитанными данными, которые были обнулены прозрачно для вас.
      Подобное происходит только с небуферизированными результирующими наборами.</entry>
     <entry>Небуферизированные результирующие наборы должны быть полностью извлечены,
      прежде чем будет возможно запустить новый запрос в том же соединении с MySQL, в противном
      случае произойдёт ошибка. Если приложение не извлекло все строки небуферизированного
      результирующего набора, mysqlnd принудительно извлечёт его, чтобы освободить ресурсы
      сервера. Также смотрите <literal>rows_skipped_normal</literal> и
      <literal>rows_skipped_ps</literal>. Возможные причины, ведущие к принудительному обнулению:
      <itemizedlist>
       <listitem>
        <para>
         Ошибка клиентского приложения
        </para>
       </listitem>
       <listitem>
        <para>
         Клиент перестал извлекать записи, так как нашёл, что искал, но
         результирующий набор ещё не был извлечён до конца
        </para>
       </listitem>
       <listitem>
        <para>
         Аварийное завершение клиентского приложения
        </para>
       </listitem>
      </itemizedlist></entry>
    </row>
    <row>
     <entry><literal>ps_prepared_never_executed</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество подготовленных, но не запущенных запросов.</entry>
     <entry>Подготовленные запросы потребляют серверные ресурсы. Вы не должны
      подготавливать запросы, если не будете их запускать.</entry>
    </row>
    <row>
     <entry><literal>ps_prepared_once_executed</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество подготовленных запросов, запущенных только один раз.</entry>
     <entry>Главная идея подготовленных запросов в том, что один и тот же запрос
      будет запускаться несколько раз, но, возможно, с другими параметрами. Это
      позволяет сэкономить на подготовке запросов, позволяя произвести разбор
      запроса только один раз, а потом просто подставлять в него параметры и запускать.
      При подготовке запроса происходит <quote>кеширование</quote> результата, например
      можно многократно использовать дерево разбора, созданное один раз на этапе подготовки.
      Если же вы запускаете подготовленный запрос всего один раз, то никакого выигрыша
      по сравнению с <quote>нормальными</quote> запросами не будет, даже наоборот, будут
      дополнительные накладные расходы на кеширование подготовленного запроса.
      Таким образом, подготовленные запросы, которые используются всего один раз,
      ведут к ухудшению производительности.</entry>
    </row>
    <row>
     <entry><literal>rows_fetched_from_server_normal</literal>,
      <literal>rows_fetched_from_server_ps</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество успешно извлечённых строк из базы MySQL,
      независимо от того, использованы они были приложением или нет.
      Часть строк могут не извлекаться приложением, но при этом
      принудительно обнуляться.</entry>
     <entry>Также смотрите <literal>packets_received_rset_row</literal></entry>
    </row>
    <row>
     <entry><literal>rows_buffered_from_client_normal</literal>,
      <literal>rows_buffered_from_client_ps</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество успешно буферизованных строк, полученных
      при выполнении "нормальных" запросов. Это количество строк, извлечённых
      из MySQL и буферизованных на клиенте. Обратите внимание, что существует
      две независимые метрики для буферизованных строк и (переданных
      от MySQL в буфер mysqlnd) и строк, прочтённых приложением (переданных
      из буфера mysqlnd клиентскому приложению). Если количество буферизованных
      строк больше чем число извлечённых клиентом, то стоит обратить
      внимание на клиентские запросы, так как они извлекают больше данных, чем
      им на самом деле нужно.</entry>
     <entry>Пример запросов, буферизующих результирующие наборы:
      <function>mysqli_query</function>,
      <function>mysqli_store_result</function></entry>
    </row>
    <row>
     <entry><literal>rows_fetched_from_client_normal_buffered</literal>,
      <literal>rows_fetched_from_client_ps_buffered</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество извлечённых клиентов строк из буферизованных
      результирующих наборов для любого типа запросов.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>rows_fetched_from_client_normal_unbuffered</literal>,
      <literal>rows_fetched_from_client_ps_unbuffered</literal></entry>
     <entry>Соединение</entry>
     <entry>Total number of rows fetched by the client from a unbuffered result set
      created by a "normal" query or a prepared statement.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>rows_fetched_from_client_ps_cursor</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество извлечённых клиентов строк из небуферизованных
      результирующих наборов для любого типа запросов.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>rows_skipped_normal</literal>,
      <literal>rows_skipped_ps</literal></entry>
     <entry>Соединение</entry>
     <entry>Зарезервировано для использования в будущем и в данный момент не поддерживается</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>copy_on_write_saved</literal>,
      <literal>copy_on_write_performed</literal></entry>
     <entry>Процесс</entry>
     <entry>Если используется mysqlnd: переменные, возвращённые модулем, указывают
      на внутренний сетевой буфер результатов mysqlnd. Если вы не меняли переменные,
      извлечённые данные будут сохранены в памяти один раз. Если вы
      меняли переменные, mysqlnd выполнит копирование при записи для
      защиты внутренних сетевых буферов результата от изменения.
      Если используется клиентская библиотека MySQL: вы всегда держите
      извлечённые данные в памяти в двух экземплярах. Один раз во внутренних
      буферах клиентской библиотеки MySQL, и ещё один раз в переменных, возвращённых
      модулем. В теории, mysqlnd может до 40% сократить потребление памяти.
      В любом случае помните, что эту экономию не удастся замерить
      с помощью <function>memory_get_usage</function>.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>explicit_free_result</literal>,
      <literal>implicit_free_result</literal></entry>
     <entry>Соединение, процесс (только на стадии очистки подготовленных запросов)</entry>
     <entry>Общее количество высвобожденных результирующих наборов.</entry>
     <entry>Очистка всегда производится явно, но для результирующих наборов, созданных
      инициализирующими командами, например
      <literal>mysqli_options(MYSQLI_INIT_COMMAND , ...)</literal></entry>
    </row>
    <row>
     <entry><literal>proto_text_fetched_null</literal>,
      <literal>proto_text_fetched_bit</literal>,
      <literal>proto_text_fetched_tinyint</literal>
      <literal>proto_text_fetched_short</literal>,
      <literal>proto_text_fetched_int24</literal>,
      <literal>proto_text_fetched_int</literal>
      <literal>proto_text_fetched_bigint</literal>,
      <literal>proto_text_fetched_decimal</literal>,
      <literal>proto_text_fetched_float</literal>
      <literal>proto_text_fetched_double</literal>,
      <literal>proto_text_fetched_date</literal>,
      <literal>proto_text_fetched_year</literal>
      <literal>proto_text_fetched_time</literal>,
      <literal>proto_text_fetched_datetime</literal>,
      <literal>proto_text_fetched_timestamp</literal>
      <literal>proto_text_fetched_string</literal>,
      <literal>proto_text_fetched_blob</literal>,
      <literal>proto_text_fetched_enum</literal>
      <literal>proto_text_fetched_set</literal>,
      <literal>proto_text_fetched_geometry</literal>,
      <literal>proto_text_fetched_other</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество столбцов определённого типа, извлечённых нормальными запросами
      (текстовый протокол MySQL).</entry>
     <entry>Связка метаданных C API / MySQL с именами метрик статистики:
      <itemizedlist>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_NULL</literal> - proto_text_fetched_null
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_BIT</literal> - proto_text_fetched_bit
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_TINY</literal> - proto_text_fetched_tinyint
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_SHORT</literal> - proto_text_fetched_short
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_INT24</literal> - proto_text_fetched_int24
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_LONG</literal> - proto_text_fetched_int
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_LONGLONG</literal> -
         proto_text_fetched_bigint
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_DECIMAL</literal>,
         <literal>MYSQL_TYPE_NEWDECIMAL</literal> -
         proto_text_fetched_decimal
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_FLOAT</literal> - proto_text_fetched_float
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_DOUBLE</literal> -
         proto_text_fetched_double
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_DATE</literal>,
         <literal>MYSQL_TYPE_NEWDATE</literal> - proto_text_fetched_date
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_YEAR</literal> - proto_text_fetched_year
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_TIME</literal> - proto_text_fetched_time
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_DATETIME</literal> -
         proto_text_fetched_datetime
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_TIMESTAMP</literal> -
         proto_text_fetched_timestamp
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_STRING</literal>,
         <literal>MYSQL_TYPE_VARSTRING</literal>,
         <literal>MYSQL_TYPE_VARCHAR</literal> -
         proto_text_fetched_string
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_TINY_BLOB</literal>,
         <literal>MYSQL_TYPE_MEDIUM_BLOB</literal>,
         <literal>MYSQL_TYPE_LONG_BLOB</literal>,
         <literal>MYSQL_TYPE_BLOB</literal> - proto_text_fetched_blob
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_ENUM</literal> - proto_text_fetched_enum
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_SET</literal> - proto_text_fetched_set
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_GEOMETRY</literal> -
         proto_text_fetched_geometry
        </para>
       </listitem>
       <listitem>
        <para>
         Любые не перечисленные <literal>MYSQL_TYPE_*</literal> - proto_text_fetched_other
        </para>
       </listitem>
      </itemizedlist>
      <para>
       Обратите внимание, что константы типов MYSQL_* могут не ассоциироваться с одинаковыми
       столбцами SQL для разных версий MySQL.
      </para></entry>
    </row>
    <row>
     <entry><literal>proto_binary_fetched_null</literal>,
      <literal>proto_binary_fetched_bit</literal>,
      <literal>proto_binary_fetched_tinyint</literal>
      <literal>proto_binary_fetched_short</literal>,
      <literal>proto_binary_fetched_int24</literal>,
      <literal>proto_binary_fetched_int</literal>,
      <literal>proto_binary_fetched_bigint</literal>,
      <literal>proto_binary_fetched_decimal</literal>,
      <literal>proto_binary_fetched_float</literal>,
      <literal>proto_binary_fetched_double</literal>,
      <literal>proto_binary_fetched_date</literal>,
      <literal>proto_binary_fetched_year</literal>,
      <literal>proto_binary_fetched_time</literal>,
      <literal>proto_binary_fetched_datetime</literal>,
      <literal>proto_binary_fetched_timestamp</literal>,
      <literal>proto_binary_fetched_string</literal>,
      <literal>proto_binary_fetched_blob</literal>,
      <literal>proto_binary_fetched_enum</literal>,
      <literal>proto_binary_fetched_set</literal>,
      <literal>proto_binary_fetched_geometry</literal>,
      <literal>proto_binary_fetched_other</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество столбцов определённого типа, извлечённых подготовленными запросами
      (бинарный протокол MySQL).</entry>
     <entry>Связь типов с <literal>proto_text_*</literal> смотрите в предыдущем пункте.</entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 <table xml:id="mysqlnd.stats.connection">
  <title>Статистика mysqlnd: Соединение</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Метрика</entry>
     <entry>Область применения</entry>
     <entry>Описание</entry>
     <entry>Замечания</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>connect_success</literal>, <literal>connect_failure</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество удачных/неудачных попыток соединения.</entry>
     <entry>Переиспользованные и прочие типы соединений включаются.</entry>
    </row>
    <row>
     <entry><literal>reconnect</literal></entry>
     <entry>Процесс</entry>
     <entry>Общее количество попыток выполнить real_connect на уже открытом соединении.</entry>
     <entry>Следующий код <literal>$link = new mysqli(...);
      $link-&gt;real_connect(...)</literal> приведёт к пересоединению. Но
      <literal>$link = new mysqli(...); $link-&gt;connect(...)</literal>
      не приведёт, так как <literal>$link-&gt;connect(...)</literal> принудительно
      закроет существующее соединение перед созданием нового.</entry>
    </row>
    <row>
     <entry><literal>pconnect_success</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество успешных попыток открыть постоянное соединение</entry>
     <entry>Обратите внимание, что <literal>connect_success</literal> содержит суммарное
      количество обычных и постоянных соединений. Так что количество обычных
      соединений можно вычислить так: <literal>connect_success</literal> -
      <literal>pconnect_success</literal>.</entry>
    </row>
    <row>
     <entry><literal>active_connections</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество активных соединений, как обычных, так и постоянных.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>active_persistent_connections</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество активных постоянных соединений.</entry>
     <entry>Общее количество активных непостоянных соединений равно:
      <literal>active_connections</literal> -
      <literal>active_persistent_connections</literal>.</entry>
    </row>
    <row>
     <entry><literal>explicit_close</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество явно закрытых соединений (только ext/mysqli).</entry>
     <entry>Пример кода, в котором явно закрывается соединение:
      <programlisting>
<![CDATA[
$link = new mysqli(...); $link->close(...)
$link = new mysqli(...); $link->connect(...)
]]>
      </programlisting></entry>
    </row>
    <row>
     <entry><literal>implicit_close</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество неявно закрытых соединений (только ext/mysqli).</entry>
     <entry>Пример кода, в котором соединение закрывается не явно:
      <itemizedlist>
       <listitem>
        <para>
         <literal>$link = new mysqli(...);
          $link-&gt;real_connect(...)</literal>
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>unset($link)</literal>
        </para>
       </listitem>
       <listitem>
        <para>
         Постоянное соединение: соединение было создано с помощью
         real_connect и, возможно, с неизвестным набором опций - закрывается
         неявно для предотвращения переиспользования соединения с неизвестным набором опций
        </para>
       </listitem>
       <listitem>
        <para>
         Постоянное соединение: ping/change_user завершаются с ошибкой и ext/mysqli
         закрывает соединение
        </para>
       </listitem>
       <listitem>
        <para>
         Окончание работы скрипта: закрываются соединения, не закрытые пользователем явно
        </para>
       </listitem>
      </itemizedlist></entry>
    </row>
    <row>
     <entry><literal>disconnect_close</literal></entry>
     <entry>Соединение</entry>
     <entry>Ошибки соединения возвращаемые при вызове C API
      <function>mysql_real_connect</function> во время установления соединения.</entry>
     <entry>Вызывается <literal>disconnect_close</literal>, потому, что идентификатор
      соединения, переданный в вызов C API, должен быть закрыт.</entry>
    </row>
    <row>
     <entry><literal>in_middle_of_command_close</literal></entry>
     <entry>Процесс</entry>
     <entry>Соединение закрыто во время исполнения команды
      (результирующий набор не извлечён, после запуска запроса и до
      получения ответа, во время извлечения данных, во время загрузки
      данных с помощью LOAD DATA).</entry>
     <entry>Если вы не используете асинхронные запросы, подобное может произойти
      только в том случае, если работа скрипта неожиданно прервалась и PHP автоматически закрыл
      соединение.</entry>
    </row>
    <row>
     <entry><literal>init_command_executed_count</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество запусков инициализирующих команд, к примеру
      <literal>mysqli_options(MYSQLI_INIT_COMMAND , ...)</literal>.</entry>
     <entry>Количество успешно запущенных команд равно
      <literal>init_command_executed_count</literal> -
      <literal>init_command_failed_count</literal>.</entry>
    </row>
    <row>
     <entry><literal>init_command_failed_count</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество неудачных инициализирующих команд.</entry>
     <entry></entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 <table xml:id="mysqlnd.stats.com">
  <title>Статистика mysqlnd: Команды COM_*</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Метрика</entry>
     <entry>Область применения</entry>
     <entry>Описание</entry>
     <entry>Замечания</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>com_quit</literal>, <literal>com_init_db</literal>,
      <literal>com_query</literal>, <literal>com_field_list</literal>,
      <literal>com_create_db</literal>, <literal>com_drop_db</literal>,
      <literal>com_refresh</literal>, <literal>com_shutdown</literal>,
      <literal>com_statistics</literal>,
      <literal>com_process_info</literal>,
      <literal>com_connect</literal>,
      <literal>com_process_kill</literal>, <literal>com_debug</literal>,
      <literal>com_ping</literal>, <literal>com_time</literal>,
      <literal>com_delayed_insert</literal>,
      <literal>com_change_user</literal>,
      <literal>com_binlog_dump</literal>,
      <literal>com_table_dump</literal>,
      <literal>com_connect_out</literal>,
      <literal>com_register_slave</literal>,
      <literal>com_stmt_prepare</literal>,
      <literal>com_stmt_execute</literal>,
      <literal>com_stmt_send_long_data</literal>,
      <literal>com_stmt_close</literal>,
      <literal>com_stmt_reset</literal>,
      <literal>com_stmt_set_option</literal>,
      <literal>com_stmt_fetch</literal>, <literal>com_daemon</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество попыток послать одну из COM_* команд из PHP серверу MySQL.</entry>
     <entry><para>
      Метрика увеличивается после проверки синтаксиса команды и непосредственно
      перед отсылкой соответствующего пакета серверу MySQL.
      Если mysqlnd не удалось послать пакет, метрика не будет уменьшена.
      В случае неудачной посылки mysqlnd вернёт предупреждение <quote>Error while sending %s packet.
      PID=%d.</quote>
      </para>

      <para>
       Примеры использования:
      </para>
      <itemizedlist>
       <listitem>
        <para>
         Отследить, что PHP посылает определённые команды серверу,
         например, что клиент шлёт <literal>COM_PROCESS_KILL</literal>
        </para>
       </listitem>
       <listitem>
        <para>
         Посчитать среднее количество запусков подготовленных запросов,
         сравнив <literal>COM_EXECUTE</literal> с
         <literal>COM_PREPARE</literal>
        </para>
       </listitem>
       <listitem>
        <para>
         Проверить, что PHP исполняет неподготовленные запросы, убедившись,
         что <literal>COM_QUERY</literal> равно нулю
        </para>
       </listitem>
       <listitem>
        <para>
         Определить скрипт PHP, выполняющий множество запросов,
         проверив <literal>COM_QUERY</literal> и
         <literal>COM_EXECUTE</literal>
        </para>
       </listitem>
      </itemizedlist></entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 <para>
  <emphasis role="bold">Прочее</emphasis>
 </para>
 <table xml:id="mysqlnd.stats.misc">
  <title>Статистика mysqlnd: Прочее</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Метрика</entry>
     <entry>Область применения</entry>
     <entry>Описание</entry>
     <entry>Замечания</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>explicit_stmt_close</literal>,
      <literal>implicit_stmt_close</literal></entry>
     <entry>Процесс</entry>
     <entry>Общее количество закрытых подготовленных запросов.</entry>
     <entry>Закрытие всегда происходит явно, за исключением ошибок при подготовке.</entry>
    </row>
    <row>
     <entry><literal>mem_emalloc_count</literal>,
      <literal>mem_emalloc_ammount</literal>,
      <literal>mem_ecalloc_count</literal>,
      <literal>mem_ecalloc_ammount</literal>,
      <literal>mem_erealloc_count</literal>,
      <literal>mem_erealloc_ammount</literal>,
      <literal>mem_efree_count</literal>,
      <literal>mem_malloc_count</literal>,
      <literal>mem_malloc_ammount</literal>,
      <literal>mem_calloc_count</literal>,
      <literal>mem_calloc_ammount</literal>,
      <literal>mem_realloc_count</literal>,
      <literal>mem_realloc_ammount</literal>,
      <literal>mem_free_count</literal></entry>
     <entry>Процесс</entry>
     <entry>Вызовы менеджера памяти.</entry>
     <entry>Только для разработчиков.</entry>
    </row>
    <row>
     <entry><literal>command_buffer_too_small</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество модулей сетевого командного буфера в процессе отправки
      команды от PHP серверу MySQL.</entry>
     <entry><para>
      mysqlnd выделяет внутренний командный/сетевой буфер размера
      <literal>mysqlnd.net_cmd_buffer_size</literal>
      (<filename>php.ini</filename>) байт для каждого соединения.
      Если команда клиент-серверного протокола MySQL, к примеру
      <literal>COM_QUERY</literal> (обычный запрос), не помещается в него,
      mysqlnd увеличивает размер буфера до необходимого размера.
      Каждый раз, когда размер буфера увеличивается для соединения,
      <literal>command_buffer_too_small</literal> увеличивается на единицу.
      </para>

      <para>
       Если mysqlnd увеличивает размер буфера более его начального размера
       <literal>mysqlnd.net_cmd_buffer_size</literal>
       (<filename>php.ini</filename>) практически для каждого соединения,
       вам стоит задуматься об изменении этого значения.
      </para>

      <para>
       Размер буфера по умолчанию составляет 4096 байт, что является наименьшим возможным значением. Это значение можно поменять
       в <filename>php.ini</filename> изменив значение ключа
       <literal>mysqlnd.net_cmd_buffer_size</literal> или используя
       <literal>mysqli_options(MYSQLI_OPT_NET_CMD_BUFFER_SIZE, int
        size)</literal>.
      </para></entry>
    </row>
    <row>
     <entry><literal>connection_reused</literal></entry>
     <entry></entry>
     <entry></entry>
     <entry></entry>
    </row>
   </tbody>
  </tgroup>
 </table>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
