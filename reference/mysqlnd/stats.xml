<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: a30c86ae3deab2fcf5b9392ef02bb7fd7ecb5638 Maintainer: rjhdby Status: ready -->
<!-- Reviewed: no -->
<!-- $Revision$ -->
<chapter xml:id="mysqlnd.stats" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Statistics</title>
 <para>
  <emphasis role="bold">Using Statistical Data</emphasis>
 </para>
 <para>
  MySQL Native Driver поддерживает сбор статистики по взаимодействию
  клиента с сервером. Статистика собирается с двух основных точек:
 </para>
 <itemizedlist>
  <listitem>
   <para>
    Клиентская статистика
   </para>
  </listitem>
  <listitem>
   <para>
    Статистика соединения
   </para>
  </listitem>
 </itemizedlist>
 <para>
  Если вы используете расширение <literal>mysqli</literal>, эта статистика
  доступна с помощью двух функций, обращающихся к API:
 </para>
 <itemizedlist>
  <listitem>
   <para>
    <function>mysqli_get_client_stats</function>
   </para>
  </listitem>
  <listitem>
   <para>
    <function>mysqli_get_connection_stats</function>
   </para>
  </listitem>
 </itemizedlist>
 <note>
  <para>
   Статистика аггрегируется со всех расширений использующих MySQL Native
   Driver. К примеру, если подключить и <literal>ext/mysql</literal>
   и <literal>ext/mysqli</literal> через MySQL Native Driver, как вызовы
   функций <literal>ext/mysql</literal> так и <literal>ext/mysqli</literal>
   будут внесены в общую статистику. Возможность разделить статистику
   в зависимости от использованного расширения отсутствует. Вы можете
   сконфигурировать драйвера PDO MySQL, <literal>ext/mysql</literal> и 
   <literal>ext/mysqli</literal> для опционального использования
   MySQL Native Driver. При этом, все три расширения будут изменять статистику.
  </para>
 </note>
 <para>
  <emphasis role="bold">Доступ к клиентской статистике</emphasis>
 </para>
 <para>
  Для получения клиентской статистике необходимо выполнить функцию
  <function>mysqli_get_client_stats</function>. Функция вызывается без параметров.
 </para>
 <para>
  Функция возвращает ассоциативный массив, использующий в качестве ключей
  названия метрик статистики и в качестве значения этих метрик, собственно, значения.
 </para>
 <para>
  Также клиентская статистика доступна с помощью функции
  <function>phpinfo</function>.
 </para>
 <para>
  <emphasis role="bold">Доступ к статистике соединения</emphasis>
 </para>
 <para>
  Для получения статистики соединения, выполните функцию
  <function>mysqli_get_connection_stats</function>, передав в качестве
  параметра ресурс соединения.
 </para>
 <para>
  Функция возвращает ассоциативный массив, использующий в качестве ключей
  названия метрик статистики и в качестве значения этих метрик, собственно, значения.
 </para>
 <para>
  <emphasis role="bold">Буферизованные и небуферизованные результирующие наборы</emphasis>
 </para>
 <para>
  Результирующие наборы могут быть буферизованными и небуферизованными.
  При использовании настроек по умолчанию, <literal>ext/mysql</literal> и 
  <literal>ext/mysqli</literal> работают с буферизованными результирующими
  наборами при использовании нормальных (не подготовленных) запросов.
  Буферизованные результирующие наборы кешируются на стороне клиента.
  После выполнения запроса, все результаты передаются на клиента, где
  сохраняются в кеше. Преимущество буферизованных запросов в том, что
  сразу высвобождаются серверные ресурсы, связанные с хранением результирующего
  набора.
 </para>
 <para>
  Небуферизованные результирующие наборы, с другой стороны,
  сохраняются на сервере гораздо дольше. Если вы хотите сократить потребление
  памяти на клиенте, но при этом нагрузить сервер, используйте небуферизованные
  результирующие наборы. Если узким местом в вашей системе является сервер
  баз данных, то вам стоит задуматься о скорейшем перемещении орезультатов
  на клиента. Обычно клиенты масштабируются гораздо легче, чем сервера БД.
  <quote>Нагрузка</quote> ложится не только на память, но и
  на прочие ресурсы, которые должна поддерживать база данных для обслуживания
  соединения, такие как открытые файловые дескрипторы и нити исполнения.
 </para>
 <para>
  Подготовленные запросы по умолчанию используют небуферизованные
  результирующие наборы. В любом случае, вы можете использовать
  функцию <function>mysqli_stmt_store_result</function> для буферизации результатов.
 </para>
 <para>
  <emphasis role="bold">Статистика возвращаемая MySQL Native Driver</emphasis>
 </para>
 <para>
  Следующая таблица демонстрирует список возвращаемой
  функциями <function>mysqli_get_client_stats</function> и
  <function>mysqli_get_connection_stats</function> статистики.
 </para>
 <table>
  <title>Статистика mysqlnd: Сеть</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Метрика</entry>
     <entry>Область применения</entry>
     <entry>Описание</entry>
     <entry>Замечания</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>bytes_sent</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество байт переданных от PHP на сервер MySQL</entry>
     <entry>Может использоваться для проверки эффективности протокола сжатия</entry>
    </row>
    <row>
     <entry><literal>bytes_received</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество байт полученных от сервера MySQL</entry>
     <entry>Может использоваться для проверки эффективности протокола сжатия</entry>
    </row>
    <row>
     <entry><literal>packets_sent</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество пакетов посланых от клиента серверу MySQL</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола</entry>
    </row>
    <row>
     <entry><literal>packets_received</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество пакетов принятых клиентом от сервера MySQL</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола</entry>
    </row>
    <row>
     <entry><literal>protocol_overhead_in</literal></entry>
     <entry>Соединение</entry>
     <entry>накладные расходы клиент-серверного протокола MySQLв байтах для входящего траффика.
      на данный момент только заголовок пакета (4 байта) считается за накладные расходы.
      protocol_overhead_in = packets_received * 4</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола</entry>
    </row>
    <row>
     <entry><literal>protocol_overhead_out</literal></entry>
     <entry>Соединение</entry>
     <entry>MySQL Client Server protocol overhead in bytes for outgoing traffic.
      Currently only the Packet Header (4 bytes) is considered as
      overhead. protocol_overhead_out = packets_sent * 4</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола</entry>
    </row>
    <row>
     <entry><literal>bytes_received_ok_packet</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество байт принятых ОК-пакетов клиент-серверного протокола MySQL.
      OK-пакеты могут содержать статусные сообщения. Длина статусных сообщений может 
      меняться, следовательно размер ОК-пакетов не фиксирована.</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>packets_received_ok</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество принятых OK-пакетов</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>bytes_received_eof_packet</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество байт принятых EOF-пакетов. Размер EOF-пакета может изменяться
      в зависимости от версии сервера. Также, EOF-пакеты могут использоваться как
      транспорт для сообщений об ошибках.</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>packets_received_eof</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество принятых EOF-пакетов. Как и для прочей статистики
      по пакетам, это число может увеличиваться каждый раз, когда PHP не получает
      ожидаемый пакет, а, к примеру, получае сообщение об ошибке.</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>bytes_received_rset_header_packet</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество байт принятых заголовочных пакетов результирующих наборов.
      Размер пакетов зависит от полезной нагрузки (<literal>LOAD LOCAL INFILE</literal>,
      <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>SELECT</literal>, сообщение об ошибке).
     </entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>packets_received_rset_header</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество пакетов заголовков результирующих наборов.</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>bytes_received_rset_field_meta_packet</literal></entry>
     <entry>Соединение</entry>
     <entry>Общий размер в байтах полученных пакетов с метаданными результирующих наборов
      (информации о столбцах). Естественно размер каждого пакета индивидуален. 
      Эти пакеты могут выступать транспортом для ошибок и EOF-пакетов в случае COM_LIST_FIELDS.</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>packets_received_rset_field_meta</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество полученных пакетов с метаданными результирующих наборов
      (информации о столбцах).</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>bytes_received_rset_row_packet</literal></entry>
     <entry>Соединение</entry>
     <entry>Общий размер в байтах полученных пакетов с данными результирующего набора.
      Эти пакеты могут служить транспортом для ошибок и в качестве EOF-пакетов.
      Вы можете вычислить количество ошибок и EOF-пакетов отняв
      <literal>rows_fetched_from_server_normal</literal> и
      <literal>rows_fetched_from_server_ps</literal> от
      <literal>bytes_received_rset_row_packet</literal>.</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>packets_received_rset_row</literal></entry>
     <entry>Соединение</entry>
     <entry>Кодичество пакетов с данными результирующих наборов и их суммарный объем в байтах.</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>bytes_received_prepare_response_packet</literal></entry>
     <entry>Соединение</entry>
     <entry>Общий размер в байтах ОК-пакетов инициализации подготовленных запросов.
      (инициализирующие пакеты подготовленных запросов). Эти пакеты могут выступать транспортом 
      для ошибок. Рзмер пакета зависит от версии Mysql: 9 байт для MySQL4.1 и 12 байт начиная с 5.0.
      Нет надежного способа узнать количество ошибок. Вы можете определить, что случилась 
      ошибка, если, наример, вы работаете с MySQL 5.0 или новее, а
      <literal>bytes_received_prepare_response_packet</literal> !=
      <literal>packets_received_prepare_response</literal> * 12. Также смотрите
      <literal>ps_prepared_never_executed</literal>, <literal>ps_prepared_once_executed</literal>.
     </entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>packets_received_prepare_response</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество полученных ОК-пакетов для инициализации подготовленных запросов.</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>bytes_received_change_user_packet</literal></entry>
     <entry>Соединение</entry>
     <entry>Общий размер в байтах полученных пакетов COM_CHANGE_USER.
      Пакеты могут служить транспортом для ошибок и EOF-пакетов.</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>packets_received_change_user</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество принятых пакетов COM_CHANGE_USER</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола. Обратите внимание,
      что общий размер включает в себя заголовочный пакет, размером 4 байта.</entry>
    </row>
    <row>
     <entry><literal>packets_sent_command</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество команд посланных от PHP серверу MySQL.
      Возможность узнать, какие конкретно и в каких количествах посылались команды отсутствует.
      Лучшее, для чего вы можете использовать эту метрику, это проверять,
      что посылает команды серверу MySQL и поддержка MySQL в PHP не запрещена.
      Также отсутствует возможность определить количество ошибок, возникших
      при отправке этих команд. Единственная опозноваемая ошибка - это
      command_buffer_too_small (смотрите ниже).</entry>
     <entry>Используется для отладки реализации клиент-серверного протокола</entry>
    </row>
    <row>
     <entry><literal>bytes_received_real_data_normal</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество байт полезной нагрузки извлеченной клиентом PHP из
      <literal>mysqlnd</literal> с использованием текстового протокола.</entry>
     <entry>Это актуальный размер данных содержащихся в результирующем наборе, 
      которые клиент PHP уже загрузил.
      Обратите внимание, что хоть возможно <literal>mysqlnd</literal> забрал и полный
      результирующий набор с сервера MySQL, но в этой метрике учитываются только данные
      уже полученные клиентом PHP от <literal>mysqlnd</literal>. 
      К примеру, следующий код увеличит значение метрики:
      <programlisting>
<![CDATA[
$mysqli = new mysqli();
$res = $mysqli->query("SELECT 'abc'");
$res->fetch_assoc();
$res->close();
]]>
      </programlisting>
      <para>
       Каждая операция извлечения увеличивает это число.
      </para>
      
      <para>
       Статистика не изменится, если результирующий набор был только буферизован,
       но не извлечен, как в этом примере:
      </para>
      <programlisting>
<![CDATA[
$mysqli = new mysqli();
$res = $mysqli->query("SELECT 'abc'");
$res->close();
]]>
      </programlisting>
      <para>
       Эта статистика доступна с PHP версии 5.3.4.
      </para></entry>
    </row>
    <row>
     <entry><literal>bytes_received_real_data_ps</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество байт полезной нагрузки, извлеченной клиентом PHP из
      <literal>mysqlnd</literal> используя подготовленные запросы.</entry>
     <entry>Это размер только тех данных, которые были извлечены клиентом PHP.
      Значение метрики не будет увеличиваться если клиент PHP не будет запрвшивать эти данные.
      Обратите внимание, что хоть возможно <literal>mysqlnd</literal> забрал и полный
      результирующий набор с сервера MySQL, но в этой метрике учитываются только данные
      уже полученные клиентом PHP от <literal>mysqlnd</literal>. 
      Также смотрите <literal>bytes_received_real_data_normal</literal>. 
      Эта метрика доступна с PHP версии 5.3.4.</entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 <para>
  <emphasis role="bold">Результирующий набор</emphasis>
 </para>
 <table>
  <title>Статистика mysqlnd: результирующий набор</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Метрика</entry>
     <entry>Область применения</entry>
     <entry>Описание</entry>
     <entry>Замечания</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>result_set_queries</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество запросов, по которым был создан результирующий набор. 
      Пример запросов, создающих результирующий набор: <literal>SELECT</literal>, <literal>SHOW</literal>. 
      Статистика не будет увеличиваться в случае ошибки чтения заголовочного
      пакета результирующего набора.</entry>
     <entry>Вы можете использовать эту метрику, как опосредованный счетчик выполненых запросов,
      например для обнаружения клиента, создающего большую нагрузку на БД.</entry>
    </row>
    <row>
     <entry><literal>non_result_set_queries</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество запросов, по которым не был создан результирующий набор. 
      Пример запросов, не создающих результирующий набор:
      <literal>INSERT</literal>, <literal>UPDATE</literal>,
      <literal>LOAD DATA</literal>. 
      Статистика не будет увеличиваться в случае ошибки чтения заголовочного
      пакета результирующего набора.</entry>
     <entry>Вы можете использовать эту метрику, как опосредованный счетчик выполненых запросов,
      например для обнаружения клиента, создающего большую нагрузку на БД.</entry>
    </row>
    <row>
     <entry><literal>no_index_used</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество запросов, создающих результирующий набор, но не использовавших
      индексы (также смотрите опцию запуска mysqld –log-queries-not-using-indexes). 
      Если вы хотите получать отчеты о подобных запросах, вы можете
      использовать mysqli_report(MYSQLI_REPORT_INDEX) для того, что бы
      ext/mysqli выбрасывал исключение. Если вы предпочитаете просто предупреждение,
      используйте mysqli_report(MYSQLI_REPORT_INDEX ^ MYSQLI_REPORT_STRICT).</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>bad_index_used</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество запросов, создающих результирующий набор, но не использовавших
      хорошие индексы (также смотрите опцию запуска mysqld –log-slow-queries).</entry>
     <entry>Если вы хотите получать отчеты о подобных запросах, вы можете
      использовать mysqli_report(MYSQLI_REPORT_INDEX)для того, что бы
      ext/mysqli выбрасывал исключение. Если вы предпочитаете просто предупреждение,
      используйте mysqli_report(MYSQLI_REPORT_INDEX ^ MYSQLI_REPORT_STRICT)</entry>
    </row>
    <row>
     <entry><literal>slow_queries</literal></entry>
     <entry>Соединение</entry>
     <entry>SQL-запросы, выполнявшиеся долешь чем <literal>long_query_time</literal>
      секунд и потребовавшие перебора более чем <literal>min_examined_row_limit</literal> 
      строк.</entry>
     <entry>Не извлекается с помощью <function>mysqli_report</function></entry>
    </row>
    <row>
     <entry><literal>buffered_sets</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество буферезированных результирующих наборов возвращенных
      <quote>нормальными</quote> запросами.
      <quote>Нормальные</quote>, здесь и дальше значит <quote>не подготовленные</quote>.</entry>
     <entry>Примеры вызовов API, буферизующих результирующий набор на клиенте:
      <function>mysql_query</function>,
      <function>mysqli_query</function>,
      <function>mysqli_store_result</function>,
      <function>mysqli_stmt_get_result</function>. Буферизация результирующего
      набора на клиенте гарантирует, что серверные ресурсы будут освобождены
      так быстро, как возможно и делает позиционирование более простым.
      Плохая новость в том, что это будет стоит дополнительного расхода памяти на клиенте.
      Обратите внимание, что mysqlnd (в отличии от клиентской библиотеки MySQL) зависит 
      от ограничений PHP на память, поскольку использует внутренний менеджер памяти
      PHP. Это является одной из причин, почему <function>memory_get_usage</function> 
      при использовании mysqlnd показывает большие значение, чем при использовании
      клиенктской библиотеки MySQL. <function>memory_get_usage</function> не замеряет 
      потребление памяти клиентской библиотекой MySQL, поскольку он
      не использует внутренний менеджер памяти PHP.</entry>
    </row>
    <row>
     <entry><literal>unbuffered_sets</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество небуферизованных результирующих наборов возвращенных нормальными
      (не подготовленными) запросами.</entry>
     <entry>Примеры вызовов API, не буферизующих результирующий набор на клиенте:
      <function>mysqli_use_result</function></entry>
    </row>
    <row>
     <entry><literal>ps_buffered_sets</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество буферизованных результирующих наборов возвращенных
      подготовленными запросами. По умолчанию, подготовленные запросы
      не буферизируются.</entry>
     <entry>Примеры вызовов API, буферизующих результирующий набор на клиенте:
      <literal>mysqli_stmt_store_result</literal></entry>
    </row>
    <row>
     <entry><literal>ps_unbuffered_sets</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество небуферизованных результирующих наборов возвращенных
      подготовленными запросами.</entry>
     <entry>По умолчанию, подготовленные запросы
      не буферизируются.</entry>
    </row>
    <row>
     <entry><literal>flushed_normal_sets</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество результирующих наборов возвращенных нормальными (не подготовленными)
      запросами с непрочтенными данными, которые были обнулены прозрачно для вас.
      Подобное происходит только с небуферизированными результирующими наборами.</entry>
     <entry>Небуферизированные результирующие наборы должны быть полностью извлечены,
      прежде чем будет возможно запустить новый запрос в том же соединении с MySQL, в противном
      случае произойдет ошибка. Если приложение не извлекло все строки небуферизированного
      результирующего набора, mysqlnd принудительно извлечет его, что бы освободить ресурсы
      сервера. Также смотрите <literal>rows_skipped_normal</literal> и
      <literal>rows_skipped_ps</literal>. Возможные причины, ведущие к принудительному обнулению:
      <itemizedlist>
       <listitem>
        <para>
         Ошибка клиентского приложения
        </para>
       </listitem>
       <listitem>
        <para>
         Клиент перестал извлекать записи, так как нашел, что искал, но
         результирующий набор еще не был извлечен до конца
        </para>
       </listitem>
       <listitem>
        <para>
         Аварийное завершение клиентского приложения
        </para>
       </listitem>
      </itemizedlist></entry>
    </row>
    <row>
     <entry><literal>flushed_ps_sets</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество результирующих наборов возвращенных подготовленными
      запросами с непрочтенными данными, которые были обнулены прозрачно для вас.
      Подобное происходит только с небуферизированными результирующими наборами.</entry>
     <entry>Небуферизированные результирующие наборы должны быть полностью извлечены,
      прежде чем будет возможно запустить новый запрос в том же соединении с MySQL, в противном
      случае произойдет ошибка. Если приложение не извлекло все строки небуферизированного
      результирующего набора, mysqlnd принудительно извлечет его, что бы освободить ресурсы
      сервера. Также смотрите <literal>rows_skipped_normal</literal> и
      <literal>rows_skipped_ps</literal>. Возможные причины, ведущие к принудительному обнулению:
      <itemizedlist>
       <listitem>
        <para>
         Ошибка клиентского приложения
        </para>
       </listitem>
       <listitem>
        <para>
         Клиент перестал извлекать записи, так как нашел, что искал, но
         результирующий набор еще не был извлечен до конца
        </para>
       </listitem>
       <listitem>
        <para>
         Аварийное завершение клиентского приложения
        </para>
       </listitem>
      </itemizedlist></entry>
    </row>
    <row>
     <entry><literal>ps_prepared_never_executed</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество подготовленных, но не запущенных запросов.</entry>
     <entry>Подготовленные запросы потребляют серверные ресурсы. Вы не должны
      подготавливать запросы, если не будете их запускать.</entry>
    </row>
    <row>
     <entry><literal>ps_prepared_once_executed</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество подготовленных запросов, запущенных только один раз.</entry>
     <entry>Главная идея подготовленных запросов в том, что один и тот же запрос
      будет запускаться несколько раз, но, возможно, с другими параметрами. Это
      позволяет сэкономить на подготовке запросов, позволяя произвести разбор
      запроса только один раз, а потом просто подставлять в него параметры и запускать.
      При подготовке запроса происходит <quote>кеширование</quote> результата, например
      можно многократно использовать дерево разбора, созданное один раз на жтапе подготовки.
      Если же вы запускаете подготовленный запрос всего один раз, то никакого выйгрыша
      по сравнению с <quote>нормальными</quote> запросами не будет, даже наоборот, будут
      дополнительные накладные расходы на кеширование подготовленного запроса.
      Таким образом, подготовленные запросы, которые используются всего один раз,
      ведут к ухудшению производительности.</entry>
    </row>
    <row>
     <entry><literal>rows_fetched_from_server_normal</literal>,
      <literal>rows_fetched_from_server_ps</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество успешно извлеченных строк из базы MySQL,
      независимо от того, использованы они были приложением или нет.
      Часть строк могут не извлекаться приложением, но при этом
      принудительно обнуляться.</entry>
     <entry>Также смотрите <literal>packets_received_rset_row</literal></entry>
    </row>
    <row>
     <entry><literal>rows_buffered_from_client_normal</literal>,
      <literal>rows_buffered_from_client_ps</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество успешно буферизованных строк, полученных 
      при выполнении "нормальных" запросов. Это количество строк, извлеченных 
      из MySQL и буферизованных на клиенте. Обратите внимание, что существует
      две независимые метрики для буферизованных строк и (переданых
      от MySQL в буфер mysqlnd) и строк, прочтенных приложением (переданных
      из буфера mysqlnd клиентскому приложению). Если количество буферизованных 
      строк больше чем число извлеченных клиентом, то стоит обратить
      внимание на клиентские запросы, так как они извлекают больше данных, чем
      им на самом деле нужно.</entry>
     <entry>Пример запросов, буферизующих результирующие наборы:
      <function>mysqli_query</function>,
      <function>mysqli_store_result</function></entry>
    </row>
    <row>
     <entry><literal>rows_fetched_from_client_normal_buffered</literal>,
      <literal>rows_fetched_from_client_ps_buffered</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество извлеченных клиентов строк из буферизованных
      результирующих наборов для любого типа запросов.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>rows_fetched_from_client_normal_unbuffered</literal>,
      <literal>rows_fetched_from_client_ps_unbuffered</literal></entry>
     <entry>Соединение</entry>
     <entry>Total number of rows fetched by the client from a unbuffered result set
      created by a "normal" query or a prepared statement.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>rows_fetched_from_client_ps_cursor</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество извлеченных клиентов строк из небуферизованных
      результирующих наборов для любого типа запросов.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>rows_skipped_normal</literal>,
      <literal>rows_skipped_ps</literal></entry>
     <entry>Соединение</entry>
     <entry>Зарезервированно для использования в будущем и в данный момент не поддерживается</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>copy_on_write_saved</literal>,
      <literal>copy_on_write_performed</literal></entry>
     <entry>Процесс</entry>
     <entry>Если используется mysqlnd: переменные, возвращенные расширением, указывающие 
      на внутренний сетевой буфер результатов mysqlnd. если вы не меняли переменные,
      извлеченные данные будут сохранены в памяти один раз. если вы
      меняли переменные, mysqlnd выполнит копирование при записи для
      защиты внутренних сетевых буферов результата от изменения.
      Если используется клиентская библиотека MySQL: вы всегда держите
      извлеченные данные в памяти в двух экземплярах. Один раз во внутренних
      буферах клиентской библиотеки MySQL, и еще один раз в переменных, возвращенных
      расширением. В теории, mysqlnd может до 40% сократить потребление памяти.
      В любом случае помните, что эту экономию не удастся замерить
      с помощью <function>memory_get_usage</function>.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>explicit_free_result</literal>,
      <literal>implicit_free_result</literal></entry>
     <entry>Соединение, процесс (только на стадии очистки подготовленных запросов)</entry>
     <entry>Общее количество высвобожденных результирующих наборов.</entry>
     <entry>Очистка всегда производится явно, но для результирующих наборов, созданных 
      инициализирующими командами, например
      <literal>mysqli_options(MYSQLI_INIT_COMMAND , ...)</literal></entry>
    </row>
    <row>
     <entry><literal>proto_text_fetched_null</literal>,
      <literal>proto_text_fetched_bit</literal>,
      <literal>proto_text_fetched_tinyint</literal>
      <literal>proto_text_fetched_short</literal>,
      <literal>proto_text_fetched_int24</literal>,
      <literal>proto_text_fetched_int</literal>
      <literal>proto_text_fetched_bigint</literal>,
      <literal>proto_text_fetched_decimal</literal>,
      <literal>proto_text_fetched_float</literal>
      <literal>proto_text_fetched_double</literal>,
      <literal>proto_text_fetched_date</literal>,
      <literal>proto_text_fetched_year</literal>
      <literal>proto_text_fetched_time</literal>,
      <literal>proto_text_fetched_datetime</literal>,
      <literal>proto_text_fetched_timestamp</literal>
      <literal>proto_text_fetched_string</literal>,
      <literal>proto_text_fetched_blob</literal>,
      <literal>proto_text_fetched_enum</literal>
      <literal>proto_text_fetched_set</literal>,
      <literal>proto_text_fetched_geometry</literal>,
      <literal>proto_text_fetched_other</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество столбцов определенного типа, извлеченных нормальными запросами
      (текстовый протокол MySQL).</entry>
     <entry>Связка метаданных C API / MySQL с именами метрик статистики:
      <itemizedlist>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_NULL</literal> - proto_text_fetched_null
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_BIT</literal> - proto_text_fetched_bit
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_TINY</literal> - proto_text_fetched_tinyint
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_SHORT</literal> - proto_text_fetched_short
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_INT24</literal> - proto_text_fetched_int24
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_LONG</literal> - proto_text_fetched_int
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_LONGLONG</literal> -
         proto_text_fetched_bigint
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_DECIMAL</literal>,
         <literal>MYSQL_TYPE_NEWDECIMAL</literal> -
         proto_text_fetched_decimal
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_FLOAT</literal> - proto_text_fetched_float
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_DOUBLE</literal> -
         proto_text_fetched_double
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_DATE</literal>,
         <literal>MYSQL_TYPE_NEWDATE</literal> - proto_text_fetched_date
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_YEAR</literal> - proto_text_fetched_year
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_TIME</literal> - proto_text_fetched_time
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_DATETIME</literal> -
         proto_text_fetched_datetime
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_TIMESTAMP</literal> -
         proto_text_fetched_timestamp
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_STRING</literal>,
         <literal>MYSQL_TYPE_VARSTRING</literal>,
         <literal>MYSQL_TYPE_VARCHAR</literal> -
         proto_text_fetched_string
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_TINY_BLOB</literal>,
         <literal>MYSQL_TYPE_MEDIUM_BLOB</literal>,
         <literal>MYSQL_TYPE_LONG_BLOB</literal>,
         <literal>MYSQL_TYPE_BLOB</literal> - proto_text_fetched_blob
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_ENUM</literal> - proto_text_fetched_enum
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_SET</literal> - proto_text_fetched_set
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>MYSQL_TYPE_GEOMETRY</literal> -
         proto_text_fetched_geometry
        </para>
       </listitem>
       <listitem>
        <para>
         Любые не перечисленные <literal>MYSQL_TYPE_*</literal> - proto_text_fetched_other
        </para>
       </listitem>
      </itemizedlist>
      <para>
       Обратите внимение, что константы типов MYSQL_* могут не ассоциироваться с одинаковыми
       столбцами SQL для разных версий MySQL.
      </para></entry>
    </row>
    <row>
     <entry><literal>proto_binary_fetched_null</literal>,
      <literal>proto_binary_fetched_bit</literal>,
      <literal>proto_binary_fetched_tinyint</literal>
      <literal>proto_binary_fetched_short</literal>,
      <literal>proto_binary_fetched_int24</literal>,
      <literal>proto_binary_fetched_int</literal>,
      <literal>proto_binary_fetched_bigint</literal>,
      <literal>proto_binary_fetched_decimal</literal>,
      <literal>proto_binary_fetched_float</literal>,
      <literal>proto_binary_fetched_double</literal>,
      <literal>proto_binary_fetched_date</literal>,
      <literal>proto_binary_fetched_year</literal>,
      <literal>proto_binary_fetched_time</literal>,
      <literal>proto_binary_fetched_datetime</literal>,
      <literal>proto_binary_fetched_timestamp</literal>,
      <literal>proto_binary_fetched_string</literal>,
      <literal>proto_binary_fetched_blob</literal>,
      <literal>proto_binary_fetched_enum</literal>,
      <literal>proto_binary_fetched_set</literal>,
      <literal>proto_binary_fetched_geometry</literal>,
      <literal>proto_binary_fetched_other</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество столбцов определенного типа, извлеченных подготовленными запросами
      (бинарный протокол MySQL).</entry>
     <entry>Связь типов с <literal>proto_text_*</literal> смотри в предыдущем пункте.</entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 <table>
  <title>Статистика mysqlnd: Соединение</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Метрика</entry>
     <entry>Область применения</entry>
     <entry>Описание</entry>
     <entry>Замечания</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>connect_success</literal>, <literal>connect_failure</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество удачных/неудачных попыток соединения.</entry>
     <entry>Переиспользованные и прочие типы соединений включаются.</entry>
    </row>
    <row>
     <entry><literal>reconnect</literal></entry>
     <entry>Процесс</entry>
     <entry>Общее количество попыток выполнить real_connect на уже открытом соединении.</entry>
     <entry>Следующий код <literal>$link = new mysqli(...);
      $link-&gt;real_connect(...)</literal> приведет к пересоединению. Но
      <literal>$link = new mysqli(...); $link-&gt;connect(...)</literal>
      не приведет, так как <literal>$link-&gt;connect(...)</literal> принудительно
      закроет существующее соединение перед созданием нового.</entry>
    </row>
    <row>
     <entry><literal>pconnect_success</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество успешных попыток открыть постоянное соединение</entry>
     <entry>Обратите внимание, что <literal>connect_success</literal> содержит суммарное
      количество обычных и постоянных соединений. Так что количество обычных
      соединений можно вычислить так: <literal>connect_success</literal> -
      <literal>pconnect_success</literal>.</entry>
    </row>
    <row>
     <entry><literal>active_connections</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество активных соединений, как обычных, так и постоянных.</entry>
     <entry></entry>
    </row>
    <row>
     <entry><literal>active_persistent_connections</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество активных постоянных соединений.</entry>
     <entry>Общее количество активных непостоянных соединений равно:
      <literal>active_connections</literal> -
      <literal>active_persistent_connections</literal>.</entry>
    </row>
    <row>
     <entry><literal>explicit_close</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество явно закрытых соединений (только ext/mysqli).</entry>
     <entry>Пример кода, в котором явно закрывается соединение:
      <programlisting>
<![CDATA[
$link = new mysqli(...); $link->close(...)
$link = new mysqli(...); $link->connect(...)
]]>
      </programlisting></entry>
    </row>
    <row>
     <entry><literal>implicit_close</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество неявно закрытых соединений (только ext/mysqli).</entry>
     <entry>Пример кода, в котором соединение закрывается не явно:
      <itemizedlist>
       <listitem>
        <para>
         <literal>$link = new mysqli(...);
          $link-&gt;real_connect(...)</literal>
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>unset($link)</literal>
        </para>
       </listitem>
       <listitem>
        <para>
         Постоянное соединение: соединение было создано с помощью
         real_connect и, возможно, с неизвестным набором опций - закрывается
         неявно для предотвращения переиспользования соединения с неизвестным набором опций
        </para>
       </listitem>
       <listitem>
        <para>
         Постоянное соединение: ping/change_user завершаются с ошибкой и ext/mysqli
         закрывает соединение
        </para>
       </listitem>
       <listitem>
        <para>
         Окончание работы скрипта: закрываются соединения, не закрытые пользователем явно
        </para>
       </listitem>
      </itemizedlist></entry>
    </row>
    <row>
     <entry><literal>disconnect_close</literal></entry>
     <entry>Соединение</entry>
     <entry>Ошибки соединения возвращаемые при вызове C API
      <function>mysql_real_connect</function> во время установления соединения.</entry>
     <entry>Вызывается <literal>disconnect_close</literal>, потому, что идентификатор
      соединения, переданный в вызов C API, должен быть закрыт.</entry>
    </row>
    <row>
     <entry><literal>in_middle_of_command_close</literal></entry>
     <entry>Процесс</entry>
     <entry>Соединение закрыто во время исполнения команды
      (результирующий набор не извлечен, после запуска запроса и до  
      получения ответа, во время извлечения данных, во время загрузки
      данных с помощью LOAD DATA).</entry>
     <entry>если вы не используете асинхронные запросы, подобное может случиться
      только если работа скрипта неожиданно прервалась и PHP автоматически закрыл
      соединение.</entry>
    </row>
    <row>
     <entry><literal>init_command_executed_count</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество запусков инициализирующих команд, к примеру
      <literal>mysqli_options(MYSQLI_INIT_COMMAND , ...)</literal>.</entry>
     <entry>Количество успешно запущенных команд равно
      <literal>init_command_executed_count</literal> -
      <literal>init_command_failed_count</literal>.</entry>
    </row>
    <row>
     <entry><literal>init_command_failed_count</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество неудачных инициализирующих команд.</entry>
     <entry></entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 <table>
  <title>Статистика mysqlnd: Команды COM_*</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Метрика</entry>
     <entry>Область применения</entry>
     <entry>Описание</entry>
     <entry>Замечания</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>com_quit</literal>, <literal>com_init_db</literal>,
      <literal>com_query</literal>, <literal>com_field_list</literal>,
      <literal>com_create_db</literal>, <literal>com_drop_db</literal>,
      <literal>com_refresh</literal>, <literal>com_shutdown</literal>,
      <literal>com_statistics</literal>,
      <literal>com_process_info</literal>,
      <literal>com_connect</literal>,
      <literal>com_process_kill</literal>, <literal>com_debug</literal>,
      <literal>com_ping</literal>, <literal>com_time</literal>,
      <literal>com_delayed_insert</literal>,
      <literal>com_change_user</literal>,
      <literal>com_binlog_dump</literal>,
      <literal>com_table_dump</literal>,
      <literal>com_connect_out</literal>,
      <literal>com_register_slave</literal>,
      <literal>com_stmt_prepare</literal>,
      <literal>com_stmt_execute</literal>,
      <literal>com_stmt_send_long_data</literal>,
      <literal>com_stmt_close</literal>,
      <literal>com_stmt_reset</literal>,
      <literal>com_stmt_set_option</literal>,
      <literal>com_stmt_fetch</literal>, <literal>com_daemon</literal></entry>
     <entry>Соединение</entry>
     <entry>Общее количество попыток послать одну из COM_* команд из PHP серверу MySQL.</entry>
     <entry><para>
      Метрика увеличивается после проверки синтаксиса команды и непосредственно
      перед отсылкой соответствующего пакета серверу MySQL.
      Если mysqlnd не удалось послать пакет, метрика не будет уменьшина.
      В случае неудачной посылки mysqlnd вернет предупреждение <quote>Error while sending %s packet.
      PID=%d.</quote>
      </para>
      
      <para>
       Примеры использования:
      </para>
      <itemizedlist>
       <listitem>
        <para>
         Отследить, что PHP посылает определенные команды серверу,
         например, что клиент шлет <literal>COM_PROCESS_KILL</literal>
        </para>
       </listitem>
       <listitem>
        <para>
         Посчитать среднее количество запусков подготовленных запросов,
         сравнив <literal>COM_EXECUTE</literal> с
         <literal>COM_PREPARE</literal>
        </para>
       </listitem>
       <listitem>
        <para>
         Проверить, что PHP исполняет неподготовленные запросы, убедившись,
         что <literal>COM_QUERY</literal> равно нулю
        </para>
       </listitem>
       <listitem>
        <para>
         Определить скрипт PHP, выполняющий множество запросов, 
         проверив <literal>COM_QUERY</literal> и
         <literal>COM_EXECUTE</literal>
        </para>
       </listitem>
      </itemizedlist></entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 <para>
  <emphasis role="bold">Прочее</emphasis>
 </para>
 <table>
  <title>Статистика mysqlnd: Прочее</title>
  <tgroup cols="4">
   <colspec colwidth="10*"/>
   <colspec colwidth="10*"/>
   <colspec colwidth="40*"/>
   <colspec colwidth="40*"/>
   <thead>
    <row>
     <entry>Метрика</entry>
     <entry>Область применения</entry>
     <entry>Описание</entry>
     <entry>Замечания</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry><literal>explicit_stmt_close</literal>,
      <literal>implicit_stmt_close</literal></entry>
     <entry>Процесс</entry>
     <entry>Общее количество закрытых подготовленных запросов.</entry>
     <entry>Закрытие всегда происходит явно, за исключением ошибок при подготовке.</entry>
    </row>
    <row>
     <entry><literal>mem_emalloc_count</literal>,
      <literal>mem_emalloc_ammount</literal>,
      <literal>mem_ecalloc_count</literal>,
      <literal>mem_ecalloc_ammount</literal>,
      <literal>mem_erealloc_count</literal>,
      <literal>mem_erealloc_ammount</literal>,
      <literal>mem_efree_count</literal>,
      <literal>mem_malloc_count</literal>,
      <literal>mem_malloc_ammount</literal>,
      <literal>mem_calloc_count</literal>,
      <literal>mem_calloc_ammount</literal>,
      <literal>mem_realloc_count</literal>,
      <literal>mem_realloc_ammount</literal>,
      <literal>mem_free_count</literal></entry>
     <entry>Процесс</entry>
     <entry>Вызовы менеджера памяти.</entry>
     <entry>Только для разработчиков.</entry>
    </row>
    <row>
     <entry><literal>command_buffer_too_small</literal></entry>
     <entry>Соединение</entry>
     <entry>Количество расширений сетевого командного буфера в процессе отправки
      команды от PHP серверу MySQL.</entry>
     <entry><para>
      mysqlnd выделяет внутренний командный/сетевой буфер размера
      <literal>mysqlnd.net_cmd_buffer_size</literal>
      (<filename>php.ini</filename>) байт для каждого соединения.
      Если команда клиент-серверного протокола MySQL, к примеру
      <literal>COM_QUERY</literal> (обычный запрос), не помещается в него,
      mysqlnd увеличивает размер буфера до необходимого размера.
      Каждый раз, когда размер буфера увеличивается длясоединения,
      <literal>command_buffer_too_small</literal> увеличивается на единицу.
      </para>
      
      <para>
       Если mysqlnd увеличивает размер буфера более его начального размера
       <literal>mysqlnd.net_cmd_buffer_size</literal>
       (<filename>php.ini</filename>) практически для каждого соединения, 
       вам стоит задуматься об изменении этого значения.
      </para>
      
      <para>
       Размер буфера по умолчанию равен 2048 байт в PHP 5.3.0. В будущих
       версиях по умолчанию будет 4kB или больше. Это значение можно поменять
       в <filename>php.ini</filename> изменив значение ключа
       <literal>mysqlnd.net_cmd_buffer_size</literal> или используя
       <literal>mysqli_options(MYSQLI_OPT_NET_CMD_BUFFER_SIZE, int
        size)</literal>.
      </para>
      
      <para>
       рекомендуется устанавливать размер буфера не менее 4096 байт,
       потому как mysqlnd также использует его при чтении определенных
       комуникационных пакетов от сервера MySQL. В PHP 5.3.0, mysqlnd не
       увеличивает буфер, если MySQL шлет пакет больший текущего размера буфера.
       Из-за этого mysqlnd не может принять такой пакет и возвращает
       ошибку пользовательскому приложению. Есть только два варианта,
       когда размер пакета может быть более 2048 байт
       (значение <literal>mysqlnd.net_cmd_buffer_size</literal> по умолчанию в PHP 5.3.0)
       : пакет содержит очень длинное сообщение, либо если пакет содержит
       метаданные столбцов из <literal>COM_LIST_FIELD</literal>
       (<function>mysql_list_fields</function>) и метаданные содержат
       данный о строковом столбце с очень длинным значением по умолчанию (>1900 байт).
       Ни одного сообщение о подобных проблемах не зафиксировано, но опасность есть.
      </para>
      
      <para>
       Начиная с PHP 5.3.2, mysqlnd не позволяет задавать размер буфера меньше 4096 байт.
      </para></entry>
    </row>
    <row>
     <entry><literal>connection_reused</literal></entry>
     <entry></entry>
     <entry></entry>
     <entry></entry>
    </row>
   </tbody>
  </tgroup>
 </table>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
