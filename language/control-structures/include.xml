<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 676d5ed969778ce8c67b6a1d468ecb51ecd3170f Maintainer: mch Status: ready -->
<!-- Reviewed: no -->
<!-- $Revision$ -->

<sect1 xml:id="function.include" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>include</title>
 <?phpdoc print-version-for="include"?>
 <simpara>
  Выражение <literal>include</literal> включает и выполняет
  указанный файл.
 </simpara>
 <simpara>
  Документация ниже также относится к выражению <function>require</function>.
 </simpara>
 <simpara>
  Файлы включаются исходя из пути указанного файла, или, если путь не указан,
  используется путь, указанный в директиве <link linkend="ini.include-path">include_path</link>. Если файл 
  не найден в <link linkend="ini.include-path">include_path</link>,
  <literal>include</literal> попытается проверить директорию, в которой находится текущий включающий скрипт
  и текущую рабочую директорию перед тем, как выдать ошибку. Конструкция 
  <literal>include</literal> выдаст <link linkend="errorfunc.constants.errorlevels.e-warning">warning</link>, если
  не сможет найти файл; поведение отлично от <function>require</function>, который выдаст 
  <link linkend="errorfunc.constants.errorlevels.e-error">фатальную ошибку</link>.
 </simpara>
 <simpara>
  Если путь указан — не важно, абсолютный (начинающийся с буквы диска или с 
  <literal>\</literal> в Windows или с <literal>/</literal> в Unix/Linux
  системах) или относительно текущей директории (начинающийся с
  <literal>.</literal> или <literal>..</literal>) — директива
  <link linkend="ini.include-path">include_path</link> будет проигнорирована в любом случае.
  К примеру, если начинается с <literal>../</literal>,
  парсер проверит родительскую директорию на наличие запрошенного файла.
 </simpara>
 <simpara>
  Для большей информации о том, как PHP обрабатывает включаемые файлы и включаемые пути,
  смотрите документацию для директивы <link linkend="ini.include-path">include_path</link>.
 </simpara>
 <simpara>
  Когда файл включается, его код наследует ту же 
  <link linkend="language.variables.scope">область видимости переменных</link>, что 
  и строка, на которой произошло включение.  Все переменные, доступные на этой строке 
  во включающем файле будут также доступны во включаемом файле.
  Однако все функции и классы, объявленные во включаемом файле, будут доступны 
  в глобальной области видимости.
 </simpara>
 <para>
  <example>
   <title>Простой пример <literal>include</literal></title>
   <programlisting role="php">
<![CDATA[
vars.php
<?php

$color = 'green';
$fruit = 'apple';

?>

test.php
<?php

echo "A $color $fruit"; // A

include 'vars.php';

echo "A $color $fruit"; // A green apple

?>
]]>
   </programlisting>
  </example>
 </para>
 <simpara>
  Если включение происходит внутри функции включающего файла,
  тогда весь код, содержащийся во включаемом файле, будет вести себя так,
  как будто он был определен внутри этой функции.  То есть, он будет в той же области видимости 
  переменных этой функции.
  Исключением к этому правилу являются <link
  linkend="language.constants.predefined">магические константы</link>, которые
  выполняются парсером перед тем, как происходит включение.
 </simpara>
 <para>
  <example>
   <title>Включение внутри функции</title>
   <programlisting role="php">
<![CDATA[
<?php

function foo()
{
    global $color;

    include 'vars.php';

    echo "A $color $fruit";
}

/* vars.php в той же области видимости, что и foo(),  *
* поэтому $fruit НЕ доступен снаружи этой области     *
* $color доступен, поскольку мы переменную глобальной */

foo();                    // A green apple
echo "A $color $fruit";   // A green

?>
]]>
   </programlisting>
  </example>
 </para>
 <simpara>
  Когда файл включается, парсинг в режиме PHP кода прекращается и переключается
  в режим HTML в начале указанного файла и продолжается
  снова в конце.  По этой причине любой код внутри включаемого файла,
  который должен быть выполнен как PHP код, должен быть заключен в 
  <link linkend="language.basic-syntax.phpmode">верные теги начала и конца PHP кода</link>.
 </simpara>
 <simpara>
  Если "<link linkend="ini.allow-url-include">обертки URL include</link>"
  включены в PHP, вы можете также указать файл для включения через URL (с помощью HTTP или
  других поддерживающихся обработчиков - смотри <xref linkend="wrappers"/> для списка 
  протоколов) вместо локального пути.  Если целевой сервер интерпретирует 
  указанный файл как PHP код, могут быть переданы переменные во включаемый файл
  с помощью строки URL-запроса, как если бы использовался метод HTTP GET. Это, 
  строго говоря, не тоже самое, что включение файла и наследование  
  родительской области видимости; скрипт 
  выполняется на удаленном сервере и результат выполнения
  включается в локальный скрипт.
 </simpara>
 &warn.no-win32-fopen-wrapper;
 <para>
  <example>
   <title>Пример <literal>include</literal> через HTTP</title>
   <programlisting role="php">
<![CDATA[
<?php

/* В этом примере предполагается, что www.example.com настроен на обработку .php
* файлов, но не .txt. Также, 'Works' обозначает, что переменные
* $foo и $bar доступны внутри включаемого файла. */

// Не сработает; file.txt не обрабатывается www.example.com как PHP
include 'http://www.example.com/file.txt?foo=1&bar=2';

// Не сработает; будет искаать файл 'file.php?foo=1&bar=2' в
// локальной файловой системе.
include 'file.php?foo=1&bar=2';

// Сработает.
include 'http://www.example.com/file.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'file.txt';  // Сработает.
include 'file.php';  // Сработает.

?>
]]>
   </programlisting>
  </example>
 </para>
 <warning>
  <title>Предупреждение безопасности</title>
  <para>
   Удаленные файлы могут быть обработаны на удаленной стороне (в зависимости от
   расширения файла и того, что удаленный сервер выполняет скрипты PHP или нет), но это все равно
   должно производить валидный PHP скрипт, потому что он будет затем обработан уже на 
   локальном сервере. Если файл с удаленного сервера должен быть обработан
   там и выведен его результат, предпочтительнее воспользоваться функцией <function>readfile</function> 
   В противном случае, должны быть предусмотрены дополнительные меры, чтобы обезопасить 
   удаленный скрипт от ошибок и нежелательного кода.
  </para>
 </warning>
 <para>
  Смотрите также раздел <link linkend="features.remote-files">Удаленные файлы</link>, функции
  <function>fopen</function> и <function>file</function> для дополнительной
  информации.
 </para>
 <simpara>
  Обработка возвращаемых значений: оператор <literal>include</literal> возвращает
  значение <literal>FALSE</literal> при ошибке и выдает предупреждение. Успешные
  включения, пока это не переопределено во включаемом файле, возвращают значение
  <literal>1</literal>. Возможно выполнить выражение <function>return</function>
  внутри включаемого файла, чтобы завершить процесс выполнения в
  этом файле и вернуться к выполнению включающего файла.  Также, возможно вернуть 
  значение из включаемых файлов. Вы можете получить значение включения как 
  если бы вы вызвали обычную функцию. Хотя это не возможно при включении 
  удаленного файла, только если вывод удаленного файла не содержит
  <link linkend= "language.basic-syntax.phpmode">правильные теги начала и конца PHP 
  кода</link> (так же, как и локальный файл). Вы можете определить необходимые 
  переменные внутри этих тегов и они будут представлены в том месте,
  где файл был включен.
 </simpara>
 <para>
  Так как <literal>include</literal> - это специальная языковая конструкция,
  круглые скобки не обязательны для заключения аргумента. Будьте осторожны при сравнении
  возвращаемого значения.
  <example>
   <title>Сравнение возвращаемого значения при include</title>
   <programlisting role="php">
<![CDATA[
<?php
// не сработает, интерпретируется как include(('vars.php') == 'OK'), т.е. include('')
if (include('vars.php') == 'OK') {
    echo 'OK';
}

// сработает
if ((include 'vars.php') == 'OK') {
    echo 'OK';
}
?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  <example>
   <title>Выражения <literal>include</literal> и <function>return</function></title>
   <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // выведет 'PHP'

$bar = include 'noreturn.php';

echo $bar; // выведет 1

?>
]]>
   </programlisting>
  </example>
 </para>
 <simpara>
  <literal>$bar</literal> имеет значение <literal>1</literal>, т.к. включение файла произошло
  успешно.  Заметьте разницу между примерами сверху. Первый использует
  <function>return</function> внутри включаемого файла, тогда как второй не использует.
  Если файл не может быть включен, возвращается &false; и возникает
  <constant>E_WARNING</constant>.
 </simpara>
 <para>
  Если во включаемом файле определены функции, они могут быть использованы в
  главном файле вне зависимости от того, были ли они объявлены до <function>return</function> или после.
  Если файл включается дважды, PHP 5 выдаст фатальную ошибку, потому что функции
  уже были определены, в то время как PHP 4 не обратил бы внимания на функции,
  определенные после <function>return</function>.
  Рекомендуется использовать <function>include_once</function> вместо того, чтобы 
  проверять был ли уже файл включен ранее.
 </para>
 <simpara>
  Другой путь "включить" PHP файл в переменную - это захватить 
  вывод используя <link linkend="ref.outcontrol">Функции контроля вывода</link>
  с <literal>include</literal>. К примеру:
 </simpara>
 <para>
  <example>
   <title>Использование буферизированного вывода для включения PHP файла в строку</title>
   <programlisting role="php">
<![CDATA[
<?php
$string = get_include_contents('somefile.php');

function get_include_contents($filename) {
    if (is_file($filename)) {
        ob_start();
        include $filename;
        return ob_get_clean();
    }
    return false;
}

?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  Для того, чтобы включать файлы автоматически в скрипты, обратите внимание на конфигурационные директивы
  <link linkend="ini.auto-prepend-file">auto_prepend_file</link> и
  <link linkend="ini.auto-append-file">auto_append_file</link>
  в &php.ini;.
 </para>

 &note.language-construct;

 <simpara>
  Смотрите также <function>require</function>, <function>require_once</function>,
  <function>include_once</function>, <function>get_included_files</function>,
  <function>readfile</function>, <function>virtual</function> и
  <link linkend="ini.include-path">include_path</link>.
 </simpara>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
