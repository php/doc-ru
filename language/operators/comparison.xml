<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 52407313885d27a4e891e08dd2e2481bcc39e244 Maintainer: sergey Status: ready -->
<!-- Reviewed: no -->
<sect1 xml:id="language.operators.comparison">
 <title>Операторы сравнения</title>
 <simpara>
  Операторы сравнения, как это видно из их названия, разрешают сравнивать между собой
  два значения. Возможно вам будет интересно также ознакомиться с разделом
  <link linkend="types.comparisons">Сравнение типов</link>, в котором приведено большое
  количество соответствующих примеров.
 </simpara>
 <table>
  <title>Операторы сравнения</title>
  <tgroup cols="3">
   <thead>
    <row>
     <entry>Пример</entry>
     <entry>Название</entry>
     <entry>Результат</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry>$a == $b</entry>
     <entry>Равно</entry>
     <entry>&true; если <varname>$a</varname> равно <varname>$b</varname>
    после преобразования типов.</entry>
    </row>
    <row>
     <entry>$a === $b</entry>
     <entry>Тождественно равно</entry>
     <entry>
    &true; если <varname>$a</varname> равно <varname>$b</varname> и имеет тот же тип.
   </entry>
    </row>
    <row>
     <entry>$a != $b</entry>
     <entry>Не равно</entry>
     <entry>&true; если <varname>$a</varname> не равно <varname>$b</varname>
    после преобразования типов.</entry>
    </row>
    <row>
     <entry>$a &lt;&gt; $b</entry>
     <entry>Не равно</entry>
     <entry>&true; если <varname>$a</varname> не равно <varname>$b</varname>
    после преобразования типов.</entry>
    </row>
    <row>
     <entry>$a !== $b</entry>
     <entry>Тождественно не равно</entry>
     <entry>
    &true; если <varname>$a</varname> не равно <varname>$b</varname>, или они разных типов.
   </entry>
    </row>
    <row>
     <entry>$a &lt; $b</entry>
     <entry>Меньше</entry>
     <entry>&true; если <varname>$a</varname> строго меньше <varname>$b</varname>.</entry>
    </row>
    <row>
     <entry>$a &gt; $b</entry>
     <entry>Больше</entry>
     <entry>&true; если <varname>$a</varname> строго больше <varname>$b</varname>.</entry>
    </row>
    <row>
     <entry>$a &lt;= $b</entry>
     <entry>Меньше или равно</entry>
     <entry>&true; если <varname>$a</varname> меньше или равно <varname>$b</varname>.</entry>
    </row>
    <row>
     <entry>$a &gt;= $b</entry>
     <entry>Больше или равно</entry>
     <entry>&true; если <varname>$a</varname> больше или равно <varname>$b</varname>.</entry>
    </row>
    <row>
     <entry>$a &lt;=&gt; $b</entry>
     <entry>Космический корабль (spaceship)</entry>
     <entry>
    Число типа <type>int</type> меньше, больше или равное нулю, когда
    <varname>$a</varname> соответственно меньше, больше или равно
    <varname>$b</varname>.
   </entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 <para>
  В случае, если оба операнда являются
  <link linkend="language.types.numeric-strings">строками, содержащими числа</link>
  или один операнд является числом, а другой  — <link linkend="language.types.numeric-strings">строкой, содержащей числа</link>,
  то сравнение выполняется численно.
  Эти правила также применяются к оператору <link linkend="control-structures.switch">switch</link>.
  Преобразование типа не происходит при сравнении
  <literal>===</literal> или <literal>!==</literal>, поскольку это включает сравнение
  типа, а также значения.
 </para>
 <warning>
  <para>
  До PHP 8.0.0, если строка (<type>string</type>) сравнивалась с числом
  или строкой, содержащей число, то строка (<type>string</type>) преобразовывалось
  в число перед выполнением сравнения. Это могло привести к неожиданным
  результатам, что можно увидеть на следующем примере:
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a");
var_dump("1" == "01");
var_dump("10" == "1e1");
var_dump(100 == "1e2");

switch ("a") {
case 0:
    echo "0";
    break;
case "a":
    echo "a";
    break;
}
?>
]]>
    </programlisting>
    &example.outputs.7;
    <screen>
<![CDATA[
bool(true)
bool(true)
bool(true)
bool(true)
0
]]>
    </screen>
    &example.outputs.8;
    <screen>
<![CDATA[
bool(false)
bool(true)
bool(true)
bool(true)
a
]]></screen>
   </informalexample>
  </para>
 </warning>
 <para>
  <informalexample>
   <programlisting role="php"><![CDATA[
<?php
// Целые числа
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1

// Числа с плавающей точкой
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1

// Строки
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1
echo "a" <=> "aa"; // -1
echo "zz" <=> "aa"; // 1

// Массивы
echo [] <=> []; // 0
echo [1, 2, 3] <=> [1, 2, 3]; // 0
echo [1, 2, 3] <=> []; // 1
echo [1, 2, 3] <=> [1, 2, 1]; // 1
echo [1, 2, 3] <=> [1, 2, 4]; // -1

// Объекты
$a = (object) ["a" => "b"];
$b = (object) ["a" => "b"];
echo $a <=> $b; // 0
$a = (object) ["a" => "b"];
$b = (object) ["a" => "c"];
echo $a <=> $b; // -1
$a = (object) ["a" => "c"];
$b = (object) ["a" => "b"];
echo $a <=> $b; // 1

// сравниваются не только значения; ключи также должны совпадать
$a = (object) ["a" => "b"];
$b = (object) ["b" => "b"];
echo $a <=> $b; // 1
?>
]]>

   </programlisting>
  </informalexample>
 </para>
 <para>
  Для различных типов сравнение происходит в соответствии со следующей
  таблицей (по порядку).
 </para>
 <table xml:id="language.operators.comparison.types">
  <title>Сравнение различных типов</title>
  <tgroup cols="3">
   <thead>
    <row>
     <entry>Тип операнда 1</entry>
     <entry>Тип операнда 2</entry>
     <entry>Результат</entry>
    </row>
   </thead>
   <tbody>
    <row>
     <entry>
      <type>null</type> или <type>string</type>
     </entry>
     <entry>
      <type>string</type>
     </entry>
     <entry>&null; преобразуется в "", числовое или лексическое сравнение</entry>
    </row>
    <row>
     <entry>
      <type>bool</type> или <type>null</type>
     </entry>
     <entry>что угодно</entry>
     <entry>Преобразуется в тип <type>bool</type>, &false; &lt; &true;</entry>
    </row>
    <row>
     <entry>
      <type>object</type>
     </entry>
     <entry>
      <type>object</type>
     </entry>
     <entry>Встроенные классы могут определять свои собственные правила сравнения,
    объекты разных классов не сравниваются, про сравнение объектов одного класса смотрите <link linkend="language.oop5.object-comparison">Сравнение объекта</link>
     </entry>
    </row>
    <row>
     <entry>
      <type>string</type>, <type>resource</type>, <type>int</type> или <type>float</type>
     </entry>
     <entry>
      <type>string</type>, <type>resource</type>, <type>int</type> или <type>float</type>
     </entry>
     <entry>Строки и ресурсы переводятся в числа, обычная математика</entry>
    </row>
    <row>
     <entry>
      <type>array</type>
     </entry>
     <entry>
      <type>array</type>
     </entry>
     <entry>Массивы с меньшим числом элементов считаются меньше,
    если ключ из первого операнда не найден во втором операнде —
    массивы не могут сравниваться, иначе идёт сравнение соответствующих
    значений (смотрите пример ниже)</entry>
    </row>
    <row>
     <entry>
      <type>array</type>
     </entry>
     <entry>что угодно</entry>
     <entry>тип <type>array</type> всегда больше</entry>
    </row>
    <row>
     <entry>
      <type>object</type>
     </entry>
     <entry>что угодно</entry>
     <entry>тип <type>object</type> всегда больше</entry>
    </row>
   </tbody>
  </tgroup>
 </table>
 <para>
  <example>
   <title>Сравнение boolean/null</title>
   <programlisting role="php">
<![CDATA[
<?php
// Логические значения и null всегда сравниваются как логические
var_dump(1 == TRUE); // TRUE  — то же, что и (bool)1 == TRUE
var_dump(0 == FALSE); // TRUE  — то же, что и (bool)0 == FALSE
var_dump(100 < TRUE); // FALSE  — то же, что и (bool)100 < TRUE
var_dump(-10 < FALSE);// FALSE  — то же, что и (bool)-10 < FALSE
var_dump(min(-100, -10, NULL, 10, 100)); // NULL  — (bool)NULL < (bool)-100 это FALSE < TRUE
?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  <example>
   <title>Алгоритм сравнения обычных массивов</title>
   <programlisting role="php">
<![CDATA[
<?php
// Массивы сравниваются таким образом с помощью стандартных операторов сравнения, а также оператора spaceship.
function standard_array_compare($op1, $op2)
{
  if (count($op1) < count($op2)) {
    return -1; // $op1 < $op2
  } elseif (count($op1) > count($op2)) {
    return 1; // $op1 > $op2
  }
  foreach ($op1 as $key => $val) {
    if (!array_key_exists($key, $op2)) {
      return 1;
    } elseif ($val < $op2[$key]) {
      return -1;
    } elseif ($val > $op2[$key]) {
      return 1;
    }
  }
  return 0; // $op1 == $op2
}
?>
]]>
   </programlisting>
  </example>
 </para>

 <warning>
  <title>Сравнение чисел с плавающей точкой</title>
  <para>
  Из-за особого внутреннего представления типа <type>float</type>, не нужно
  проверять на равенство два числа с плавающей точкой (<type>float</type>).
  </para>
  <para>
  Для более подробной информации смотрите документацию по типу <type>float</type>.
  </para>
 </warning>

 <note>
  <simpara>
  Помните, что жонглирование типами в PHP не всегда очевидно при сравнении значений разных типов,
  особенно при сравнении целых чисел (&integer;) с логическими значениями (&boolean;)
  или целых чисел (&integer;) со строками (&string;).
  Поэтому в большинстве случаев рекомендуется использовать сравнения <literal>===</literal> и <literal>!==</literal>,
  а не <literal>==</literal> и <literal>!=</literal>.
  </simpara>
 </note>
 <sect2 xml:id="language.operators.comparison.incomparable">
  <title>Несравнимые значение</title>
  <simpara>
  В то время как сравнение тождества (<literal>===</literal> и <literal>!==</literal>)
  можно применять к произвольным значениям, другие операторы сравнения следует применять только к сравнимым значениям.
  Результат сравнения несравнимых значений не определён и на него не следует полагаться.
  </simpara>
 </sect2>
 <sect2 role="seealso">
  &reftitle.seealso;
  <para><simplelist><member><function>strcasecmp</function>
    </member>
    <member>
     <function>strcmp</function>
    </member>
    <member>
     <link linkend="language.operators.array">Операторы, работающие с массивами</link>
    </member>
    <member>
     <link linkend="language.types">Типы</link>
    </member>
   </simplelist>
  </para>
 </sect2>
 <sect2 xml:id="language.operators.comparison.ternary">
  <title>Тернарный оператор</title>
  <para>
  Ещё одним условным оператором является тернарный оператор "?:".
  <example><title>Присваивание значения по умолчанию</title>
    <programlisting role="php">
<![CDATA[
<?php
// Пример использования тернарного оператора
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];
// Приведённый выше код аналогичен следующему блоку с использованием if/else
if (empty($_POST['action'])) {
  $action = 'default';
} else {
  $action = $_POST['action'];
}
?>
]]>
    </programlisting>
   </example>
  Выражение <literal>(expr1) ? (expr2) : (expr3)</literal>
  интерпретируется как <replaceable>expr2</replaceable>, если
  <replaceable>expr1</replaceable> имеет значение &true;, или как
  <replaceable>expr3</replaceable>, если
  <replaceable>expr1</replaceable> имеет значение &false;.
  </para>
  <para>
  Также стало возможным не писать среднюю часть
  тернарного оператора. Выражение <literal>expr1 ?: expr3</literal> оценивается
  как результат <replaceable>expr1</replaceable>, если результат выражения <replaceable>expr1</replaceable> оценивается как &true;
  и <replaceable>expr3</replaceable> в противном случае.
  Выражение <replaceable>expr1</replaceable> в этом случае оценивается только один раз.
  </para>
  <note>
   <simpara>
   Обратите внимание, что тернарный оператор является выражением
   и трактуется не как переменная, а как результат выражения. Это важно знать,
   если вы хотите вернуть переменную по ссылке.
   Выражение <literal>return $var == 42 ? $a : $b;</literal> не будет
   работать в функции, возвращающей значение по ссылке, а в более поздних
   версиях PHP также будет выдано предупреждение.
  </simpara>
  </note>
  <note>
   <para>
   Рекомендовано избегать «нагромождения» тернарных выражений.
   Поведение PHP при указании более чем одного тернарного оператора без скобок
   в одном выражении неочевидно по сравнению с другими языками.
   Действительно, до PHP 8.0.0 троичные выражения оценивались лево-ассоциативными,
   а не право-ассоциативными, как в большинстве других языков программирования.
   Опора на левую ассоциативность устарела начиная с PHP 7.4.0.
   Начиная с PHP 8.0.0 тернарный оператор неассоциативен.
   <example><title>Неочевидное поведение тернарного оператора</title>
     <programlisting role="php">
<![CDATA[
<?php
// на первый взгляд, следующий код должен вывести 'true'
echo (true ? 'true' : false ? 't' : 'f');

// однако он выводит 't' до PHP 8.0.0
// это потому, что тернарные выражения левоассоциативны

// это намного более очевидная версия вышеприведённого кода
echo ((true ? 'true' : false) ? 't' : 'f');

// здесь видно, что первое выражение вычисляется в 'true', которое
// в свою очередь вычисляется в (bool)true, таким образом возвращая истинную ветвь
// второго тернарного выражения.
?>
]]>
     </programlisting>
    </example>
   </para>
  </note>
  <note>
   <para>
   Цепочка коротких тернарных операторов (<literal>?:</literal>) стабильна и ведёт себя разумно.
   Она будет оценивать первый аргумент, который оценивается как не ложное значение.
   Обратите внимание, что неопределённые значения все равно вызовут предупреждение.
   <example><title>Цепочка коротких тернарных операторов</title>
     <programlisting role="php">
<![CDATA[
<?php
echo 0 ?: 1 ?: 2 ?: 3, PHP_EOL; // 1
echo 0 ?: 0 ?: 2 ?: 3, PHP_EOL; // 2
echo 0 ?: 0 ?: 0 ?: 3, PHP_EOL; // 3
?>
]]>
     </programlisting>
    </example>
   </para>
  </note>
 </sect2>
 <sect2 xml:id="language.operators.comparison.coalesce">
  <title>Оператор объединения с null</title>
  <para>
  Другой полезный сокращённый оператор — оператор "??" (null coalescing).
  <example><title>Присваивание значения по умолчанию</title>
    <programlisting role="php">
<![CDATA[
<?php
// Пример работы с оператором нулевого слияния
$action = $_POST['action'] ?? 'default';

// Пример выше аналогичен этому выражению с if/else
if (isset($_POST['action'])) {
  $action = $_POST['action'];
} else {
  $action = 'default';
}
?>
]]>
    </programlisting>
   </example>
  Выражение <literal>(expr1) ?? (expr2)</literal> вычисляется так:
  <replaceable>expr2</replaceable>, если <replaceable>expr1</replaceable> равен
  &null; и <replaceable>expr1</replaceable> в противном случае.
  </para>
  <para>
  На практике, этот оператор не вызывает предупреждения или ошибки, если левый операнд не
  существует, как и <function>isset</function>. Это очень полезно для ключей массива.
  </para>
  <note>
   <simpara>
   Пожалуйста помните, что этот оператор является выражением, и он приравнивается к
   выражению, а не значению переменной. Это может быть важным, если вы хотите
   вернуть значение по ссылке. Выражение <literal>return $foo ?? $bar;</literal> в
   функции возвращающей ссылку будет не работать, а выводить предупреждение.
  </simpara>
  </note>
  <note>
   <para>
   У оператора null coalescing низкий приоритет. Это означает, что при смешивании его с другими операторами
   (такими как конкатенация строк или арифметические операторы), скорее всего, потребуются круглые скобки.
  </para>
   <programlisting role="php">
<![CDATA[
<?php
// Вызывает предупреждение о том, что $name не определено.
print 'Mr. ' . $name ?? 'Anonymous';
// Выведет "Mr. Anonymous"
print 'Mr. ' . ($name ?? 'Anonymous');
?>
]]>
   </programlisting>
  </note>
  <note>
   <para>
   Обратите внимание, что этот оператор позволяет использовать простую вложенность:
   <example><title>Вложенный оператор null coalescing</title>
     <programlisting role="php">
<![CDATA[
<?php
$foo = null;
$bar = null;
$baz = 1;
$qux = 2;
echo $foo ?? $bar ?? $baz ?? $qux; // выведет 1
?>
]]>
     </programlisting>
    </example>
   </para>
  </note>
 </sect2>
</sect1>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
