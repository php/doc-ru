<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 52407313885d27a4e891e08dd2e2481bcc39e244 Maintainer: sergey Status: ready -->
<!-- Reviewed: no -->
<sect1 xml:id="language.operators.errorcontrol">
 <title>Оператор управления ошибками</title>
 <simpara>
  PHP поддерживает один оператор управления ошибками: знак <literal>@</literal>.
  В случае если он предшествует какому-либо выражению в PHP-коде, любые
  сообщения об ошибках, генерируемые этим выражением, будут подавлены.
 </simpara>
 <para>
  Если пользовательская функция обработчика ошибок установлена с помощью
  <function>set_error_handler</function>, она всё равно будет вызываться,
  даже если диагностика была подавлена.
 </para>
 <warning>
  <para>
  До версии PHP 8.0.0 функция <function>error_reporting</function>, вызываемая внутри пользовательского обработчика ошибок,
  всегда возвращала <literal>0</literal>, если ошибка была подавлена оператором <literal>@</literal>.
  Начиная с PHP 8.0.0, она возвращает значение <literal>E_ERROR | E_CORE_ERROR | E_COMPILE_ERROR | E_USER_ERROR | E_RECOVERABLE_ERROR | E_PARSE</literal>.
  </para>
 </warning>
 <simpara>
  Любое сообщение об ошибке, сгенерированное выражением, доступно
  в элементе массива <literal>"message"</literal>, возвращаемого <function>error_get_last</function>.
  Результат этой функции будет меняться при каждой ошибке, поэтому его необходимо проверить заранее.
 </simpara>
 <para>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
/* Преднамеренная ошибка при работе с файлами */
$my_file = @file ('non_existent_file') or
    die ("Ошибка при открытии файла: сообщение об ошибке было таким: '" . error_get_last()['message'] . "'");

// работает для любых выражений, а не только для функций
$value = @$cache[$key];
// В случае если ключа $key нет, сообщение об ошибке (notice) не будет отображено

?>
]]>
   </programlisting>
  </informalexample>
 </para>
 <note>
  <simpara>
  Оператор <literal>@</literal> работает только с
  <link linkend="language.expressions">выражениями</link>.
  Есть простое правило: если что-то возвращает
  значение, значит вы можете использовать перед ним оператор
  <literal>@</literal>. Например, вы можете использовать <literal>@</literal> перед
  именем переменной, произвольной функцией или вызовом <function>include</function> и так далее. В то же время вы не можете использовать этот оператор
  перед определением функции или класса, условными конструкциями, такими как <literal>if</literal>,
  &foreach; и т. д.
  </simpara>
 </note>
 <warning>
  <para>
  До PHP 8.0.0 оператор <literal>@</literal> мог подавлять критические ошибки, которые прерывали выполнение скрипта.
  Например, добавление <literal>@</literal> к вызову несуществующей функции,
  в случае, если она недоступна или написана неправильно, дальнейшая
  работа скрипта приведёт к прерыванию выполнения скрипта без каких-либо уведомлений.
  </para>
 </warning>
 <sect2 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><function>error_reporting</function></member>
    <member><link linkend="ref.errorfunc">Обработка ошибок и функции логирования</link></member>
   </simplelist>
  </para>
 </sect2>
</sect1>
