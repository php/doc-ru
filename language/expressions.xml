<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 4decb44c7141a97e348a1235bbb20d930d2baac0 Maintainer: shein Status: ready -->
<!-- Reviewed: no -->
<chapter xml:id="language.expressions" xmlns="http://docbook.org/ns/docbook">
 <title>Выражения</title>
 <simpara>
  Выражения — это самые важные строительные элементы PHP. Почти всё, что вы пишете
  в PHP, является выражением. Самое простое и точное определение
  выражения — «все что угодно, имеющее значение».
 </simpara>
 <simpara>
  Основными формами выражений являются константы и переменные. Если
  вы записываете <code>$a = 5</code>, вы присваиваете <code>5</code> переменной
  <varname>$a</varname>. <code>5</code>, очевидно, имеет значение 5 или, другими словами,
  <code>5</code> — это выражение со значением 5 (в данном случае <code>5</code> — это целочисленная
  константа).
 </simpara>
 <simpara>
  После этого присвоения вы ожидаете, что значением <varname>$a</varname>
  также является 5, поэтому, если вы написали <code>$b = $a</code>,
  вы полагаете, что работать это будет так же, как
  если бы вы написали <code>$b = 5</code>. Другими словами,
  <varname>$a</varname> это также выражение со значением 5. Если всё работает
  верно, то именно так и произойдёт.
 </simpara>
 <para>
  Немного более сложными примерами выражений являются функции. Например,
  рассмотрим следующую функцию:
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
function foo ()
{
    return 5;
}
?>
]]>
     </programlisting>
    </informalexample>
  </para>
  <simpara>
   Исходя из того, что вы хорошо знакомы с концепцией функций (если нет,
   то прочитайте главу о <link linkend="language.functions">функциях</link>), вы
   полагаете, что запись <code>$c = foo()</code> абсолютно
   эквивалентна записи <code>$c = 5</code>, и вы правы. Функции -
   это выражения, значением которых является то, что возвращает функция.
   Поскольку <code>foo()</code> возвращает 5, значением выражения
   '<code>foo()</code>' является 5.
   Как правило, функции возвращают не просто статическое значение, а
   что-то вычисляют.
  </simpara>
  <simpara>
   Разумеется, значения в PHP не обязаны быть целочисленными, и очень
   часто ими не являются. PHP поддерживает четыре типа скалярных значений:
   целочисленные (<type>int</type>), с плавающей точкой (<type>float</type>),
   строковые значения (<type>string</type>) и булевы (<type>bool</type>)
   значения (скалярными являются значения, которые вы не можете 'разбить' на
   меньшие части, в отличие, например, от массивов). PHP поддерживает также два
   комбинированных (не скалярных) типа: массивы и объекты. Любое значение такого
   типа может присваиваться переменной или возвращаться функцией.
  </simpara>
  <simpara>
   Однако PHP, как и многие другие языки, понимает гораздо больше выражений.
   PHP — это язык, ориентированный на выражения и рассматривающий почти все как
   выражение. Вернёмся к примеру, с которым мы уже имели дело:
   <code>$a = 5</code>. Легко заметить, что здесь присутствуют два значения —
   значение целочисленной константы <code>5</code> и значение переменной <varname>$a</varname>,
   также принимающей значение 5. Но на самом деле здесь присутствует и ещё одно
   значение — значение самого присвоения. Само присвоение вычисляется в
   присвоенное значение, в данном случае — в 5. На практике это означает, что
   <code>$a = 5</code>, независимо от того, что оно делает, является
   выражением со значением 5. Таким образом, запись <code>$b = ($a = 5)</code>
   равносильна записи <code>$a = 5; $b = 5;</code> (точка с запятой обозначает конец выражения).
   Поскольку операции присвоения анализируются справа налево, вы также
   можете написать <code>$b = $a = 5</code>.
  </simpara>
  <simpara>
   Другой хороший пример ориентированности на выражения — префиксный и
   постфиксный инкремент и декремент. Пользователи PHP и многих
   других языков возможно уже знакомы с формой записи <code>variable++</code>
   и <code>variable--</code>. Это <link linkend="language.operators.increment">
   операторы инкремента и декремента</link>. Также как и C, PHP
   поддерживает два типа инкремента — префиксный и постфиксный. Они
   оба инкрементируют значение переменной и эффект их действия на неё
   одинаков. Разница состоит в значении выражения инкремента.
   Префиксный инкремент, записываемый как <code>++$variable</code>,
   вычисляется в инкрементированное значение (PHP инкрементирует переменную до того
   как прочесть её значение, отсюда название 'пре-инкремент').
   Постфиксный инкремент, записываемый как <code>$variable++</code>,
   вычисляется в первоначальное значение переменной <varname>$variable</varname> до её приращения
   (PHP инкрементирует переменную после прочтения её значения, отсюда
   название 'пост-инкремент').
  </simpara>
  <simpara>
   Очень распространённым типом выражений являются выражения  <link
   linkend="language.operators.comparison">сравнения</link>.
   Результатом вычислений являются &false; (ложь)
   или &true; (истина). PHP поддерживает операции сравнения &gt; (больше), &gt;= (больше
   либо равно), == (равно), != (не равно), &lt; (меньше) и &lt;=
   (меньше либо равно). Он также поддерживает операторы строгого
   равенства: === (равно и одного типа) и !== (не равно или не одного
   типа). Чаще всего эти выражения используются в операторах условного выполнения,
   таких как <code>if</code>.
  </simpara>
  <simpara>
   Последний пример выражений, который мы здесь рассмотрим, это
   смешанные выражения операции и присвоения. Вы уже знаете, что если
   вы хотите увеличить <varname>$a</varname> на 1, вы можете просто написать
   <code>$a++</code> или <code>++$a</code>. Но что, если вы
   хотите прибавить больше, чем единицу, например, 3? Вы могли бы написать
   <code>$a++</code> много раз, однако, очевидно это не очень
   рациональный и удобный способ. Гораздо более распространённой практикой
   является запись вида <code>$a = $a + 3</code>.
   <code>$a + 3</code> вычисляется в значение <varname>$a</varname> плюс
   3 и снова присваивается <varname>$a</varname>, увеличивая в результате
   <varname>$a</varname> на 3. В PHP, как и в некоторых других языках, таких как C,
   вы можете записать это более коротким образом, что увеличит очевидность смысла
   и быстроту понимания кода по прошествии времени. Прибавить 3 к текущему значению
   <varname>$a</varname> можно с помощью записи <code>$a += 3</code>.
   Это означает дословно "взять значение <varname>$a</varname>, прибавить к
   нему 3 и снова присвоить его переменной <varname>$a</varname>". Кроме
   большей понятности и краткости, это быстрее работает. Значением
   <code>$a += 3</code>, как и обычного присвоения, является присвоенное
   значение. Обратите внимание, что это НЕ 3, а суммированное значение
   <varname>$a</varname> плюс 3 (то, что было присвоено <varname>$a</varname>).
   Таким образом может использоваться любой бинарный оператор, например,
   <code>$a -= 5</code> (вычесть 5 из значения <varname>$a</varname>),
   <code>$b *= 7</code> (умножить значение <varname>$b</varname> на 7)
   и т.д.
  </simpara>
  <para>
   Существует ещё одно выражение, которое может выглядеть необычно,
   если вы не встречали его в других языках — тернарный условный
   оператор:
  </para>
  <para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$first ? $second : $third
?>
]]>
     </programlisting>
    </informalexample>
  </para>
  <para>
   Если значением первого подвыражения является &true; (не ноль),
   то выполняется второе подвыражение, которое и будет результатом
   условного выражения. В противном случае будет выполнено третье
   подвыражение и его значение будет результатом.
  </para>
  <para>
   Следующий пример должен помочь вам немного улучшить понимание
   префиксного и постфиксного инкремента и выражений:
  </para>
  <para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function double($i)
{
    return $i*2;
}
$b = $a = 5;        /* присвоить значение пять переменным $a и $b */
$c = $a++;          /* постфиксный инкремент, присвоить значение $a
                       (5) переменной $c */
$e = $d = ++$b;     /* префиксный инкремент, присвоить увеличенное
                       значение $b (6) переменным $d и $e */

/* в этой точке и $d, и $e равны 6 */

$f = double($d++);  /* присвоить удвоенное значение $d перед
                       инкрементом (2*6 = 12) переменной $f */
$g = double(++$e);  /* присвоить удвоенное значение $e после
                       инкремента (2*7 = 14) переменной $g */
$h = $g += 10;      /* сначала переменная $g увеличивается на 10,
                       приобретая, в итоге, значение 24. Затем значение
                       присвоения (24) присваивается переменной $h,
                       которая в итоге также становится равной 24. */
?>
]]>
     </programlisting>
    </informalexample>
  </para>
  <simpara>
   Некоторые выражения могут рассматриваться как инструкции. В
   данном случае инструкция имеет вид '<code>expr ;</code>' — выражение с
   последующей точкой с запятой. В записи <code>$b = $a = 5;</code>,
   <code>$a = 5</code> — это верное выражение, но само по себе не инструкция.
   Тогда как <code>$b = $a = 5;</code> является верной инструкцией.
  </simpara>
  <simpara>
   Последнее, что стоит упомянуть, это истинность значения выражений.
   Во многих случаях, как правило, в условных операторах и циклах,
   вас может интересовать не конкретное значение выражения, а только
   его истинность (значение &true; или &false;).

   <!-- (PHP doesn't have a
    dedicated boolean type) : WRONG, PHP does. -->

    Константы &true; и &false; (регистронезависимые) — это два
    возможных булевых значения. Выражения можно
    автоматически преобразовать в логическое значение. Подробнее о том, как это
    сделать, рассказано в <link linkend="language.types.typecasting">разделе о
    приведении типов</link>.
  </simpara>
  <simpara>
   PHP предоставляет полную и мощную реализацию выражений, и их
   полное документирование выходит за рамки этого руководства.
   Примеры выше дают представление о выражениях, о том, что
   они из себя представляют, и как можно создавать полезные
   выражения. Для обозначения любого верного выражения PHP в
   этой документации будет использовано сокращение <varname>expr</varname>.
  </simpara>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
