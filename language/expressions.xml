<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: f4f96ef8b2a95283c92ea2183fe1dedf06f3ad22 Maintainer: shein Status: ready -->
<!-- Reviewed: no -->
<chapter xml:id="language.expressions" xmlns="http://docbook.org/ns/docbook">
 <title>Выражения</title>
 <simpara>
  Выражения — самые важные строительные элементы PHP. Почти всё, что разработчик пишет
  в PHP, — выражение. Самое простое и точное определение
  выражения — «всё, что вычисляется как значение».
 </simpara>
 <simpara>
  Главные формы выражений — константы и переменные. В записи
  <code>$a = 5</code> значение <code>5</code> присвоится переменной
  <varname>$a</varname>. Значение <code>5</code>, очевидно, содержит значение 5 или, говоря по-другому,
  <code>5</code> — выражение со значением 5; в этом случае <code>5</code> — целочисленная
  константа.
 </simpara>
 <simpara>
  После этого присваивания ожидается, что значение переменной <varname>$a</varname>
  тоже равно 5, поэтому, когда записывают <code>$b = $a</code>,
  ожидают, что это сработает так же,
  как если бы написали <code>$b = 5</code>. Говоря по-другому,
  переменная <varname>$a</varname> — тоже выражение со значением 5. Всё так и произойдёт,
  если всё работает правильно.
 </simpara>
 <para>
  Немного более сложные примеры выражений — функции. Например,
  рассмотрим следующую функцию:
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php

function foo ()
{
    return 5;
}
?>
]]>
     </programlisting>
    </informalexample>
  </para>
  <simpara>
   Разработчик, который познакомился с концепцией функций
   в главе «<link linkend="language.functions">О функциях</link>»,
   мог бы предположить, что присваивание <code>$c = foo()</code>
   по смыслу аналогично присваиванию <code>$c = 5</code>, и оказался бы прав.
   Функция — выражение, значение которого равно тому, что возвращает функция.
   Значение выражения <code>foo()</code> равно 5,
   поскольку функция <code>foo()</code> возвращает 5.
   Часто функции не просто возвращают статическое значение,
   а что-то вычисляют.
  </simpara>
  <simpara>
   Конечно, значения в PHP не обязаны быть целочисленными,
   и часто это не так. Язык PHP поддерживает четыре типа скалярных значений:
   целочисленные <type>int</type>, значения с плавающей точкой <type>float</type>,
   строковые <type>string</type> и логические <type>bool</type>.
   Скалярными называются значения, которые нельзя «разбить»
   на меньшие части, в отличие, например, от массивов. Ещё PHP поддерживает два
   сложных (составных, композитных — нескалярных) типа: массивы и объекты. Каждый из этих
   типов значений возможно присвоить переменной или вернуть из функции.
  </simpara>
  <simpara>
   Однако PHP использует выражения значительно шире, точно так же, как это делают другие языки.
   PHP — язык с ориентацией на выражения, который почти всё в коде рассматривает
   как выражение. Вернёмся к тому примеру, с которым уже имели дело:
   <code>$a = 5</code>. Легко заметить, что здесь содержится два значения —
   значение целочисленной константы <code>5</code> и значение переменной <varname>$a</varname>,
   которая также принимает значение 5. Но, хотя это неочевидно, здесь содержится ещё одно
   значение — значение самого присваивания. Само присваивание вычисляется
   в значение, которое присваивется переменной, в приведённом примере — в значение 5. Поэтому
   выражение <code>$a = 5</code> независимо от того, что оно делает, —
   это выражение со значением 5. Поэтому запись <code>$b = ($a = 5)</code>
   равносильна записи <code>$a = 5; $b = 5;</code> (точка с запятой означает конец инструкции).
   Разработчику также доступна запись <code>$b = $a = 5</code>,
   поскольку операции присваивания анализируются справа налево.
  </simpara>
  <simpara>
   Другой хороший пример ориентированности на выражения — префиксный
   и постфиксный инкремент и декремент. Пользователи PHP
   и других языков, возможно, уже знакомы с формой записи <code>variable++</code>
   и <code>variable--</code>. Это <link linkend="language.operators.increment">
   операторы инкремента и декремента</link>. Как и язык Си, язык PHP
   поддерживает два типа инкремента — префиксный и постфиксный. Они
   оба инкрементируют значение переменной и эффект их действия на неё
   одинаков. Разница состоит в значении выражения инкремента.
   Префиксный инкремент, записываемый как <code>++$variable</code>,
   вычисляется в инкрементированное значение (PHP инкрементирует переменную до того
   как прочесть её значение, отсюда название «преинкремент»).
   Постфиксный инкремент, записываемый как <code>$variable++</code>,
   вычисляется в первоначальное значение переменной <varname>$variable</varname> до её приращения
   (PHP вначале читает значение переменной и только потом инкрементирует её, отсюда
   название «постинкремент»).
  </simpara>
  <simpara>
   Распространённые типы выражений — выражения <link
   linkend="language.operators.comparison">сравнения</link>.
   Эти выражения вычисляются либо как &false; (ложь),
   либо как &true; (истина). PHP поддерживает операции сравнения &gt; (больше), &gt;= (больше
   либо равно), == (равно), != (не равно), &lt; (меньше) и &lt;=
   (меньше либо равно). Он также поддерживает операторы строгого
   равенства: === (равно и одного типа) и !== (не равно или не одного
   типа). Обычно этими выражениями пользуются в операторах условного выполнения,
   например, инструкции <code>if</code>.
  </simpara>
  <simpara>
   Последний пример выражений, который здесь рассматривается,
   это смешанные выражения операции и присваивания. Уже известно, что когда
   требуется увеличить значение переменной <varname>$a</varname> на 1, записывают
   <code>$a++</code> или <code>++$a</code>. Но что, если потребуется
   прибавить больше единицы, например 3? Можно было бы написать
   <code>$a++</code> много раз, однако, очевидно, это нерационально и неудобно.
   Наиболее распространённая практика — запись вида <code>$a = $a + 3</code>.
   Выражение <code>$a + 3</code> вычисляется в значение переменной <varname>$a</varname>, к которому
   прибавляется 3 и снова присваивается значение переменной <varname>$a</varname>, увеличивая в результате
   значение переменной <varname>$a</varname> на 3. В PHP, как и в ряде других языков, например Си,
   это же присваивание записывается короче, что увеличит очевидность смысла
   и скорость понимания кода по прошествии времени. Тройку к текущему значению
   переменной <varname>$a</varname> прибавляют так: <code>$a += 3</code>.
   Это означает дословно «взять значение переменной <varname>$a</varname>, прибавить
   к нему значение 3 и снова присвоить результат сложения переменной <varname>$a</varname>». Кроме
   большей понятности и краткости, это быстрее работает. Значением
   выражения <code>$a += 3</code>, как и стандартного присваивания, станет
   значение, которое присвоилось переменной. Обратите внимание, что это НЕ 3, а суммированное значение
   переменной <varname>$a</varname> плюс 3 (то, что присвоилось перменной <varname>$a</varname>).
   Поэтому разрешается использовать любой бинарный оператор, например,
   <code>$a -= 5</code> (вычесть 5 из значения переменной <varname>$a</varname>),
   <code>$b *= 7</code> (умножить значение переменной <varname>$b</varname> на 7)
   и т. д.
  </simpara>
  <para>
   Ещё одно выражение, которое выглядит необычно,
   если читатель не встречал такое выражение в других языках, — тернарный условный
   оператор:
  </para>
  <para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php

$first ? $second : $third

?>
]]>
     </programlisting>
    </informalexample>
  </para>
  <para>
   Если значение первого подвыражения — &true; (ненулевое значение),
   то выполняется второе подвыражение, которое и будет результатом
   условного выражения. Или выполняется третье
   подвыражение и его значение будет результатом.
  </para>
  <para>
   Задача следующего примера — помочь немного улучшить понимание
   префиксного и постфиксного инкремента и выражений:
  </para>
  <para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php

function double($i)
{
    return $i*2;
}

$b = $a = 5;        /* Присвоить значение пять переменным $a и $b */
$c = $a++;          /* Постфиксный инкремент, присвоить значение переменной
                       $a (5) — переменной $c */
$e = $d = ++$b;     /* Префиксный инкремент, присвоить увеличенное
                       значение переменной $b (6) — переменным $d и $e */

/* в этой точке и переменная $d, и переменная $e равны 6 */

$f = double($d++);  /* Присвоить удвоенное значение перменной $d перед
                       инкрементом (2 * 6 = 12) — переменной $f */
$g = double(++$e);  /* Присвоить удвоенное значение перменной $e после
                       инкремента (2 * 7 = 14) — переменной $g */
$h = $g += 10;      /* Сначала переменная $g увеличивается на 10,
                       приобретая, в итоге, значение 24. Затем значение
                       присваивания (24) присваивается переменной $h,
                       которая в итоге также становится равной 24. */
?>
]]>
     </programlisting>
    </informalexample>
  </para>
  <simpara>
   Иногда PHP рассматривает выражения как инструкции.
   В этом случае у инструкции следующий вид — «<code>expr ;</code>», то есть выражение,
   за которым следует точка с запятой. В записи <code>$b = $a = 5;</code>,
   часть <code>$a = 5</code> — допустимое выражение, но оно само — не инструкция.
   Тогда как запись <code>$b = $a = 5;</code> — допустимая инструкция.
  </simpara>
  <simpara>
   Последнее, что вспомним, — истинность значения выражений.
   Обычно в условных операторах и циклах
   может интересовать не конкретное значение выражения, а только
   его истинность (значение &true; или &false;).

   <!-- (PHP doesn't have a
    dedicated boolean type) : WRONG, PHP does. -->

   Регистронезависимые константы &true; и &false; — два
   возможных логических значения. Выражения автоматически преобразовываются
   в логические значения, когда требуется. Подробнее о преобразовании типов рассказывает раздел
   <link linkend="language.types.typecasting">Приведение типов</link>.
  </simpara>
  <simpara>
   Язык PHP со всей полнотой и мощностью реализует выражения,
   а полное документирование выражений выходит за рамки руководства.
   Приведённые примеры дают представление о выражениях, о том, что
   они из себя представляют, и как создавать полезные
   выражения. В остальной части руководства
   допустимые PHP-выражения обозначают сокращением <varname>expr</varname>.
  </simpara>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
