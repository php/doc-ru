<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 5dba865d911a1d0aed3160abbb19be77fff560ca Maintainer: shein Status: ready -->
<!-- Reviewed: yes -->
<!-- $Revision$ -->
<chapter xml:id="language.expressions" xmlns="http://docbook.org/ns/docbook">
 <title>Выражения</title>
 <simpara>
  Выражения - это самые важные строительные элементы PHP. Почти все, что вы пишете
  в PHP, является выражением. Самое простое и точное определение
  выражения - "все что угодно, имеющее значение".
 </simpara>
 <simpara>
  Основными формами выражений являются константы и переменные. Если
  вы записываете "<varname>$a</varname> = 5", вы присваиваете '5' переменной
  <varname>$a</varname>. '5', очевидно, имеет значение 5 или, другими словами,
  '5' это выражение со значением 5 (в данном случае '5' - это целочисленная
  константа).
 </simpara>
 <simpara>
  После этого присвоения вы ожидаете, что значением <varname>$a</varname>
  также является 5, поэтому, если вы написали <varname>$b</varname> =
  <varname>$a</varname>, вы полагаете, что работать это будет так же, как
  если бы вы написали <varname>$b</varname> = 5. Другими словами,
  <varname>$a</varname> это также выражение со значением 5. Если все работает
  верно, то именно так и произойдет.
 </simpara>
 <para>
  Немного более сложными примерами выражений являются функции. Например,
  рассмотрим следующую функцию:
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
function foo ()
{
    return 5;
}
?>
]]>
     </programlisting>
    </informalexample>
  </para>
  <simpara>
   Исходя из того, что вы хорошо знакомы с концепцией функций (если нет,
   то прочитайте главу о <link linkend="language.functions">функциях</link>), вы
   полагаете, что запись <literal>$c = foo()</literal> абсолютно
   эквивалентна записи <literal>$c = 5</literal>, и вы правы. Функции -
   это выражения, значением которых является то, что возвращает функция.
   Поскольку <literal>foo()</literal> возвращает 5, значением выражения
   <literal>'foo()'</literal> является 5.
   Как правило, функции возвращают не просто статическое значение, а
   что-то вычисляют.
  </simpara>
  <simpara>
   Разумеется, значения в PHP не обязаны быть целочисленными, и очень
   часто ими не являются. PHP поддерживает четыре типа скалярных значений:
   целочисленные (<type>integer</type>), с плавающей точкой (<type>float</type>),
   строковые значения (<type>string</type>) и булевы (<type>boolean</type>)
   значения (скалярными являются значения, которые вы не можете 'разбить' на
   меньшие части, в отличие, например, от массивов). PHP поддерживает также два
   комбинированных (не скалярных) типа: массивы и объекты. Любое значение такого
   типа может присваиваться переменной или возвращаться функцией.
  </simpara>
  <simpara>
   Однако PHP, как и многие другие языки, понимает гораздо больше выражений.
   PHP - это язык, ориентированный на выражения и рассматривающий почти все как
   выражение. Вернемся к примеру, с которым мы уже имели дело:
   '<varname>$a</varname> = 5'. Легко заметить, что здесь присутствуют два значения
   - значение целочисленной константы '5' и значение переменной <varname>$a</varname>,
   также принимающей значение 5. Но на самом деле здесь присутствует и еще одно
   значение - значение самого присвоения. Само присвоение вычисляется в
   присвоенное значение, в данном случае - в 5. На практике это означает, что
   '<varname>$a</varname> = 5', независимо от того, что оно делает, является
   выражением со значением 5. Таким образом, запись '<varname>$b</varname> =
   (<varname>$a</varname> = 5)' равносильна записи '<varname>$a</varname> = 5;
   <varname>$b</varname> = 5;' (точка с запятой обозначает конец выражения).
   Поскольку операции присвоения анализируются справа налево, вы также
   можете написать '<varname>$b</varname> = <varname>$a</varname> = 5'.
  </simpara>
  <simpara>
   Другой хороший пример ориентированности на выражения - префиксный и
   постфиксный инкремент и декремент. Пользователи PHP и многих
   других языков возможно уже знакомы с формой записи <literal>variable++</literal>
   и <literal>variable--</literal>. Это <link linkend="language.operators.increment">
   операторы инкремента и декремента</link>. Также как и C, PHP
   поддерживает два типа инкремента - префиксный и постфиксный. Они
   оба инкрементируют значение переменной и эффект их действия на нее
   одинаков. Разница состоит в значении выражения инкремента.
   Префиксный инкремент, записываемый как '++<varname>$variable</varname>',
   вычисляется в инкрементированное значение (PHP инкрементирует переменную до того
   как прочесть ее значение, отсюда название 'пре-инкремент').
   Постфиксный инкремент, записываемый как '<varname>$variable</varname>++',
   вычисляется в первоначальное значение переменной $variable до ее приращения
   (PHP инкрементирует переменную после прочтения ее значения, отсюда
   название 'пост-инкремент').
  </simpara>
  <simpara>
   Очень распространенным типом выражений являются выражения  <link
   linkend="language.operators.comparison">сравнения</link>.
   Результатом вычислений являются &false; (ложь)
   или &true; (истина). PHP поддерживает операции сравнения &gt; (больше), &gt;= (больше
   либо равно), == (равно), != (не равно), &lt; (меньше) и &lt;=
   (меньше либо равно). Он также поддерживает операторы строгого
   равенства: === (равно и одного типа) и !== (не равно или не одного
   типа). Чаще всего эти выражения используются в операторах условного выполнения,
   таких как <literal>if</literal>.
  </simpara>
  <simpara>
   Последний пример выражений, который мы здесь рассмотрим, это
   смешанные выражения операции и присвоения. Вы уже знаете, что если
   вы хотите увеличить <varname>$a</varname> на 1, вы можете просто написать
   '<varname>$a</varname>++' или '++<varname>$a</varname>'. Но что, если вы
   хотите прибавить больше, чем единицу,например, 3? Вы могли бы написать
   '<varname>$a</varname>++' много раз, однако, очевидно это не очень
   рациональный и удобный способ. Гораздо более распространенной практикой
   является запись вида '<varname>$a</varname> = <varname>$a</varname> + 3'.
   '<varname>$a</varname> + 3' вычисляется в значение <varname>$a</varname> плюс
   3 и снова присваивается <varname>$a</varname>, увеличивая в результате
   <varname>$a</varname> на 3. В PHP, как и в некоторых других языках, таких как C,
   вы можете записать это более коротким образом, что увеличит очевидность смысла
   и быстроту понимания кода по прошествии времени. Прибавить 3 к текущему значению
   <varname>$a</varname> можно с помощью записи '<varname>$a</varname> += 3'.
   Это означает дословно "взять значение <varname>$a</varname>, прибавить к
   нему 3 и снова присвоить его переменной <varname>$a</varname>". Кроме
   большей понятности и краткости, это быстрее работает. Значением
   '<varname>$a</varname> += 3', как и обычного присвоения, является присвоенное
   значение. Обратите внимание, что это НЕ 3, а суммированное значение
   <varname>$a</varname> плюс 3 (то, что было присвоено <varname>$a</varname>).
   Таким образом может использоваться любой бинарный оператор, например,
   '<varname>$a</varname> -= 5' (вычесть 5 из значения <varname>$a</varname>),
   '<varname>$b</varname> *= 7' (умножить значение <varname>$b</varname> на 7)
   и т.д.
  </simpara>
  <para>
   Существует еще одно выражение, которое может выглядеть необычно,
   если вы не встречали его в других языках - тернарный условный
   оператор:
  </para>
  <para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$first ? $second : $third
?>
]]>
     </programlisting>
    </informalexample>
  </para>
  <para>
   Если значением первого подвыражения является &true; (не ноль),
   то выполняется второе подвыражение, которое и будет результатом
   условного выражения. В противном случае будет выполнено третье
   подвыражение и его значение будет результатом.
  </para>
  <para>
   Следующий пример должен помочь вам немного улучшить понимание
   префиксного и постфиксного инкремента и выражений:
  </para>
  <para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function double($i)
{
    return $i*2;
}
$b = $a = 5;        /* присвоить значение пять переменным $a и $b */
$c = $a++;          /* постфиксный инкремент, присвоить значение $a 
                       (5) переменной $c */
$e = $d = ++$b;     /* префиксный инкремент, присвоить увеличенное
                       значение $b (6) переменным $d и $e */

/* в этой точке и $d, и $e равны 6 */

$f = double($d++);  /* присвоить удвоенное значение $d перед
                       инкрементом (2*6 = 12) переменной $f */
$g = double(++$e);  /* присвоить удвоенное значение $e после
                       инкремента (2*7 = 14) переменной $g */
$h = $g += 10;      /* сначала переменная $g увеличивается на 10,
                       приобретая, в итоге, значение 24. Затем значение
                       присвоения (24) присваивается переменной $h,
                       которая в итоге также становится равной 24. */
?>
]]>
     </programlisting>
    </informalexample>
  </para>
  <simpara>
   Некоторые выражения могут рассматриваться как инструкции. В
   данном случае инструкция имеет вид '<literal>expr ;</literal> - выражение с
   последующей точкой с запятой. В записи <literal>'$b = $a = 5;'</literal>,
   <literal>$a = 5</literal> - это верное выражение, но само по себе не инструкция.
   Тогда как <literal>'$b = $a = 5;'</literal> является верной инструкцией.
  </simpara>
  <simpara>
   Последнее, что стоит упомянуть, это истинность значения выражений.
   Во многих случаях, как правило, в условных операторах и циклах,
   вас может интересовать не конкретное значение выражения, а только
   его истинность (значение &true; или &false;).
   
   <!-- (PHP doesn't have a
    dedicated boolean type) : WRONG, PHP does. -->
    
    Константы &true; и &false; (регистро-независимые) - это два
    возможных булевых значения. При необходимости выражение
    автоматически преобразуется в булев тип. Подробнее о том, как это
    происходит, смотрите в <link linkend="language.types.typecasting">разделе о
    приведении типов</link>.
  </simpara>
  <simpara>
   PHP предоставляет полную и мощную реализацию выражений, и их
   полное документирование выходит за рамки этого руководства.
   Вышеприведенные примеры должны дать вам представление о том, что
   они из себя представляют и как вы сами можете создавать полезные
   выражения. Далее, для обозначения любого верного выражения PHP в
   этой документации мы будем использовать сокращение <varname>expr</varname>.
  </simpara>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
