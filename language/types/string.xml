<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 8ad0d94e1c87b2daabff88e74acc31e8a11eec0a Maintainer: shein Status: ready -->
<!-- Reviewed: no -->
<!-- $Revision$ -->
<sect1 xml:id="language.types.string">
 <title>Строки</title>

 <!-- FIXME PHP_6 Likely unicode support will alter this -->
 <para>
  Строка - это набор символов, где символ - это то же самое, что
  и байт. Это значит, что PHP поддерживает ровно 256 различных
  символов, а также то, что в PHP нет встроенной поддержки
  Unicode. Смотрите также <link linkend="language.types.string.details">
  подробности реализации строкового типа</link>.
 </para>

 <note>
  <simpara>
   Строки не могут быть размером более 2 Гб (2147483647 байт).
  </simpara>
 </note>

 <sect2 xml:id="language.types.string.syntax">
  <title>Синтаксис</title>

  <para>
   Строка может быть определена четырьмя различными способами:
  </para>

  <itemizedlist>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.single">одинарными кавычками</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.double">двойными кавычками</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.heredoc">heredoc-синтаксисом</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.nowdoc">nowdoc-синтаксисом</link>
     (начиная с версии PHP 5.3.0)
    </simpara>
   </listitem>
  </itemizedlist>

  <sect3 xml:id="language.types.string.syntax.single">
   <title>Одинарные кавычки</title>

   <para>
    Простейший способ определить строку - это заключить ее в
    одинарные кавычки (символ <literal>'</literal>).
   </para>

   <para>
    Чтобы использовать одинарную кавычку внутри строки,
    проэкранируйте ее обратной косой чертой (<literal>\</literal>).
    Если необходимо написать саму обратную косую черту, продублируйте ее
    (<literal>\\</literal>).
    Все остальные случаи применения обратной косой черты будут интерпретированы как
    обычные символы: это означает, что если вы попытаетесь использовать другие управляющие
    последовательности, такие как <literal>\r</literal> или <literal>\n</literal>,
    они будут выведены как есть вместо какого-либо особого поведения.
   </para>

   <note>
    <simpara>
     В отличие от синтаксиса <link linkend="language.types.string.syntax.double">двойных кавычек</link>
     и <link linkend="language.types.string.syntax.heredoc">heredoc</link>,
     <link linkend="language.variables">переменные</link> и
     управляющие последовательности для специальных
     символов, заключенных в одинарные кавычки, <emphasis>не</emphasis>
     обрабатываются.
    </simpara>
   </note>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo 'это простая строка';

echo 'Также вы можете вставлять в строки
символ новой строки вот так,
это нормально';

// Выводит: Однажды Арнольд сказал: "I'll be back"
echo 'Однажды Арнольд сказал: "I\'ll be back"';

// Выводит: Вы удалили C:\*.*?
echo 'Вы удалили C:\\*.*?';

// Выводит: Вы удалили C:\*.*?
echo 'Вы удалили C:\*.*?';

// Выводит: Это не будет развернуто: \n новая строка
echo 'Это не будет развернуто: \n новая строка';

// Выводит: Переменные $expand также $either не разворачиваются
echo 'Переменные $expand также $either не разворачиваются';
?>
]]>
    </programlisting>
   </informalexample>

  </sect3>

  <sect3 xml:id="language.types.string.syntax.double">
   <title>Двойные кавычки</title>

   <para>
    Если строка заключена в двойные кавычки ("), PHP распознает
    большее количество управляющих последовательностей для
    специальных символов:
   </para>

   <table>
    <title>Управляющие последовательности</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Последовательность</entry>
       <entry>Значение</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>\n</literal></entry>
       <entry>новая строка (LF или 0x0A (10) в ASCII)</entry>
      </row>
      <row>
       <entry><literal>\r</literal></entry>
       <entry>возврат каретки (CR или 0x0D (13) в ASCII)</entry>
      </row>
      <row>
       <entry><literal>\t</literal></entry>
       <entry>горизонтальная табуляция (HT или 0x09 (9) в ASCII)</entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>вертикальная табуляция (VT или 0x0B (11) в ASCII) (с версии PHP 5.2.5)</entry>
      </row>
      <row>
       <entry><literal>\e</literal></entry>
       <entry>escape-знак (ESC или 0x1B (27) в ASCII) (с версии PHP 5.4.0)</entry>
      </row>      
      <row>
       <entry><literal>\f</literal></entry>
       <entry>подача страницы (FF или 0x0C (12) в ASCII) (с версии PHP 5.2.5)</entry>
      </row>
      <row>
       <entry><literal>\\</literal></entry>
       <entry>обратная косая черта</entry>
      </row>
      <row>
       <entry><literal>\$</literal></entry>
       <entry>знак доллара</entry>
      </row>
      <row>
       <entry><literal>\"</literal></entry>
       <entry>двойная кавычка</entry>
      </row>
      <row>
       <entry><literal>\[0-7]{1,3}</literal></entry>
       <entry>
        последовательность символов, соответствующая
        регулярному выражению символа в восьмеричной
        системе счисления
       </entry>
      </row>
      <row>
       <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
       <entry>
        последовательность символов, соответствующая
        регулярному выражению символа в шестнадцатеричной
        системе счисления
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Как и в строке, заключенной в одинарные кавычки, экранирование любого символа
    выведет также и саму обратную косую черту. До версии PHP 5.1.1, обратная косая
    черта в <literal>\{$var}</literal> не печаталась.
   </para>

   <para>
    Но самым важным свойством строк в двойных кавычках является
    обработка переменных.
    Смотрите более подробно: <link linkend="language.types.string.parsing">обработка строк</link>
   </para>
  </sect3>
  
  <sect3 xml:id="language.types.string.syntax.heredoc">
   <title>Heredoc</title>

   <simpara>
    Третий способ определения строк - это использование
    heredoc-синтаксиса: <literal>&lt;&lt;&lt;</literal>. После
    этого оператора необходимо указать идентификатор,
    затем перевод строки. После этого идет сама строка,
    а потом этот же идентификатор, закрывающий вставку.
   </simpara>

   <simpara>
    Строка <emphasis>должна</emphasis> начинаться с закрывающего идентификатора,
    т.е. он должен стоять в первом столбце строки. Кроме того, идентификатор должен
    соответствовать тем же правилам именования, что и все остальные
    метки в PHP: содержать только буквенно-цифровые символы и знак
    подчеркивания, и не должен начинаться с цифры (знак подчеркивания разрешается).
   </simpara>
   
   <warning>
    <simpara>
     Очень важно отметить, что строка с закрывающим идентификатором
     не содержит других символов, за исключением,
     <emphasis>возможно</emphasis>, точки с запятой
     (<literal>;</literal>). Это означает, что идентификатор
     <emphasis>не должен вводиться с отступом</emphasis> и что не
     может быть никаких пробелов или знаков табуляции до или после
     точки с запятой. Важно также понимать, что первым символом перед
     закрывающим идентификатором должен быть символ новой строки,
     определенный в вашей операционной системе. Например, на Macintosh
     это <literal>\r</literal>. После закрывающего идентификатора (необязательно
     дополненного точкой с запятой) также сразу должна начинаться новая строка.
    </simpara>

    <simpara>
     Если это правило нарушено и закрывающий идентификатор не является
     "чистым", считается, что закрывающий идентификатор отсутствует и
     PHP продолжит его поиск дальше. Если в этом случае верный
     закрывающий идентификатор так и не будет найден, то это вызовет
     ошибку парсинга с номером строки в конце скрипта.
    </simpara>

    <para>
     Heredoc не может быть использован для инициализации полей класса.
     Начиная с версии PHP 5.3, это ограничение распространяется только на heredoc,
     содержащие внутри себя переменные.
    </para>
    
    <example>
     <title>Неверный пример</title>
     <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
    EOT;
}
?>
]]>
     </programlisting>
    </example>
   </warning>

   <para>
    Heredoc-текст ведет себя так же, как и строка в двойных кавычках,
    при этом их не имея. Это означает, что вам нет необходимости
    экранировать кавычки в heredoc, но вы по-прежнему можете
    использовать вышеперечисленные управляющие последовательности.
    Переменные обрабатываются, но с применением сложных переменных
    внутри heredoc нужно быть также внимательным, как и при работе
    со строками.
   </para>

   <example> 
    <title>Пример определения heredoc-строки</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Пример строки,
охватывающей несколько строчек,
с использованием heredoc-синтаксиса.
EOD;

/* Более сложный пример с переменными. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'МоеИмя';

echo <<<EOT
Меня зовут "$name". Я печатаю $foo->foo.
Теперь я вывожу {$foo->bar[1]}.
Это должно вывести заглавную букву 'A': \x41
EOT;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Меня зовут "МоеИмя". Я печатаю Foo.
Теперь, я вывожу Bar2.
Это должно вывести заглавную букву 'A': A]]>
    </screen>
   </example>

   <para>
    Также возможно использовать heredoc-синтаксис для передачи данных
    через аргументы функции:
   </para>

   <example> 
    <title>Пример применения heredoc в аргументах</title>
    <programlisting role="php">
<![CDATA[
<?php
var_dump(array(<<<EOD
foobar!
EOD
));
?>
]]>
    </programlisting>
   </example>

   <para>
    Начиная с версии 5.3.0, стала возможной инциализация статических переменных
    и свойств/констант класса с помощью синтаксиса heredoc:
   </para>

   <example> 
    <title>Использование heredoc для инциализации статических переменных</title>
    <programlisting role="php">
<![CDATA[
<?php
// Статические переменные
function foo()
{
    static $bar = <<<LABEL
Здесь ничего нет...
LABEL;
}

// Class properties/constants
class foo
{
    const BAR = <<<FOOBAR
Пример использования константы
FOOBAR;

    public $baz = <<<FOOBAR
Пример использования поля
FOOBAR;
}
?>
]]>
    </programlisting>
   </example>

   <para>
    Начиная с версии PHP 5.3.0 можно также окружать идентификатор Heredoc
    двойными кавычками:
   </para>

   <example> 
    <title>Использование двойных кавычек в heredoc</title>
    <programlisting role="php">
<![CDATA[
<?php
echo <<<"FOOBAR"
Привет, мир!
FOOBAR;
?>
]]>
    </programlisting>
   </example>

  </sect3>
  
  <sect3 xml:id="language.types.string.syntax.nowdoc">
   <title>Nowdoc</title>
   
   <para>
    Nowdoc - это то же самое для строк в одинарных кавычках, что и
    heredoc для строк в двойных кавычках.
    Nowdoc похож на heredoc, но внутри него <emphasis>не осуществляется
    никаких подстановок</emphasis>. Эта конструкция идеальна для внедрения
    PHP-кода или других больших блоков текста без необходимости
    его экранирования. В этом он немного похож на SGML-конструкцию
    <literal>&lt;![CDATA[ ]]&gt;</literal> тем, что объявляет блок текста,
    не предназначенный для обработки.
   </para>
   
   <para>
    Nowdoc указывается той же последовательностью <literal>&lt;&lt;&lt;</literal>,
    что используется в heredoc, но последующий за ней идентификатор заключается
    в одинарные кавычки, например, <literal>&lt;&lt;&lt;'EOT'</literal>.
    Все условия, действующие для heredoc идентификаторов также действительны
    и для nowdoc, особенно те, что относятся к закрывающему идентификатору.
   </para>
   
   <example>
    <title>Пример использования nowdoc</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<'EOD'
Пример текста,
занимающего несколько строк,
с помощью синтаксиса nowdoc.
EOD;

/* Более сложный пример с переменными. */
class foo
{
    public $foo;
    public $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'МоеИмя';

echo <<<'EOT'
Меня зовут "$name". Я печатаю $foo->foo.
Теперь я печатаю {$foo->bar[1]}.
Это не должно вывести заглавную 'A': \x41
EOT;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Меня зовут "$name". Я печатаю $foo->foo.
Теперь я печатаю {$foo->bar[1]}.
Это не должно вывести заглавную 'A': \x41]]>
    </screen>
   </example>
   
   <note>
    <para>
     В отличие от heredoc, nowdoc может быть использован в любом контексте
     со статическими данными. Типичный пример инициализации полей класса
     или констант:
    </para>
   </note>
    
   <example>
    <title>Пример использования статичных данных</title>
    <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<'EOT'
bar
EOT;
}
?>
]]>
    </programlisting>
   </example>

   <note>
    <para>
     Поддержка nowdoc была добавлена в PHP 5.3.0.
    </para>
   </note>

  </sect3>

  <sect3 xml:id="language.types.string.parsing">
   <title>Обработка переменных</title>

   <simpara>
    Если строка указывается в двойных кавычках, либо при помощи
    heredoc, <link linkend="language.variables">переменные</link> внутри
    нее обрабатываются.
   </simpara>

   <simpara>
    Существует два типа синтаксиса:
    <link linkend="language.types.string.parsing.simple">простой</link> и
    <link linkend="language.types.string.parsing.complex">сложный</link>.
    Простой синтаксис более легок и удобен. Он дает возможность
    обработки переменной, значения массива (<type>array</type>) или
    свойства объекта (<type>object</type>) с минимумом усилий.
   </simpara>

   <simpara>
    Сложный синтаксис может быть определен
    по фигурным скобкам, окружающим выражение.
   </simpara>

   <sect4 xml:id="language.types.string.parsing.simple">
    <title>Простой синтаксис</title>

    <simpara>
     Если интерпретатор встречает знак доллара (<literal>$</literal>), он
     захватывает так много символов, сколько возможно, чтобы сформировать
     правильное имя переменной. Если вы хотите точно определить конец имени,
     заключайте имя переменной в фигурные скобки.
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$juice = "apple";

echo "He drank some $juice juice.".PHP_EOL;
// не работает, 's' - это верный символ для имени переменной,
// но наша переменная имеет имя $juice.
echo "He drank some juice made of $juices.";
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
He drank some apple juice.
He drank some juice made of .
]]>
     </screen>
    </informalexample>

    <simpara>
     Аналогично могут быть обработаны элемент массива
     (<type>array</type>) или свойство объекта (<type>object</type>).
     В индексах массива закрывающая квадратная скобка
     (<literal>]</literal>) обозначает конец определения индекса.
     Для свойств объекта применяются те же правила, что и для простых
     переменных.
    </simpara>

    <example><title>Пример простого синтаксиса</title>
     <programlisting role="php">
<![CDATA[
<?php
$juices = array("apple", "orange", "koolaid1" => "purple");

echo "He drank some $juices[0] juice.".PHP_EOL;
echo "He drank some $juices[1] juice.".PHP_EOL;
echo "He drank some juice made of $juice[0]s.".PHP_EOL; // Не будет работать
echo "He drank some $juices[koolaid1] juice.".PHP_EOL;

class people {
    public $john = "John Smith";
    public $jane = "Jane Smith";
    public $robert = "Robert Paulsen";
    
    public $smith = "Smith";
}

$people = new people();

echo "$people->john drank some $juices[0] juice.".PHP_EOL;
echo "$people->john then said hello to $people->jane.".PHP_EOL;
echo "$people->john's wife greeted $people->robert.".PHP_EOL;
echo "$people->robert greeted the two $people->smiths."; // Не будет работать
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
He drank some apple juice.
He drank some orange juice.
He drank some juice made of s.
He drank some purple juice.
John Smith drank some apple juice.
John Smith then said hello to Jane Smith.
John Smith's wife greeted Robert Paulsen.
Robert Paulsen greeted the two .
]]>
     </screen>
    </example>

    <simpara>
      Для чего-либо более сложного, используйте сложный синтаксис.
    </simpara>
   </sect4>

   <sect4 xml:id="language.types.string.parsing.complex">
    <title>Сложный (фигурный) синтаксис</title>

    <simpara>
     Он называется сложным не потому, что труден в понимании,
     а потому что позволяет использовать сложные выражения.
    </simpara>

    <simpara>
     Любая скалярная переменная, элемент массива или свойство объекта,
     отображаемое в строку, может быть представлена в строке этим синтаксисом.
     Просто запишите выражение так же, как и вне строки, а
     затем заключите его в <literal>{</literal> и <literal>}</literal>.
     Поскольку <literal>{</literal> не может быть
     экранирован, этот синтаксис будет распознаваться только когда <literal>$</literal>
     следует непосредственно за <literal>{</literal>. Используйте
     <literal>{\$</literal>, чтобы напечатать <literal>{$</literal>.
     Несколько поясняющих примеров:
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Показываем все ошибки
error_reporting(E_ALL);

$great = 'здорово';

// Не работает, выводит: Это { здорово}
echo "Это { $great}";

// Работает, выводит: Это здорово
echo "Это {$great}";
echo "Это ${great}";

// Работает
echo "Этот квадрат шириной {$square->width}00 сантиметров.";

// Работает, ключи, заключенные в кавычки, работают только с синтаксисом фигурных скобок
echo "Это работает: {$arr['key']}";

// Работает
echo "Это работает: {$arr[4][3]}";

// Это неверно по той же причине, что и $foo[bar] вне
// строки. Другими словами, это по-прежнему будет работать,
// но поскольку PHP сначала ищет константу foo, это вызовет
// ошибку уровня E_NOTICE (неопределенная константа).
echo "Это неправильно: {$arr[foo][3]}";

// Работает. При использовании многомерных массивов внутри
// строк всегда используйте фигурные скобки
echo "Это работает: {$arr['foo'][3]}";

// Работает.
echo "Это работает: " . $arr['foo'][3];

echo "Это тоже работает: {$obj->values[3]->name}";

echo "Это значение переменной по имени $name: {${$name}}";

echo "Это значение переменной по имени, которое возвращает функция getName(): {${getName()}}";

echo "Это значение переменной по имени, которое возвращает \$object->getName(): {${$object->getName()}}";

// Не работает, выводит: Это то, что возвращает getName(): {getName()}
echo "Это то, что возвращает getName(): {getName()}";
?>
]]>
<!-- maybe it's better to leave this out?? 
// this works, but i disencourage its use, since this is NOT 
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
     </programlisting>
    </informalexample>

    <para>
     С помощью этого синтаксиса также возможен доступ к свойствам объекта
     внутри строк.
    </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class foo {
    var $bar = 'I am bar.';
}

$foo = new foo();
$bar = 'bar';
$baz = array('foo', 'bar', 'baz', 'quux');
echo "{$foo->$bar}\n";
echo "{$foo->$baz[1]}\n";
?>
]]>
    </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
I am bar.
I am bar.
]]>
   </screen>
   </informalexample>
    
    <note>
     <para>
      Функции, вызовы методов, статические переменные классов, а также
      константы классов работает внутри <literal>{$}</literal>, начиная
      с версии PHP 5.
      Однако, указываемое значение будет обработано как имя переменной
      в том же контексте, что и строка, в которой она определяется.
      Использование одинарных фигурных скобок (<literal>{}</literal>)
      не будет работать для доступа к значениям функций, методов,
      констант классов или статических переменных класса.
     </para>
    </note>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Показываем все ошибки
error_reporting(E_ALL);

class beers {
    const softdrink = 'rootbeer';
    public static $ale = 'ipa';
}

$rootbeer = 'A & W';
$ipa = 'Alexander Keith\'s';

// Это работает, выводит: Я бы хотел A & W
echo "Я бы хотел {${beers::softdrink}}\n";

// Это тоже работает, выводит: Я бы хотел Alexander Keith's
echo "Я бы хотел {${beers::$ale}}\n";
?>
]]>
     </programlisting>
    </informalexample>

   </sect4>
  </sect3>
  
  <sect3 xml:id="language.types.string.substr">
   <title>Доступ к символу в строке и его изменение</title>

   <para>
    Символы в строках можно использовать и модифицировать,
    определив их смещение относительно начала строки, начиная с
    нуля, в квадратных скобках после строки, например, <varname>$str[42]</varname>.
    Думайте о строке для этой цели, как о массиве символов.
    Если нужно получить или заменить более 1 символа, можно использовать
    функции <function>substr</function> и <function>substr_replace</function>.
   </para>

   <note>
    <simpara>
     К символу в строке также можно обращаться с помощью фигурных скобок,
     например, <varname>$str{42}</varname>.
    </simpara>
   </note>

   <warning>
    <simpara>
     Попытка записи в смещение за границами строки дополнит строку
     пробелами до этого смещения. Нецелые типы будет преобразованы в целые.
     Неверный тип смещения вызовет ошибку уровня <constant>E_NOTICE</constant>.
     Запись по отрицательному смещению вызовет ошибку уровня <constant>E_NOTICE</constant>,
     а при чтении вернет пустую строку.
     Используется только первый символ присваемой строки.
     Присвоение пустой строки присваивает нулевой байт (NULL).
    </simpara>
   </warning>

   <warning>
    <simpara>
     Строки в PHP внутренне представляют из себя массивы байт. Как результат,
     доступ или изменение строки по смещению небезопасно с точки зрения многобайтной
     кодировки, и должно выполняться только со строками в однобайтных кодировках,
     таких как, например, ISO-8859-1.
    </simpara>
   </warning>

   <example>
    <title>Несколько примеров строк</title>
    <programlisting role="php">
<![CDATA[
<?php
// Получение первого символа строки
$str = 'This is a test.';
$first = $str[0];

// Получение третьего символа строки
$third = $str[2];

// Получение последнего символа строки
$str = 'This is still a test.';
$last = $str[strlen($str)-1]; 

// Изменение последнего символа строки
$str = 'Look at the sea';
$str[strlen($str)-1] = 'e';

?>
]]>
    </programlisting>
   </example>
   
   <para>
    Начиная с PHP 5.4 смещение в строке должно задаваться либо целым числом либо строкой, содержащей цифры, иначе будет
    выдаваться предупреждение. Ранее смещение, заданное строкой вида <literal>"foo"</literal>, без предупреждений преобразовывалось в <literal>0</literal>.
   </para>

   <example>
    <title>Различия между PHP 5.3 и PHP 5.4</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = 'abc';

var_dump($str['1']);
var_dump(isset($str['1']));

var_dump($str['1.0']);
var_dump(isset($str['1.0']));

var_dump($str['x']);
var_dump(isset($str['x']));

var_dump($str['1x']);
var_dump(isset($str['1x']));
?>
]]>
    </programlisting>
    &example.outputs.53;
    <screen>
<![CDATA[
string(1) "b"
bool(true)
string(1) "b"
bool(true)
string(1) "a"
bool(true)
string(1) "b"
bool(true)
]]>
    </screen>
    &example.outputs.54;
    <screen>
<![CDATA[
string(1) "b"
bool(true)

Warning: Illegal string offset '1.0' in /tmp/t.php on line 7
string(1) "b"
bool(false)

Warning: Illegal string offset 'x' in /tmp/t.php on line 9
string(1) "a"
bool(false)
string(1) "b"
bool(false)
]]>
    </screen>
   </example>

   <note>
    <para>
     Попытка доступа к переменным других типов (исключая массивы или
     объекты, реализующие определенные интерфейсы) с помощью <literal>[]</literal>
     или <literal>{}</literal> молча вернет &null;.
    </para>
   </note>

   <note>
    <para>
     В PHP 5.5 была добавлена поддержка доступа к символам в строковых литералах
     с помощью синтаксиса <literal>[]</literal> или <literal>{}</literal>.
    </para>
   </note>
  </sect3>
 </sect2><!-- end syntax -->

 <sect2 xml:id="language.types.string.useful-funcs">
  <title>Полезные функции и операторы</title>

  <para>
   Строки могут быть объединены при помощи оператора '.' (точка).
   Обратите внимание, оператор сложения '+' <emphasis>здесь не работает</emphasis>.
   Дополнительную информацию смотрите в разделе <link
   linkend="language.operators.string">Строковые операторы</link>.
  </para>

  <para>
   Для модификации строк существует множество полезных функций.
  </para>

  <simpara>
   Основные функции описаны в разделе
   <link linkend="ref.strings">строковых функций</link>, а
   для расширенного поиска и замены - функции
   <link linkend="ref.regex">регулярных выражений</link>
   или <link linkend="ref.pcre">Perl-совместимых регулярных выражений</link>.
  </simpara>

  <simpara>
   Также существуют <link linkend="ref.url">функции для работы с URL</link>,
   и функции шифрования/дешифрования строк (<link
   linkend="ref.mcrypt">mcrypt</link> и <link
   linkend="ref.mhash">mhash</link>).
  </simpara>

  <simpara>
   Наконец, смотрите также
   <link linkend="ref.ctype">функции символьных типов</link>.
  </simpara>
 </sect2>

 <sect2 xml:id="language.types.string.casting">
  <title>Преобразование в строку</title>
  
  <para>
   Значение может быть преобразовано в строку, с помощью приведения
   <literal>(string)</literal>, либо функции <function>strval</function>.
   В выражениях, где необходима строка, преобразование происходит автоматически.
   Это происходит, когда вы используете функции <function>echo</function>
   или <function>print</function>, либо когда значение переменной сравнивается
   со строкой. Прочтение разделов руководства <link
   linkend="language.types">Типы</link> и <link
   linkend="language.types.type-juggling">Манипуляции с типами</link> сделает
   следующее более понятным. Смотрите также <function>settype</function>.
  </para>
  
  <para>
   Значение <type>boolean</type> &true; преобразуется в строку
   <literal>"1"</literal>, а значение &false; преобразуется в
   <literal>""</literal> (пустую строку). Это позволяет преобразовывать значения
    в обе стороны - из булева типа в строковый и наоборот.
  </para>

  <para> 
   Целое (<type>integer</type>) или число с плавающей точкой
   (<type>float</type>) преобразуется в строку, представленную числом,
   состоящим из его цифр (включая показатель степени для чисел с плавающей
   точкой). Числа с плавающей точкой могут быть преобразованы с помощью
   экспоненциального представления (<literal>4.1E+6</literal>).
  </para>

  <note>
   <para>
    Символ десятичной точки определяется из настроек локали текущего скрипта
    (категория LC_NUMERIC). Смотрите также <function>setlocale</function>.
   </para>
  </note>

  <para>
   Массивы всегда преобразуются в строку <literal>"Array"</literal>,
   так что вы не можете отобразить содержимое массива (<type>array</type>),
   используя <function>echo</function> или <function>print</function>,
   чтобы узнать, что он содержит. Чтобы просмотреть отдельный элемент, используйте
   что-нибудь вроде <literal>echo $arr['foo']</literal>. Смотрите
   ниже советы о том, как отобразить/просмотреть все содержимое.
  </para>

  <para>
   Объекты в PHP 4 всегда преобразовывались в строку <literal>"Object"</literal>.
   Если вы хотите вывести значения полей объекта
   (<type>object</type>) с целью отладки, читайте дальше. Если
   вы хотите получить имя класса требуемого объекта, используйте
   <function>get_class</function>. Начиная с PHP 5, также стал доступен метод
   <link linkend="language.oop5.magic">__toString</link>.
  </para>

  <para>
   Ресурсы всегда преобразуются в строки со структурой
   <literal>"Resource id #1"</literal>, где <literal>1</literal> - это
   уникальный номер ресурса (<type>resource</type>), присвоенный ему PHP
   во время выполнения. Не полагайтесь на эту структуру, она может измениться в любое время.
   Если вы хотите получить тип ресурса, используйте <function>get_resource_type</function>.
  </para>

  <para>
    &null; всегда преобразуется в пустую строку.
  </para>
  
  <para>
   Как вы могли видеть выше, прямое преобразование в строку массивов, объектов
   или ресурсов не дает никакой полезной информации о самих значениях, кроме их типов.
   Более подходящий способ вывода значений для отладки - использовать функции
   <function>print_r</function> и <function>var_dump</function>.
  </para>
  
  <para>
   Большинство значений в PHP может быть преобразовано в строку для постоянного
   хранения. Этот метод называется сериализацией и может быть выполнен
   при помощи функции <function>serialize</function>. Кроме того, если в
   вашей установке PHP есть поддержка <link linkend="ref.wddx">WDDX</link>,
   возможна также сериализация в XML-структуру.
  </para>

 </sect2>

 <sect2 xml:id="language.types.string.conversion">
  <title>Преобразование строк в числа</title>

  <simpara>
   Если строка распознается как числовое значение, результирующее значение
   и тип определяется так, как показано далее.
  </simpara>

  <simpara>
   Если строка не содержит какой-либо из символов '.', 'e', или 'E', и
   значение числа помещается в пределы целых чисел (определенных
   <constant>PHP_INT_MAX</constant>), строка будет распознана как целое число (<type>integer</type>).
   Во всех остальных случаях она считается числом с плавающей точкой (<type>float</type>).
  </simpara>

  <para>
   Значение определяется по начальной части строки. Если строка
   начинается с верного числового значения, будет использовано это
   значение. Иначе значением будет 0 (ноль). Верное числовое значение
   - это одна или более цифр (могущих содержать десятичную точку),
   по желанию предваренных знаком, с последующим необязательным
   показателем степени. Показатель степени - это 'e' или 'E' с
   последующими одной или более цифрами.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";                // $foo это float (11.5)
$foo = 1 + "-1.3e3";              // $foo это float (-1299)
$foo = 1 + "bob-1.3e3";           // $foo это integer (1)
$foo = 1 + "bob3";                // $foo это integer (1)
$foo = 1 + "10 Small Pigs";       // $foo это integer (11)
$foo = 4 + "10.2 Little Piggies"; // $foo это float (14.2)
$foo = "10.0 pigs " + 1;          // $foo это float (11)
$foo = "10.0 pigs " + 1.0;        // $foo это float (11)
?>
]]>
   </programlisting>
  </informalexample>

  <simpara>
   Более подробную информацию об этом преобразовании смотрите в разделе
   о strtod(3) документации Unix.
  </simpara>

  <para>
   Если вы хотите протестировать любой из примеров этого раздела,
   скопируйте и вставьте его и следующую строку, чтобы
   увидеть, что происходит:
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
echo "\$foo==$foo; тип: " . gettype ($foo) . "<br />\n";
?>
]]>
   </programlisting>
  </informalexample>

  <para>
   Не ожидайте получить код символа, преобразовав его в целое (как
   это делается, например, в C). Для преобразования символов в
   их ASCII коды и обратно используйте функции <function>ord</function>
   и <function>chr</function>.
  </para>

 </sect2>

 <sect2 xml:id="language.types.string.details">
  
  <title>Подробности реализации строкового типа</title>
  
  <para>
   Строковый тип (<type>string</type>) в PHP реализован в виде массива
   байт и целого числа, содержащего длину буфера. Он не содержит никакой
   информации о способе преобразования этих байт в символы, предоставляя
   эту задачу программисту. Нет никаких ограничений на содержимое строки,
   например, байт со значением <literal>0</literal> ("NUL"-байт) может
   располагаться где угодно (однако, стоит учитывать, что некоторые функции,
   как сказано в этом руководстве, не явлляются "бинарно-безопасными",
   т.е. они могут передавать строки библиотекам, которые игнорируют
   данные после NUL-байта).
  </para>
  <para>
   Данная природа строкового типа объясняет почему в PHP нет отдельного
   типа “byte” - строки играют эту роль. Функции, возвращающие нетекстовые данные
   - например, произвольный поток данных, считываемый из сетевого сокета
   - тем не менее возвращают строки.
  </para>
  <para>
   Принимая во внимание тот факт, что PHP не диктует определенную кодировку
   для строк, можно задать вопрос, как в таком случае кодируются стрковые
   литералы. Например, строка <literal>"á"</literal> эквивалентна
   <literal>"\xE1"</literal> (ISO-8859-1), <literal>"\xC3\xA1"</literal>
   (UTF-8, форма нормализации C), <literal>"\x61\xCC\x81"</literal>
   (UTF-8, форма нормализации D) или какому-либо другому возможному
   представлению? Ответом является следующее: строка будет закодирована тем
   образом, которым она записана в файле скрипта. Таким образом, если
   скрипт записан в кодировке ISO-8859-1, то и строка будет закодирована в
   ISO-8859-1 и т.д. Однако, это правило не применяется при включенном
   режиме Zend Multibyte: в этом случае скрипт может быть записан в любой
   кодировке (которая указывается ясно или определяется автоматически),
   а затем конвертируются в определенную внутреннюю кодировку, которая и будет
   впоследствии использована для строковых литералов.
   Учтите, что на кодировку скрипта (или на внутреннюю кодировку, если
   включен режим Zend Multibyte) накладываются некоторые ограничения:
   практически всегда данная кодировка должна быть надмножеством ASCII,
   например, UTF-8 или ISO-8859-1. Учтите также, что кодировки, зависящие
   от состояния, где одни и те же значения байт могут быть использованы
   в начальном и неначальном состоянии сдвига (initial and non-inital
   shift state), могут вызвать проблемы.
  </para>
  <para>
   Разумеется, чтобы приносить пользу, строковые функции должны сделать
   некоторые предположения о кодировке строки. К несчастью, среди
   PHP-функций довольно большое разнообразие подходов к этому вопросу:
  </para>
  <itemizedlist>
   <listitem>
    <simpara>
     Некоторые функции предполагают, что строка закодирована в какой-либо
     однобайтовой кодировке, однако, для корректной работы им
     не требуется интерпретировать байты как определенные символы.
     Под эту категорию попадают, например, <function>substr</function>,
     <function>strpos</function>, <function>strlen</function> и
     <function>strcmp</function>. Другой способ мышления об этих функциях
     представляет собой оперирование буферами памяти, т.е. они работают
     непосредственно с байтами и их смещениями.
     offsets.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Другие функции ожидают передачу кодировку в виде параметра, возможно,
     предполагая некоторую кодировку по умолчанию, если параметр с кодировкой
     не был указан. Такой функцией является <function>htmlentities</function>
     и большинство функций из расширения
     <link linkend="book.mbstring">mbstring</link>.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Другие функции используют текущие установки локали (см.
     <function>setlocale</function>), но оперируют побайтово).
     В эту категорию попадают <function>strcasecmp</function>,
     <function>strtoupper</function> и <function>ucfirst</function>.
     Это означает, что они могут быть использованы только с однобайтовыми
     кодировками, в том случае, когда кодировка совпадает с локалью.
     Например, <literal>strtoupper("á")</literal> может вернуть
     <literal>"Á"</literal>, если локаль установлена корректно и буква
     <literal>á</literal> закодирована в виде одного байта. Если она
     закодирована в UTF-8, будет возвращен некорректный результат, и, в
     зависимости от текущей локали, результирующая строка может быть (или
     не быть) испорчена.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Наконец, есть функции, подразумевающие, что строка использует
     определенную кодировку, обычно UTF-8. Сюда попадают большинство
     функций из расширений <link linkend="book.intl">intl</link>
     и <link linkend="book.pcre">PCRE</link>
     (в последнем случае, только при указании модификатора
     <literal>u</literal>). Хотя это и сделано специально, функция
     <function>utf8_decode</function> подразумевает кодировку UTF-8,
     а <function>utf8_encode</function> - ISO-8859-1.
    </simpara>
   </listitem>
  </itemizedlist>

  <para>
   В конечном счете, написание корректных программ, работающих с Unicode,
   означает осторожное избегание функций, которые не работают с Unicode
   и, скорее всего, испортят данные, и использование вместо них корректных
   функций, обычно из расширений <link linkend="book.intl">intl</link>
   и <link linkend="book.mbstring">mbstring</link>.
   Однако, использование функций, способных работать с Unicode, является
   самым началом. Вне зависимости от тех функций, которые предоставляет
   язык, необходимо знать спецификацию самого Unicode. Например, если
   программа предполагает существование в языке только строчных и
   заглавных букв, то она делает большую ошибку.
  </para>
 </sect2>
</sect1><!-- end string -->
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
