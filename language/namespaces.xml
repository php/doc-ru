<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: a442778670dd2dde02af237a2de06048c59cb8cd Maintainer: mch Status: ready -->
<!-- Reviewed: no -->
<chapter xml:id="language.namespaces" xmlns="http://docbook.org/ns/docbook"
version="1.1">
 <title>Пространства имён</title>

 <sect1 xml:id="language.namespaces.rationale">
  <title>Обзор пространств имён</title>
  <?phpdoc print-version-for="namespaces"?>
  <simpara>
   Что такое пространства имён? В широком смысле — это один из способов инкапсуляции
   элементов. Такое абстрактное понятие можно увидеть во многих местах. Например, в любой
   операционной системе директории служат для группировки связанных файлов и выступают в
   качестве пространства имён для находящихся в них файлов. В качестве конкретного примера
   файл <literal>foo.txt</literal> может находиться сразу в обеих директориях:
   <literal>/home/greg</literal> и <literal>/home/other</literal>, но две копии
   <literal>foo.txt</literal> не могут существовать в одной директории. Кроме того, для доступа
   к <literal>foo.txt</literal> извне директории <literal>/home/greg</literal>, мы должны
   добавить имя директории перед именем файла используя разделитель, чтобы получить
   <literal>/home/greg/foo.txt</literal>. Этот же принцип распространяется и на пространства
   имён в программировании.
  </simpara>

  <simpara>
   В PHP пространства имён используются для решения двух проблем, с которыми
   сталкиваются авторы библиотек и приложений при создании повторно используемых
   элементов кода, таких как классы и функции:
  </simpara>
  <para>
   <orderedlist>
    <listitem>
     <simpara>
      Конфликт имён между вашим кодом и
      внутренними классами/функциями/константами PHP или сторонними.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Возможность создавать псевдонимы (или сокращения) для Ну_Очень_Длинных_Имён, чтобы облегчить
      первую проблему и улучшить читаемость исходного кода.
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <simpara>
   Пространства имён в PHP предоставляют возможность группировать логически связанные
   классы, интерфейсы, функции и константы.
  </simpara>
  <example>
   <title>Пример синтаксиса, использующего пространство имён</title>
   <programlisting role="php">
<![CDATA[
<?php
namespace my\name; // смотрите раздел "Определение пространств имён"
class MyClass {}
function myfunction() {}
const MYCONST = 1;

$a = new MyClass;
$c = new \my\name\MyClass; // смотрите раздел "Глобальная область видимости"

$a = strlen('hi'); // смотрите раздел "Использование пространств имён: возврат
                   // к глобальной функции/константе"

$d = namespace\MYCONST; // смотрите раздел "оператор пространства имён и
                        // константа __NAMESPACE__"
$d = __NAMESPACE__ . '\MYCONST';
echo constant($d); // смотрите раздел "Пространства имён и динамические особенности языка"
?>
]]>
   </programlisting>
  </example>
  <note>
   <simpara>
    Имена пространств имён регистронезависимы.
   </simpara>
  </note>
  <note>
   <para>
    Пространства имён <literal>PHP</literal> или составные имена,
    начинающиеся с этого слова (например, такие как <literal>PHP\Classes</literal>), зарезервированы для
    нужд языка, их не следует использовать в пользовательском коде.
   </para>
  </note>
 </sect1>

 <sect1 xml:id="language.namespaces.definition">
  <title>Определение пространств имён</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Хотя любой корректный PHP-код может находиться внутри пространства имён, только
   классы (включая абстрактные и трейты), интерфейсы, функции и константы зависят от него.
  </para>
  <para>
   Пространства имён объявляются с помощью зарезервированного слова <literal>namespace</literal>.
   Файл, содержащий пространство имён, должен содержать его объявление в начале
   перед любым другим кодом, кроме зарезервированного слова
   <xref linkend="control-structures.declare" />.
   <example>
    <title>Объявление единого пространства имён</title>
    <programlisting role="php">
<![CDATA[
<?php
namespace MyProject;

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }

?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     Абсолютные имена (т. е. имена, начинающиеся с обратной косой черты) не допускаются в объявлениях пространства имён,
     поскольку такие конструкции интерпретируются как относительные выражения пространства имён.
    </simpara>
   </note>
   Только выражение <literal>declare</literal> может находиться перед объявлением
   пространства имён для указания кодировки файла. Кроме того, объявлению пространства имён
   не должен предшествовать не PHP-код, в том числе лишние пробелы:
   <example>
    <title>Объявление простого пространства имён</title>
    <programlisting role="php">
<![CDATA[
<html>
<?php
namespace MyProject; // fatal error — объявление пространства имён должно быть первым выражением в скрипте
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Кроме того, в отличие от любой другой конструкции PHP, одно и то же пространство имён
    можно определять в нескольких файлах, что позволяет распределять их содержимое по файловой системе.
   </para>
 </sect1>
 <sect1 xml:id="language.namespaces.nested">
  <title>Определение подпространств имён</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Так же как файлы и каталоги, пространства имён PHP позволяют создавать
   иерархию имён. Таким образом, имя пространства может быть определено
   с подуровнями:
   <example>
    <title>Определение пространства имён с иерархией</title>
    <programlisting role="php">
<![CDATA[
<?php
namespace MyProject\Sub\Level;

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }

?>
]]>
    </programlisting>
   </example>
   Вышеприведённый пример создаёт константу <literal>MyProject\Sub\Level\CONNECT_OK</literal>,
   класс <literal>MyProject\Sub\Level\Connection</literal> и функцию
   <literal>MyProject\Sub\Level\connect</literal>.
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.definitionmultiple">
  <title>Описание нескольких пространств имён в одном файле</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Несколько пространств имён также можно описать в одном файле с помощью двух допустимых
   синтаксических конструкций.
  </para>
  <para>
   <example>
    <title>Описание нескольких пространств имён, простой синтаксис</title>
    <programlisting role="php">
<![CDATA[
<?php
namespace MyProject;

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }

namespace AnotherProject;

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Данный синтаксис не рекомендуется для комбинирования пространств имён в одном файле.
   Вместо этого рекомендуется использовать альтернативный синтаксис со скобками.
  </para>
  <para>
   <example>
    <title>Описание нескольких пространств имён, синтаксис со скобками</title>
    <programlisting role="php">
<![CDATA[
<?php
namespace MyProject {

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }
}

namespace AnotherProject {

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Настоятельно не рекомендуется при программировании комбинировать несколько пространств имён
    в один файл. Основным применением этому может быть объединение нескольких PHP-файлов в
    один файл.
   </para>
   <para>
    Для объединения кода в глобальном пространстве имён с кодом в других пространствах имён,
    используется только синтаксис со скобками. Глобальный код должен быть
    помещён в конструкцию описания пространства имён без указания имени:
    <example>
     <title>Описание глобального и обычного пространства имён в одном файле</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace MyProject {

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }
}

namespace {       // глобальный код
session_start();
$a = MyProject\connect();
echo MyProject\Connection::start();
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    PHP-код не может находиться вне скобок конструкции пространства имён, кроме
    начального выражения declare.
    <example>
     <title>Описание глобального и обычного пространства имён в одном файле</title>
     <programlisting role="php">
<![CDATA[
<?php
declare(encoding='UTF-8');
namespace MyProject {

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }
}

namespace {      // глобальный код
session_start();
$a = MyProject\connect();
echo MyProject\Connection::start();
}
?>
]]>
     </programlisting>
    </example>
   </para>
 </sect1>
 <sect1 xml:id="language.namespaces.basics">
  <title>Использование пространства имён: основы</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   До обсуждения использования пространств имён важно понять, как PHP узнает,
   какие элементы из пространства имён запрашиваются в вашем коде. Можно провести
   аналогию между пространствами имён PHP и файловой системой. Есть три способа обратиться
   к файлу в файловой системе:
   <orderedlist>
    <listitem>
     <simpara>
      Относительное имя файла, такое как <literal>foo.txt</literal>, преобразуемое в
      <literal>currentdirectory/foo.txt</literal>, где <literal>currentdirectory</literal> — текущая
      директория, в которой мы находимся. Тогда, если текущая директория
      <literal>/home/foo</literal>, то имя преобразуется в <literal>/home/foo/foo.txt</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Относительное имя пути, такое как <literal>subdirectory/foo.txt</literal>, преобразуется
      в <literal>currentdirectory/subdirectory/foo.txt</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Абсолютное имя пути, такое как <literal>/main/foo.txt</literal>, которое остаётся
      таким же: <literal>/main/foo.txt</literal>.
     </simpara>
    </listitem>
   </orderedlist>
   Тот же принцип применим и к элементам из пространств имён PHP. Например,
   имя класса может быть указано тремя способами:
   <orderedlist>
    <listitem>
     <simpara>
      Неполные имена (имена классов без префикса), такие как
      <literal>$a = new foo();</literal> или
      <literal>foo::staticmethod();</literal>. Если текущее пространство имён
      <literal>currentnamespace</literal>, то эти имена преобразуются в
      <literal>currentnamespace\foo</literal>. Если код находится в глобальном
      пространстве имён, то имена остаются такими же: <literal>foo</literal>.
     </simpara>
     <simpara>
      Предупреждение: неполные имена для функций и констант будут определяться
      в глобальном пространстве имён, если они не определены в текущем пространстве имён.
      Подробнее в <link linkend="language.namespaces.fallback">Использование пространств
      имён: доступ к глобальным функциям и классам</link>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Полные имена (имена классов с префиксами), такие как
      <literal>$a = new subnamespace\foo();</literal> или
      <literal>subnamespace\foo::staticmethod();</literal>. Если текущее пространство имён
      <literal>currentnamespace</literal>, то эти имена преобразуются в
      <literal>currentnamespace\subnamespace\foo</literal>. Если
      код находится в глобальном пространстве имён, то имена преобразуются в <literal>subnamespace\foo</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Абсолютные имена или имена с предшествующим префиксом, обозначающим глобальное
      пространство. <literal>$a = new \currentnamespace\foo();</literal> или
      <literal>\currentnamespace\foo::staticmethod();</literal>. Имена всегда
      определяются так же, как и записаны: <literal>currentnamespace\foo</literal>.
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <para>
   Ниже приведён пример трёх вариантов синтаксиса в реальном коде:
   <informalexample>
    <simpara>file1.php</simpara>
    <programlisting role="php">
<![CDATA[
<?php
namespace Foo\Bar\subnamespace;

const FOO = 1;
function foo() {}
class foo
{
    static function staticmethod() {}
}
?>
]]>
    </programlisting>
    <simpara>file2.php</simpara>
    <programlisting role="php">
<![CDATA[
<?php
namespace Foo\Bar;
include 'file1.php';

const FOO = 2;
function foo() {}
class foo
{
    static function staticmethod() {}
}

/* Неполные имена */
foo(); // определяется как функция Foo\Bar\foo
foo::staticmethod(); // определяется как класс Foo\Bar\foo с методом staticmethod
echo FOO; // определяется как константа Foo\Bar\FOO

/* Полные имена */
subnamespace\foo(); // определяется как функция Foo\Bar\subnamespace\foo
subnamespace\foo::staticmethod(); // определяется как класс Foo\Bar\subnamespace\foo
                                  // c методом staticmethod
echo subnamespace\FOO; // определяется как константа Foo\Bar\subnamespace\FOO

/* Абсолютные имена */
\Foo\Bar\foo(); // определяется как функция Foo\Bar\foo
\Foo\Bar\foo::staticmethod(); // определяется как класс Foo\Bar\foo с методом staticmethod
echo \Foo\Bar\FOO; // определяется как константа Foo\Bar\FOO
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Обратите внимание, что для доступа к любым глобальным
    классам, функциям или константам, может использоваться абсолютное имя, такое как
    <function>\strlen</function>, или <classname>\Exception</classname>, или
    <literal>\INI_ALL</literal>.
    <example>
     <title>Доступ к глобальным классам, функциям и константам из пространства имён</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace Foo;

function strlen() {}
const INI_ALL = 3;
class Exception {}

$a = \strlen('hi'); // вызывает глобальную функцию strlen
$b = \INI_ALL; // получает доступ к глобальной константе INI_ALL
$c = new \Exception('error'); // Создаёт экземпляр глобального класса Exception
?>
]]>
     </programlisting>
    </example>
   </para>
 </sect1>
 <sect1 xml:id="language.namespaces.dynamic">
  <title>Пространства имён и динамические особенности языка</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   На реализацию пространств имён в PHP повлияли и динамические особенности языка.
   Преобразуем нижеследующий код для использования пространств имён:
   <example>
    <title>Динамически доступные элементы</title>
    <simpara>example1.php:</simpara>
    <programlisting role="php">
<![CDATA[
<?php
class classname
{
    function __construct()
    {
        echo __METHOD__,"\n";
    }
}
function funcname()
{
    echo __FUNCTION__,"\n";
}
const constname = "global";

$a = 'classname';
$obj = new $a; // выводит classname::__construct
$b = 'funcname';
$b(); // выводит funcname
echo constant('constname'), "\n"; // выводит global
?>
]]>
    </programlisting>
   </example>
   Необходимо использовать абсолютное имя (имя класса с префиксом пространства имён).
   Обратите внимание, что нет никакой разницы между полным именем и абсолютным
   внутри динамического имени класса, функции или константы. Начальный обратный
   слеш не является необходимым.
   <example>
    <title>Динамически доступные элементы пространства имён</title>
    <programlisting role="php">
<![CDATA[
<?php
namespace namespacename;
class classname
{
    function __construct()
    {
        echo __METHOD__,"\n";
    }
}
function funcname()
{
    echo __FUNCTION__,"\n";
}
const constname = "namespaced";

include 'example1.php';

$a = 'classname';
$obj = new $a; // выводит classname::__construct
$b = 'funcname';
$b(); // выводит funcname
echo constant('constname'), "\n"; // выводит global

/* обратите внимание, что при использовании двойных кавычек символ обратного слеша должен быть заэкранирован. Например, "\\namespacename\\classname" */
$a = '\namespacename\classname';
$obj = new $a; // выводит namespacename\classname::__construct
$a = 'namespacename\classname';
$obj = new $a; // также выводит namespacename\classname::__construct
$b = 'namespacename\funcname';
$b(); // выводит namespacename\funcname
$b = '\namespacename\funcname';
$b(); // также выводит namespacename\funcname
echo constant('\namespacename\constname'), "\n"; // выводит namespaced
echo constant('namespacename\constname'), "\n"; // также выводит namespaced
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Обязательно прочитайте <link linkend="language.namespaces.faq.quote">примечание об
    экранировании имён пространства имён в строках</link>.
   </para>
 </sect1>
 <sect1 xml:id="language.namespaces.nsconstants">
  <title>Ключевое слово namespace и константа __NAMESPACE__</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   PHP поддерживает два способа доступа к абстрактным элементам в текущем пространстве
   имён таким, как магическая константа <constant>__NAMESPACE__</constant> и ключевое
   слово <literal>namespace</literal>.
  </para>
  <para>
   Значение константы <constant>__NAMESPACE__</constant> — это строка, которая содержит
   имя текущего пространства имён. В глобальном пространстве, вне пространства имён, она
   содержит пустую строку.
   <example>
    <title>Пример использование константы __NAMESPACE__ в коде с пространством имён</title>
    <programlisting role="php">
<![CDATA[
<?php
namespace MyProject;

echo '"', __NAMESPACE__, '"'; // выводит "MyProject"
?>
]]>
    </programlisting>
   </example>
   <example>
    <title>Пример использование константы __NAMESPACE__ в глобальном пространстве</title>
    <programlisting role="php">
<![CDATA[
<?php

echo '"', __NAMESPACE__, '"'; // выводит ""
?>
]]>
     </programlisting>
    </example>
    Константа <constant>__NAMESPACE__</constant> полезна для динамически конструируемых
    имён, например:
    <example>
     <title>использование константы  __NAMESPACE__ для динамического конструирования имени</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace MyProject;

function get($classname)
{
    $a = __NAMESPACE__ . '\\' . $classname;
    return new $a;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Ключевое слово <literal>namespace</literal> может быть использовано для
    явного запроса элемента из текущего пространства имён или из подпространства.
    Это эквивалент оператора <literal>self</literal> для классов в пространстве имён.
    <example>
     <title>Оператор namespace, внутри пространства имён</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace MyProject;

use blah\blah as mine; // смотрите "Использование пространств имён: импорт/создание псевдонима имени"

blah\mine(); // вызывает функцию MyProject\blah\mine()
namespace\blah\mine(); // вызывает функцию MyProject\blah\mine()

namespace\func(); // вызывает функцию MyProject\func()
namespace\sub\func(); // вызывает функцию MyProject\sub\func()
namespace\cname::method(); // вызывает статический метод "method" класса MyProject\cname
$a = new namespace\sub\cname(); // Создаёт экземпляр класса MyProject\sub\cname
$b = namespace\CONSTANT; // присваивает значение константы MyProject\CONSTANT переменной $b
?>
]]>
     </programlisting>
    </example>
    <example>
     <title>Оператор namespace в глобальном коде</title>
     <programlisting role="php">
<![CDATA[
<?php

namespace\func(); // вызывает функцию func()
namespace\sub\func(); // вызывает функцию sub\func()
namespace\cname::method(); // вызывает статический метод "method" класса cname
$a = new namespace\sub\cname(); // Создаёт экземпляр класса sub\cname
$b = namespace\CONSTANT; // присваивает значение константы CONSTANT переменной $b
?>
]]>
    </programlisting>
   </example>
   </para>
 </sect1>

 <sect1 xml:id="language.namespaces.importing">
  <title>Использование пространств имён: импорт/создание псевдонима имени</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Возможность ссылаться на внешнее абсолютное имя по псевдониму или импортированию —
   это важная особенность пространств имён. Это похоже на возможность
   файловых систем unix создавать символические ссылки на файл или директорию.
  </para>
  <para>
   PHP может создавать псевдонимы имени/импортировать константы, функции, классы, интерфейсы, трейты, перечисления и пространства имён.
  </para>
  <para>
   Создание псевдонима имени выполняется с помощью оператора <literal>use</literal>.
   Вот пример, показывающий 5 типов импорта:
   <example>
    <title>импорт/создание псевдонима имени с помощью оператора use</title>
    <programlisting role="php">
<![CDATA[
<?php
namespace foo;
use My\Full\Classname as Another;

// это тоже самое, что и использование My\Full\NSname as NSname
use My\Full\NSname;

// импортирование глобального класса
use ArrayObject;

// импортирование функции
use function My\Full\functionName;

// псевдоним функции
use function My\Full\functionName as func;

// импортирование константы
use const My\Full\CONSTANT;

$obj = new namespace\Another; // создаёт экземпляр класса foo\Another
$obj = new Another; // создаёт объект класса My\Full\Classname
NSname\subns\func(); // вызывает функцию My\Full\NSname\subns\func
$a = new ArrayObject(array(1)); // создаёт объект класса ArrayObject
// без выражения "use ArrayObject" мы создадим объект класса foo\ArrayObject
func(); // вызывает функцию My\Full\functionName
echo CONSTANT; // выводит содержимое константы My\Full\CONSTANT
?>
]]>
    </programlisting>
   </example>
   Обратите внимание, что для имён в пространстве имён (абсолютные имена, содержащие
   разделитель пространств имён, такие как <literal>Foo\Bar</literal>, в отличие от
   глобальных имён, которые его не содержат, такие как <literal>FooBar</literal>) нет
   необходимости в начальном обратном слеше (\) и его присутствие там не рекомендуется, так
   как импортируемые имена должны быть абсолютными и не обрабатываются
   относительно текущего пространства имён.
  </para>
  <para>
   PHP дополнительно поддерживает удобное сокращение для задания нескольких операторов
   use в одной и той же строке
   <example>
    <title>импорт/создание псевдонима имени с помощью оператора use, комбинирование нескольких операторов use</title>
    <programlisting role="php">
<![CDATA[
<?php
use My\Full\Classname as Another, My\Full\NSname;

$obj = new Another; // создаёт объект класса My\Full\Classname
NSname\subns\func(); // вызывает функцию My\Full\NSname\subns\func
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Импорт выполняется во время компиляции и поэтому не влияет на имена динамических классов,
    функций или констант.
    <example>
     <title>Импорт и динамические имена</title>
     <programlisting role="php">
<![CDATA[
<?php
use My\Full\Classname as Another, My\Full\NSname;

$obj = new Another; // создаёт объект класса My\Full\Classname
$a = 'Another';
$obj = new $a;      // создаёт объект класса Another
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    В дополнение, импорт распространяется только на неполные и полные имена. Абсолютные
    имена не затрагиваются операцией импорта.
    <example>
     <title>Импортирование и абсолютные имена</title>
     <programlisting role="php">
<![CDATA[
<?php
use My\Full\Classname as Another, My\Full\NSname;

$obj = new Another; // создаёт объект класса My\Full\Classname
$obj = new \Another; // создаёт объект класса Another
$obj = new Another\thing; // создаёт объект класса My\Full\Classname\thing
$obj = new \Another\thing; // создаёт объект класса Another\thing
?>
]]>
     </programlisting>
    </example>
   </para>
   <sect2 xml:id="language.namespaces.importing.scope">
    <title>Обзор правил для импорта</title>
    <para>
     Ключевое слово <literal>use</literal> должно быть указано в самом начале файла (в
     глобальной области) или внутри объявления пространства имён. Это необходимо потому, что
     импорт выполняется во время компиляции, а не во время исполнения, поэтому оно не может
     быть заключено в блок. Следующий пример показывает недопустимое применение
     ключевого слова <literal>use</literal>:
    </para>
    <para>
     <example>
      <title>Недопустимое правило импорта</title>
      <programlisting role="php">
<![CDATA[
<?php
namespace Languages;

function toGreenlandic()
{
    use Languages\Danish;

    //...
}
?>
]]>
      </programlisting>
     </example>
    </para>
    <note>
     <para>
      Правила импорта задаются на каждый файл отдельно. Это означает, что
      присоединяемые файлы <emphasis>НЕ</emphasis> будут наследовать правила импорта
      из родительского файла.
     </para>
    </note>
   </sect2>
   <sect2 xml:id="language.namespaces.importing.group">
    <title>Описание группирования в одном операторе <literal>use</literal></title>
    <para>
     Классы, функции и константы, импортируемые из
     одного и того же &namespace;, могут группироваться в одном операторе &use.namespace;.
    </para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

use some\namespace\ClassA;
use some\namespace\ClassB;
use some\namespace\ClassC as C;

use function some\namespace\fn_a;
use function some\namespace\fn_b;
use function some\namespace\fn_c;

use const some\namespace\ConstA;
use const some\namespace\ConstB;
use const some\namespace\ConstC;

// Эквивалентно следующему групповому использованию
use some\namespace\{ClassA, ClassB, ClassC as C};
use function some\namespace\{fn_a, fn_b, fn_c};
use const some\namespace\{ConstA, ConstB, ConstC};
]]>
     </programlisting>
    </informalexample>
   </sect2>
 </sect1>
 <sect1 xml:id="language.namespaces.global">
  <title>Глобальное пространство</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Без определения пространства имён, определения всех классов и функций
   находятся в глобальном пространстве — так же, как это было в PHP до введения
   пространств имён. Добавление префикса <literal>\</literal> к именам означает, что
   это имя должно находиться в глобальном пространстве, даже если вы находитесь в
   контексте определённого пространства имён.
   <example>
    <title>Использование глобального пространства и его задание</title>
    <programlisting role="php">
<![CDATA[
<?php
namespace A\B\C;

/* Эта функция является A\B\C\fopen */
function fopen() {
     /* ... */
     $f = \fopen(...); // вызов глобальной функции fopen
     return $f;
}
?>
]]>
    </programlisting>
   </example>
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.fallback">
  <title>Использование пространств имён: переход к глобальной функции/константе</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Когда внутри пространства имён PHP встречает неполное имя класса, функции или
   константы, он преобразовывает эти имена с разными приоритетами. Имена классов всегда
   преобразуются к текущему имени пространства имён. Таким образом, чтобы получить доступ
   ко внутреннему классу или пользовательскому классу вне пространства имён, необходимо
   ссылаться по их абсолютному имени. Например:
   <example>
    <title>Доступ к глобальным классам внутри пространства имён</title>
    <programlisting role="php">
<![CDATA[
<?php
namespace A\B\C;
class Exception extends \Exception {}

$a = new Exception('hi'); // $a — это объект класса A\B\C\Exception
$b = new \Exception('hi'); // $b — это объект класса Exception

$c = new ArrayObject; // фатальная ошибка, класс A\B\C\ArrayObject не найден
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Для функций и констант, PHP будет прибегать к глобальным функциям или константам,
   если функция или константа не существует в пространстве имён.
   <example>
    <title>Необходимость прибегнуть к глобальным функциям/константам внутри пространства имён</title>
    <programlisting role="php">
<![CDATA[
<?php
namespace A\B\C;

const E_ERROR = 45;
function strlen($str)
{
    return \strlen($str) - 1;
}

echo E_ERROR, "\n"; // выводит 45
echo INI_ALL, "\n"; // выводит 7  — прибегнет к глобальной INI_ALL

echo strlen('hi'), "\n"; // выводит "1"
if (is_array('hi')) { // выводит строку "это не массив"
    echo "это массив\n";
} else {
    echo "это не массив\n";
}
?>
]]>
     </programlisting>
    </example>
   </para>
 </sect1>

 <sect1 xml:id="language.namespaces.rules">
  <title>Правила разрешения имён</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Для этих правил здесь приведены несколько важных определений:
   <variablelist>
    <title>Определения имени пространства имён</title>
    <varlistentry>
     <term>Неполное имя</term>
     <listitem>
      <para>
       Это идентификатор без разделителя пространств имён, например, <literal>Foo</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Полное имя</term>
     <listitem>
      <para>
       Это идентификатор с разделителем пространств имён, например, <literal>Foo\Bar</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Абсолютное имя</term>
     <listitem>
      <para>
       Это идентификатор с разделителем пространств имён, который начинается с разделителя пространств имён,
       например, <literal>\Foo\Bar</literal>. Пространство имён <literal>\Foo</literal>
       также является абсолютным именем.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Относительное имя</term>
     <listitem>
      <para>
       Это идентификатор, начинающийся с <literal>namespace</literal>, такой как
       <literal>namespace\Foo\Bar</literal>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
  <para>
   Имена разрешаются согласно следующим правилам:
   <orderedlist>
    <listitem>
     <simpara>
      Абсолютные имена всегда разрешаются без ведущего разделителя пространства имён.
      Например, <literal>\A\B</literal> разрешается в <literal>A\B</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Относительные имена всегда разрешаются в имена с заменой <literal>namespace</literal>
      на текущее пространство имён. Если имя встречается в глобальном пространстве имён,
      префикс <literal>namespace\</literal> просто удаляется. К примеру
      <literal>namespace\A</literal> внутри пространства имён <literal>X\Y</literal> разрешается
      в <literal>X\Y\A</literal>. То же самое имя в глобальном пространстве имён разрешается в
      <literal>A</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      В полных именах первый сегмент преобразовывается согласно текущей таблице
      импорта класса или пространства имён. Например, если пространство имён <literal>A\B\C</literal>
      импортировано как <literal>C</literal>, то имя <literal>C\D\E</literal> преобразуется
      в <literal>A\B\C\D\E</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      В полных именах, если не применяется правило импорта, текущее пространство имён добавляется к имени.
      Например, имя <literal>C\D\E</literal> внутри пространства имён <literal>A\B</literal>,
      преобразуется в <literal>A\B\C\D\E</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Неполные имена преобразовываются согласно текущей таблице импорта в зависимости от типа
      элемента. Это означает, что имена классов преобразовываются согласно таблице импорта классов,
      имена функций — согласно таблице импорта функций, а константы согласно таблице импорта
      констант. К примеру, после <literal>use A\B\C;</literal>, вызов <literal>new C()
      </literal> разрешается как <literal>A\B\C()</literal>. Аналогично, после
      <literal>use function A\B\foo;</literal>, вызов <literal>foo()</literal> разрешается
      как <literal>A\B\foo</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Неполные имена, если отсутствуют ограничения в таблице импорта и если они используются
      как класс, то они разрешаются с префиксом текущего пространства имён. Например,
      <literal>new C()</literal> внутри пространства имён <literal>A\B</literal> разрешаются как
      <literal>A\B\C</literal>.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Неполные имена, если правило импорта не применяется, имя относится к функции или константе,
      а код находится за пределами глобального пространства имён,
      разрешаются во время выполнения. Например код, в пространстве имён <literal>A\B</literal>,
      вызывающий функцию <literal>foo()</literal>, разрешается так:
     </simpara>
     <orderedlist>
      <listitem>
       <simpara>
        Выполняется поиск функции из текущего пространства имён:
        <literal>A\B\foo()</literal>.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        PHP пытается найти и вызвать функцию <literal>foo()</literal>
        из <emphasis>глобального пространства имён</emphasis>.
       </simpara>
      </listitem>
     </orderedlist>
    </listitem>
   </orderedlist>
  </para>
  <example>
   <title>Примеры разрешения имён</title>
   <programlisting role="php">
<![CDATA[
<?php
namespace A;
use B\D, C\E as F;

// вызовы функций

foo();      // сперва пытается вызвать foo, определённую в пространстве имён A,
            // затем вызывает глобальную функцию foo

\foo();     // вызывает функцию foo, определённую в глобальном пространстве

my\foo();   // вызывает функцию foo, определённую в пространстве A\my

F();        // сперва пытается вызвать F, определённую в пространстве имён A,
            // затем вызывает глобальную функцию F

// ссылки на классы

new B();    // создаёт объект класса B, определённого в пространстве имён A.
            // если не найден, то пытается сделать автозагрузку класса A\B

new D();    // используя правила импорта, создаёт объект класса D, определённого в пространстве имён B
            // если не найден, то пытается сделать автозагрузку класса B\D

new F();    // используя правила импорта, создаёт объект класса E, определённого в пространстве имён C
            // если не найден, то пытается сделать автозагрузку класса C\E

new \B();   // создаёт объект класса B, определённого в глобальном пространстве,
            // если не найден, то пытается сделать автозагрузку класса B

new \D();   // создаёт объект класса D, определённого в глобальном пространстве,
            // если не найден, то пытается сделать автозагрузку класса D

new \F();   // создаёт объект класса F, определённого в глобальном пространстве,
            // если не найден, то пытается сделать автозагрузку класса F

// статические методы/функции пространства имён из другого пространства имён

B\foo();    // вызывает функцию foo из пространства имён A\B

B::foo();   // вызывает метод foo из класса B, определённого в пространстве имён A
            // если класс A\B не найден, то пытается сделать автозагрузку класса A\B

D::foo();   // используя правила импорта, вызывает метод foo класса D, определённого в пространстве имён B
            // если класс B\D не найден, то пытается сделать автозагрузку класса B\D

\B\foo();   // вызывает функцию foo из пространства имён B

\B::foo();  // вызывает метод foo класса B из глобального пространства
            // если класс B не найден, то пытается сделать автозагрузку класса B

// статические методы/функции пространства имён из текущего пространства имён

A\B::foo();   // вызывает метод foo класса B из пространства имён A\A
              // если класс A\A\B не найден, то пытается сделать автозагрузку класса A\A\B

\A\B::foo();  // вызывает метод foo класса B из пространства имён A
              // если класс A\B не найден, то пытается сделать автозагрузку класса A\B
?>
]]>
    </programlisting>
   </example>
 </sect1>
 <sect1 xml:id="language.namespaces.faq">
  <title>Часто задаваемые вопросы (FAQ): вещи, которые необходимо знать о пространствах имён</title>
  <?phpdoc print-version-for="namespaces"?>
  <para>
   Этот список вопросов разделён на две части: общие вопросы и некоторые особенности
   реализации, которые полезны для более полного понимания.
  </para>
  <para>
   Сперва, общие вопросы.
   <orderedlist>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.shouldicare">Если в коде не указаны пространства имён, следует
       ли считать что-либо из этого важным?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.globalclass">Как использовать внутренние или глобальные
       классы в пространстве имён?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.innamespace">Как мне использовать функции классов в
       пространствах имён, или константы в их собственном пространстве имён?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.full">
       Как такое имя как <literal>\my\name</literal> или <literal>\name</literal>
       преобразуется?
      </link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.qualified">Как такое имя, как
       <literal>my\name</literal> преобразуется?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.shortname1">Как неполное имя класса
       такое как <literal>name</literal> преобразуется?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.shortname2">Как неполное имя функции
       или неполное имя константы наподобие <literal>name</literal> преобразуется?</link>
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <para>
   Некоторые детали реализации пространств имён, которые
   полезно понимать.
   <orderedlist>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.conflict">Импортируемые имена не должны конфликтовать с
       классами, определёнными в том же файле.</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.nested">Вложенные пространства имён недопустимы.
      </link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.quote">Динамические имена пространств имён (идентификаторы,
       взятые в кавычки) должны экранировать символ обратного слеша.</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.constants">Ссылаться на неопределённые константы,
       используя обратный слеш, нельзя. Выводится фатальная ошибка</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.builtinconst">Невозможно переопределить специальные
       константы &null;, &true; или &false;</link>
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <sect2 xml:id="language.namespaces.faq.shouldicare">
   <title>Если в коде не указаны пространства имён, нужно ли считать что-либо из этого важным?</title>
   <para>
    Нет, пространства имён никак не влияют ни на существующий код,
    ни на ещё ненаписанный код без пространств имён. Можно
    написать такой код, если нужно:
   </para>
   <para>
    <example>
     <title>Доступ к глобальным классам вне пространства имён</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = new \stdClass;
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Это функционально эквивалентно следующему:
   </para>
   <para>
    <example>
     <title>Доступ к глобальным классам вне пространства имён</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = new stdClass;
?>
]]>
      </programlisting>
     </example>
    </para>
   </sect2>
   <sect2 xml:id="language.namespaces.faq.globalclass">
    <title>Как обращаться к внутренним или глобальным классам в пространстве имён?</title>
    <para>
     <example>
      <title>Доступ ко внутренним классам в пространствах имён</title>
      <programlisting role="php">
<![CDATA[
<?php
namespace foo;
$a = new \stdClass;

function test(\ArrayObject $parameter_type_example = null) {}

$a = \DirectoryIterator::CURRENT_AS_FILEINFO;

// расширение внутреннего или глобального класса
class MyException extends \Exception {}
?>
]]>
      </programlisting>
     </example>
    </para>
   </sect2>
   <sect2 xml:id="language.namespaces.faq.innamespace">
    <title>
     Как использовать функции классов в пространствах имён или
     константы в их собственном пространстве имён?
    </title>
    <para>
     <example>
      <title>Доступ ко внутренним классам, функциям или константам в пространствах имён</title>
      <programlisting role="php">
<![CDATA[
<?php
namespace foo;

class MyClass {}

// использование класса из текущего пространства имен в качестве типа параметра
function test(MyClass $parameter_type_example = null) {}
// другой способ использовать класс из текущего пространства имен в качестве типа параметра
function test(\foo\MyClass $parameter_type_example = null) {}

// расширение класса из текущего пространства имён
class Extended extends MyClass {}

// доступ к глобальной функции
$a = \globalfunc();

// доступ к глобальной константе
$b = \INI_ALL;
?>
]]>
      </programlisting>
     </example>
    </para>
   </sect2>
   <sect2 xml:id="language.namespaces.faq.full">
    <title>
     Как имена вроде <literal>\my\name</literal> или <literal>\name</literal>
     преобразовываются?
    </title>
    <para>
     Имена, которые начинаются с <literal>\</literal>, всегда преобразовываются к тому, как
     они выглядят, т. е. <literal>\my\name</literal> — это на самом деле <literal>my\name</literal>,
     а <literal>\Exception</literal> — это <literal>Exception</literal>.
     <example>
      <title>Абсолютные имена</title>
      <programlisting role="php">
<![CDATA[
<?php
namespace foo;
$a = new \my\name(); // создаёт экземпляр класса my\name
echo \strlen('hi'); // вызывает функцию strlen
$a = \INI_ALL; // переменной $a присваивается значение константы INI_ALL
?>
]]>
      </programlisting>
     </example>
    </para>
   </sect2>
   <sect2 xml:id="language.namespaces.faq.qualified">
    <title>Как имя <literal>my\name</literal> преобразуется?</title>
    <para>
     Имена, которые содержат обратный слеш, но не начинаются с него, такие как
     <literal>my\name</literal> могут быть преобразованы двумя способами.
    </para>
    <para>
     Если присутствует
     импортирующее выражение, которое создаёт синоним <literal>my</literal> другого имени, то
     этот синоним применяется к <literal>my</literal> в <literal>my\name</literal>.
    </para>
    <para>
     В ином случае, текущее имя пространства имён становится префиксом к <literal>my\name</literal>.
    </para>
    <para>
     <example>
      <title>Полные имена</title>
      <programlisting role="php">
<![CDATA[
<?php
namespace foo;
use blah\blah as foo;

$a = new my\name(); // создаёт экземпляр класса foo\my\name
foo\bar::name(); // вызывает статический метод name в классе blah\blah\bar
my\bar(); // вызывает функцию foo\my\bar
$a = my\BAR; // присваивает переменной $a значение константы foo\my\BAR
?>
]]>
      </programlisting>
     </example>
    </para>
   </sect2>
   <sect2 xml:id="language.namespaces.faq.shortname1">
    <title>Как неполное имя класса вроде <literal>name</literal> преобразовывается?</title>
    <para>
     Имена классов, которые не содержат обратный слеш, например,
     <literal>name</literal> могут быть преобразованы двумя способами.
    </para>
    <para>
     Если присутствует
     импортирующее выражение, которое создаёт синоним <literal>name</literal> другого имени, то
     применяется этот синоним.
    </para>
    <para>
     В ином случае, текущее имя пространства имён становится префиксом к <literal>name</literal>.
    </para>
    <para>
     <example>
      <title>Неполные имена классов</title>
      <programlisting role="php">
<![CDATA[
<?php
namespace foo;
use blah\blah as foo;

$a = new name(); // создаёт экземпляр класса foo\name
foo::name(); // вызывает статический метод name в классе blah\blah
?>
]]>
      </programlisting>
     </example>
    </para>
   </sect2>
   <sect2 xml:id="language.namespaces.faq.shortname2">
    <title>Как неполное имя функции или неполное имя константы, например,
     <literal>name</literal> преобразовывается?
    </title>
    <para>
     Имена функций или констант, которые не содержат обратного слеша, например,
     <literal>name</literal> могут быть преобразованы двумя способами.
    </para>
    <para>
     Сперва текущее имя пространства имён становится префиксом к <literal>name</literal>.
    </para>
    <para>
     Затем, если константа или функция <literal>name</literal> не существует
     в текущем пространстве имён, будет использована глобальная константа или функция <literal>name</literal>,
     если она существует.
    </para>
    <para>
     <example>
      <title>Неполные имена функций или констант</title>
      <programlisting role="php">
<![CDATA[
<?php
namespace foo;
use blah\blah as foo;

const FOO = 1;

function my() {}
function foo() {}
function sort(&$a)
{
    \sort($a); // вызывает глобальную функцию sort
    $a = array_flip($a);
    return $a;
}

my(); // вызывает foo\my
$a = strlen('hi'); // вызывает глобальную функцию strlen, потому что foo\strlen не существует
$arr = array(1,3,2);
$b = sort($arr); // вызывает функцию foo\sort
$c = foo(); // вызывает функцию foo\foo — импорт не применяется

$a = FOO; // присваивает переменной $a значение константы «foo\FOO» — импорт не применяется
$b = INI_ALL; // присваивает переменной $b значение глобальной константы INI_ALL
?>
]]>
      </programlisting>
     </example>
    </para>
   </sect2>
   <sect2 xml:id="language.namespaces.faq.conflict">
    <title>Импортируемые имена не должны конфликтовать с классами, определёнными в том же файле.</title>
    <para>
     Следующие комбинации скриптов допустимы:
     <informalexample>
      <simpara>file1.php</simpara>
      <programlisting role="php">
<![CDATA[
<?php
namespace my\stuff;
class MyClass {}
?>
]]>
      </programlisting>
      <simpara>another.php</simpara>
      <programlisting role="php">
<![CDATA[
<?php
namespace another;
class thing {}
?>
]]>
     </programlisting>
     <simpara>file2.php</simpara>
     <programlisting role="php">
<![CDATA[
<?php
namespace my\stuff;
include 'file1.php';
include 'another.php';

use another\thing as MyClass;
$a = new MyClass; // создаёт экземпляр класса thing из пространства имён another
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Конфликт имён отсутствует даже несмотря на то, что класс <literal>MyClass</literal> существует
    внутри пространства имён <literal>my\stuff</literal>, потому что определение MyClass
    находится в отдельном файле. Однако следующий пример приводит к фатальной ошибке с конфликтом
    имён, потому что класс MyClass определён в том же файле, где находится оператор use.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
namespace my\stuff;
use another\thing as MyClass;
class MyClass {} // фатальная ошибка: MyClass конфликтует с выражением импорта
$a = new MyClass;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   </sect2>
   <sect2 xml:id="language.namespaces.faq.nested">
    <title>Вложенные пространства имён недопустимы.</title>
    <para>
     PHP не разрешает вложение пространств имён одно в другое
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
namespace my\stuff {
    namespace nested {
        class foo {}
    }
}
?>
]]>
      </programlisting>
     </informalexample>
     Однако, можно сымитировать вложенные пространства имён так:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
namespace my\stuff\nested {
    class foo {}
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   </sect2>
   <sect2 xml:id="language.namespaces.faq.quote">
    <title>Динамические имена пространств имён (идентификаторы, взятые в кавычки) должны экранировать символ обратного слеша.</title>
    <para>
     Важно понимать это, потому что обратный слеш внутри строк работает как экранирующий символ.
     Он всегда должен быть продублирован, когда указан внутри строки, иначе
     появляется риск неумышленных последствий:
     <example>
      <title>Подводные камни при указании имени пространства имён внутри строки с двойными кавычками</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = "dangerous\name"; // \n — это переход на новую строку внутри строки с двойными кавычками!
$obj = new $a;

$a = 'not\at\all\dangerous'; // а тут нет проблем.
$obj = new $a;
?>
]]>
      </programlisting>
     </example>
     Внутри строк, заключённых в одинарные кавычки, обратный слеш в качестве разделителя более безопасен, но
     по-прежнему рекомендуемая практика экранирования обратного слеша во всех строках является наилучшим вариантом.
    </para>
   </sect2>
   <sect2 xml:id="language.namespaces.faq.constants">
    <title>Ссылаться на неопределённые константы, используя обратный слеш, нельзя. Выводится фатальная ошибка</title>
    <para>
     Любая неопределённая константа — неполное имя наподобие <literal>FOO</literal> — будет
     приводить к выводу сообщения о том, что PHP предположил, что <literal>FOO</literal> было значение
     константы. Любая константа, с полным или абсолютным именем, которая содержит
     символ обратного слеша будет приводить к фатальной ошибке, если не будет найдена.
     <example>
      <title>Неопределённые константы</title>
      <programlisting role="php">
<![CDATA[
<?php
namespace bar;
$a = FOO; // выводит предупреждение: undefined constants "FOO" assumed "FOO";
$a = \FOO; // фатальная ошибка: undefined namespace constant FOO
$a = Bar\FOO; // фатальная ошибка: undefined namespace constant bar\Bar\FOO
$a = \Bar\FOO; // фатальная ошибка: undefined namespace constant Bar\FOO
?>
]]>
      </programlisting>
     </example>
    </para>
   </sect2>
   <sect2 xml:id="language.namespaces.faq.builtinconst">
    <title>Невозможно переопределить специальные константы &null;, &true; или &false;</title>
    <para>
     Любая попытка определить константу пространства имён, которая совпадает с названиями специальных встроенных констант,
     приведёт к фатальной ошибке.
     <example>
      <title>Неопределённые константы</title>
      <programlisting role="php">
<![CDATA[
<?php
namespace bar;
const NULL = 0; // Фатальная ошибка;
const true = 'stupid'; // также фатальная ошибка;
// и т. д.
?>
]]>
      </programlisting>
     </example>
    </para>
   </sect2>
 </sect1>
</chapter>
<!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"~/.phpdoc/manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 vim600: syn=xml fen fdm=syntax fdl=2 si
 vim: et tw=78 syn=sgml
 vi: ts=1 sw=1
-->
