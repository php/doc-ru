<?xml version="1.0" encoding="UTF-8"?>
<!-- EN-Revision: 3e57d6ccfdd9e474227c60e0773a3c7d1ecb9536 Maintainer: shein Status: ready -->
<!-- Reviewed: no -->
<!-- $Revision$ -->
 <chapter xml:id="language.variables" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Переменные</title>
  
  <sect1 xml:id="language.variables.basics">
   <title>Основы</title>

   <simpara>
    Переменные в PHP представлены знаком доллара с последующим
    именем переменной. Имя переменной чувствительно к регистру.
   </simpara>

   <para>
    Имена переменных соответствуют тем же правилам, что и
    остальные наименования в PHP. Правильное имя переменной должно
    начинаться с буквы или символа подчеркивания с последующими в
    любом количестве буквами, цифрами или символами подчеркивания
    Это можно отобразить регулярным выражением:
    '<literal>[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*</literal>'
   </para>
   
   <note>
    <simpara>
     Для наших целей буквы здесь - это a-z, A-Z, и байты от
     127 до 255 (<literal>0x7f-0xff</literal>).
    </simpara>
   </note>

   <note>
    <simpara>
     <literal>$this</literal> - это особая переменная, которой
     нельзя ничего присваивать.
    </simpara>
   </note>

   &tip.userlandnaming;

   <para>
    Для информации о функциях работы с переменными, обращайтесь
    к разделу
    <link linkend="ref.var">функций работы с переменными</link>.
   </para>

   <para>
    <informalexample>
     <programlisting role="php"> 
<![CDATA[
<?php
$var = 'Bob';
$Var = 'Joe';
echo "$var, $Var";      // выведет "Bob, Joe"

$4site = 'not yet';     // неверно; начинается с цифры
$_4site = 'not yet';    // верно; начинается с символа подчеркивания
$täyte = 'mansikka';    // верно; 'ä' это (Расширенный) ASCII 228.
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <para>
    По умолчанию, переменные всегда присваиваются по значению. То есть,
    когда вы присваиваете выражение переменной, все значение
    оригинального выражения копируется в эту переменную. Это
    означает, к примеру, что после присвоения одной переменной
    значения другой, изменение одной из них не влияет на значение
    другой. Дополнительную информацию об этом способе присвоения
    смотрите в разделе <link
    linkend="language.expressions">Выражения</link>.
   </para>
   <para>
    PHP также предлагает иной способ присвоения значений переменным:
    <link linkend="language.references">присвоение по ссылке</link>. 
    Это означает, что новая переменная просто ссылается (иначе говоря,
    "становится псевдонимом" или "указывает") на оригинальную
    переменную. Изменения в одной переменной отражаются на оригинале,
    и наоборот.
   </para>
   <para>
    Для присвоения по ссылке, просто добавьте амперсанд (&amp;) к
    началу имени присваиваемой (исходной) переменной. Например,
    следующий фрагмент кода дважды выводит '<literal>Меня зовут Боб</literal>':

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 'Боб';              // Присваивает $foo значение 'Боб'
$bar = &$foo;              // Ссылка на $foo через $bar.
$bar = "Меня зовут $bar";  // Изменение $bar...
echo $bar;
echo $foo;                 // меняет и $foo.
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <para>
    Важно отметить, что по ссылке могут быть присвоены только
    именованные переменные.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 25;
$bar = &$foo;      // Это верное присвоение.
$bar = &(24 * 7);  // Неверно; ссылка на неименованное выражение.

function test()
{
   return 25;
}

$bar = &test();    // Неверно.
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <para>
    Хотя в PHP и нет необходимости инициализировать переменные, это
    считается очень хорошей практикой. Неинициализированные переменные
    принимают значение по умолчанию в зависимости от их типа, который
    определяется из контекста их первого использования: булевые
    принимают значение &false;, целые и числа с плавающей точкой -
    ноль, строки (например, при использовании в <function>echo</function>)
    - пустую строку, а массивы становятся пустыми массивами.
   </para>
   <para>
    <example>
     <title>Значения по умолчанию в неинициализированных переменных</title>
     <programlisting role="php">
<![CDATA[
<?php
// Неустановленная И не имеющая ссылок (т.е. без контекста использования) переменная; выведет NULL
var_dump($unset_var);

// Булевое применение; выведет 'false' (Подробнее по этому синтаксису смотрите раздел о тернарном операторе)
echo($unset_bool ? "true\n" : "false\n");

// Строковое использование; выведет 'string(3) "abc"'
$unset_str .= 'abc';
var_dump($unset_str);

// Целочисленное использование; выведет 'int(25)'
$unset_int += 25; // 0 + 25 => 25
var_dump($unset_int);

// Использование в качестве числа с плавающей точкой (float/double); выведет 'float(1.25)'
$unset_float += 1.25;
var_dump($unset_float);

// Использование в качестве массива; выведет array(1) {  [3]=>  string(3) "def" }
$unset_arr[3] = "def"; // array() + array(3 => "def") => array(3 => "def")
var_dump($unset_arr);

// Использование в качестве объекта; создает новый объект stdClass (см. http://www.php.net/manual/en/reserved.classes.php)
// Выведет: object(stdClass)#1 (1) {  ["foo"]=>  string(3) "bar" }
$unset_obj->foo = 'bar';
var_dump($unset_obj);
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Полагаться на значения по умолчанию неинициализированных переменных -
    довольно проблематично в случае включения одного файла в другой файл,
    использующий одноименные переменные. Это также большой <link
    linkend="security.globals">риск в системе безопасности</link> при
    включенной опции <link linkend="ini.register-globals">register_globals</link>.
    В случае работы с неинициализированной переменной вызывается ошибка уровня
    <link linkend="errorfunc.constants.errorlevels.e-notice">E_NOTICE</link>,
    за исключением случая добавления элементов в неинициализированный массив.
    Для обнаружения инициализации переменной может быть использована
    языковая конструкция <function>isset</function>.
   </para>
  </sect1>

  <sect1 xml:id="language.variables.predefined">
   <title>Предопределенные переменные</title>
   
   <simpara>
    Любому запускаемому скрипту PHP предоставляет большое количество
    предопределенных переменных. Однако, многие из этих переменных не
    могут быть полностью задокументированы, поскольку они зависят от
    запущенного сервера, его версии и настроек, а также других факторов.
    Некоторые из этих переменных не доступны, когда PHP запущен из
    <link linkend="features.commandline">командной строки</link>.
    Перечень этих переменных смотрите в разделе
    <link linkend="reserved.variables">Зарезервированные
    предопределенные переменные</link>.
   </simpara>

   <warning>
    <simpara>
     Начиная с PHP 4.2.0, значение директивы <link
     linkend="ini.register-globals">register_globals</link> по умолчанию
     установлено в <emphasis>off</emphasis> (отключено). Это большое изменение
     в PHP. Положение register_globals в <emphasis>off</emphasis> изменяет
     набор глобальных предопределенных переменных.
     Например, чтобы получить <varname>DOCUMENT_ROOT</varname>, вам необходимо
     будет использовать <varname>$_SERVER['DOCUMENT_ROOT']</varname> вместо
     <varname>$DOCUMENT_ROOT</varname>, или <varname>$_GET['id']</varname> из
     URL <literal>http://www.example.com/test.php?id=3</literal> вместо
     <varname>$id</varname>, или <varname>$_ENV['HOME']</varname> вместо
     <varname>$HOME</varname>.
    </simpara>
    <simpara>
     Дополнительную информацию, связанную с этим изменением, вы можете
     получить, прочитав описание
     <link linkend="ini.register-globals">register_globals</link> в разделе о
     настройках, главу о безопасности
     <link linkend="security.globals">Использование Register Globals
     </link>, а также сообщения о выпусках PHP <link xlink:href="&url.php.release4.1.0;">4.1.0
     </link> и <link xlink:href="&url.php.release4.2.0;">4.2.0</link>.
    </simpara>
    <simpara>
     Использование доступных зарезервированных предопределенных переменных
     PHP, таких как
     <link linkend="language.variables.superglobals">суперглобальные массивы</link>, 
     является предпочтительным.
    </simpara>
   </warning>

   <simpara>
    Начиная с версии 4.1.0, PHP предоставляет дополнительный набор
    предопределенных массивов, содержащих переменные web-сервера (если
    они доступны), окружения и пользовательского ввода. Эти новые
    массивы являются особыми, поскольку они становятся глобальными автоматически
    - то есть, автоматически доступны в любой области видимости. По этой
    причине они также известны как 'автоглобальные' или 'суперглобальные'
    переменные. (В PHP нет механизма определяемых пользователем
    суперглобальных переменных.) Суперглобальные переменные перечислены
    ниже; однако, перечисление их содержимого и дальнейшее обсуждение
    предопределенных переменных PHP и их сути смотрите в разделе
    <link linkend="reserved.variables">Зарезервированные
    предопределенные переменные</link>. Также вы заметите, что старые 
    предопределенные переменные (<varname>$HTTP_*_VARS</varname>) всё
    еще существуют.

    &avail.register-long-arrays;
   </simpara>
   
   <note>
    <title>Переменные переменных</title>
    <para>
     Суперглобальные переменные не могут быть
     <link linkend="language.variables.variable">переменными переменных</link>.
    </para>
   </note>

   <note>
    <para>
     Суперглобальные переменные и <literal>HTTP_*_VARS</literal> могут сосуществовать
     вместе; они не идентичны, поэтому изменение одного массива никак не повлияет
     на другой.
    </para>
   </note>

   <para>
    Если некоторые из переменных в <link
    linkend="ini.variables-order">variables_order</link> не установлены,
    соответствующие им предопределенные массивы также останутся пустыми.
   </para>
  </sect1>


  <sect1 xml:id="language.variables.scope">
   <title>Область видимости переменной</title>

   <simpara>
    Область видимости переменной - это среда, в которой она определена.
    В большинстве случаев все переменные PHP имеют единую область
    видимости. Эта единая область видимости охватывает также
    включаемые (include) и требуемые (require) файлы. Например:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = 1;
include 'b.inc';
?>
]]>
    </programlisting>
   </informalexample>
   <simpara>
    Здесь переменная <varname>$a</varname> будет доступна внутри
    включенного скрипта <filename>b.inc</filename>. Однако, внутри
    определенных пользователем функций вводится локальная область
    видимости функции. Любая, используемая внутри функции переменная,
    по умолчанию ограничена локальной областью видимости функции.
    Например:
   </simpara>
    
   <informalexample>
    <programlisting role="php"> 
<![CDATA[
<?php
$a = 1; /* глобальная область видимости */ 

function test()
{ 
    echo $a; /* ссылка на переменную локальной области видимости */ 
} 

test();
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    Этот скрипт не сгенерирует никакого вывода, поскольку выражение
    echo указывает на локальную версию переменной
    <varname>$a</varname>, а в пределах этой области видимости ей
    не было присвоено значение. Возможно вы заметили, что это немного
    отличается от языка C в том, что глобальные переменные в C
    автоматически доступны функциям, если только они не были
    перезаписаны локальным определением. Это может вызвать некоторые
    проблемы, поскольку люди могут нечаянно изменить глобальную
    переменную. В PHP, если глобальная переменная будет использоваться
    внутри функции, она должна быть объявлена глобальной внутри нее.
   </simpara>
       
   <sect2 xml:id="language.variables.scope.global">
    <title>Ключевое слово <literal>global</literal></title>
    <simpara>
     Сначала пример использования <literal>global</literal>:
    </simpara>
    <para>
     <example>
      <title>Использование <literal>global</literal></title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = 2;

function Sum()
{
    global $a, $b;

    $b = $a + $b;
} 

Sum();
echo $b;
?>
]]>
      </programlisting>
     </example>
    </para>

   <simpara>
    Вышеприведенный скрипт выведет <literal>3</literal>. После определения
    <varname>$a</varname> и <varname>$b</varname> внутри функции как
    global, все ссылки на любую из этих переменных будут указывать на
    их глобальную версию. Не существует никаких ограничений на
    количество глобальных переменных, которые могут обрабатываться
    функцией.
   </simpara>

   <simpara>
    Второй способ доступа к переменным глобальной области видимости -
    использование специального, определяемого PHP массива
    <varname>$GLOBALS</varname>. Предыдущий пример может быть переписан
    так:
   </simpara>
   <para>
    <example>
     <title>Использование <varname>$GLOBALS</varname> вместо global</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = 2;

function Sum()
{
    $GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];
} 

Sum();
echo $b;
?>
]]>
     </programlisting>
    </example>
   </para>

   <simpara>
    <varname>$GLOBALS</varname> - это ассоциативный массив, ключом
    которого является имя, а значением - содержимое глобальной
    переменной. Обратите внимание, что <varname>$GLOBALS</varname>
    существует в любой области видимости, это объясняется тем, что
    <varname>$GLOBALS</varname> является <link
    linkend="language.variables.superglobals">суперглобальным</link>.
    Ниже приведен пример, демонстрирующий возможности
    суперглобальных переменных:
   </simpara>
   <para>
    <example>
     <title>Суперглобальные переменные и область видимости</title>
     <programlisting role="php">
<![CDATA[
<?php
function test_global()
{
    // Большинство предопределенных переменных не являются
    // "супер", и чтобы быть доступными в локальной области
    // видимости, функции требуют указания 'global'.
    global $HTTP_POST_VARS;
    
    echo $HTTP_POST_VARS['name'];
    
    // Суперглобальные переменные доступны в любой области
    // видимости и не требуют указания 'global'.
    // Суперглобальные переменные доступны, начиная с PHP 4.1.0, а
    // использование HTTP_POST_VARS считается устаревшим.
    echo $_POST['name'];
}
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
 
  <sect2 xml:id="language.variables.scope.static">
   <title>Использование статических (<literal>static</literal>) переменных</title>
   <simpara>
    Другой важной возможностью области видимости переменной является
    <emphasis>статическая</emphasis> переменная. Статическая
    переменная существует только в локальной области видимости
    функции, но не теряет своего значения, когда выполнение программы
    выходит из этой области видимости. Рассмотрим следующий пример:
   </simpara>
   <para>
    <example>
     <title>Демонстрация необходимости статических переменных</title>
     <programlisting role="php">
<![CDATA[
<?php
function test()
{
    $a = 0;
    echo $a;
    $a++;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Эта функция довольно бесполезна, поскольку при каждом вызове она
    устанавливает <varname>$a</varname> в <literal>0</literal> и
    выводит <literal>0</literal>. Инкремент переменной <varname>$a</varname>++
    здесь не играет роли, так как при выходе из функции переменная
    <varname>$a</varname> исчезает. Чтобы написать полезную считающую
    функцию, которая не будет терять текущего значения счетчика,
    переменная <varname>$a</varname> объявляется как static:
   </simpara>
   <para>
    <example>
     <title>Пример использования статических переменных</title>
     <programlisting role="php">
<![CDATA[
<?php
function test()
{
    static $a = 0;
    echo $a;
    $a++;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Теперь <varname>$a</varname> будет проинициализирована только при
    первом вызове функции, а каждый вызов функции <literal>test()</literal>
    будет выводить значение <varname>$a</varname> и инкрементировать его.
   </simpara>

   <simpara>
    Статические переменные также дают возможность работать с
    рекурсивными функциями. Рекурсивной является функция, вызывающая
    саму себя. При написании рекурсивной функции нужно быть
    внимательным, поскольку есть вероятность сделать рекурсию
    бесконечной. Вы должны убедиться, что существует адекватный
    способ завершения рекурсии. Следующая простая функция рекурсивно
    считает до 10, используя для определения момента остановки
    статическую переменную <varname>$count</varname>:
   </simpara>
   <para>
    <example>
     <title>Статические переменные и рекурсивные функции</title>
     <programlisting role="php">
<![CDATA[
<?php
function test()
{
    static $count = 0;

    $count++;
    echo $count;
    if ($count < 10) {
        test();
    }
    $count--;
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <note>
    <para>
      Статические переменные могут быть объявлены так, как показано
      в предыдущем примере. Попытка присвоить этим переменным
      значения, являющиеся результатом выражений, вызовет ошибку
      обработки.
    </para>
    <para>
     <example>
      <title>Объявление статических переменных</title>
      <programlisting role="php">
<![CDATA[
<?php
function foo(){
    static $int = 0;          // верно
    static $int = 1+2;        // неверно  (поскольку это выражение)
    static $int = sqrt(121);  // неверно  (поскольку это тоже выражение)

    $int++;
    echo $int;
}
?>
]]>
      </programlisting>
     </example>
    </para>
   </note>
   <note>
    <para>
     Статические объявления вычисляются во время компиляции скрипта.
    </para>
   </note>
  </sect2>

  <sect2 xml:id="language.variables.scope.references">
   <title>Ссылки с глобальными (<literal>global</literal>) и статическими (<literal>static</literal>) переменными</title>
   <simpara>
    Движок Zend 1, лежащий в основе PHP 4, оперирует
    модификаторами переменных
    <link linkend="language.variables.scope.static">static</link> и
    <link linkend="language.variables.scope.global">global</link> как
    <link linkend="language.references">ссылками</link>. Например, реальная
    глобальная переменная, внедренная в область видимости функции указанием
    ключевого слова <literal>global</literal>, в действительности создает
    ссылку на глобальную переменную. Это может привести к неожиданному
    поведению, как это показано в следующем примере:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function test_global_ref() {
    global $obj;
    $obj = &new stdclass;
}

function test_global_noref() {
    global $obj;
    $obj = new stdclass;
}

test_global_ref();
var_dump($obj);
test_global_noref();
var_dump($obj);
?>
]]>
    </programlisting>
   </informalexample>

   &example.outputs;

   <screen>
NULL
object(stdClass)(0) {
}
   </screen>

   <simpara>
    Аналогично ведет себя и выражение <literal>static</literal>. Ссылки не
    хранятся статично:
   </simpara>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function &get_instance_ref() {
    static $obj;

    echo 'Статический объект: ';
    var_dump($obj);
    if (!isset($obj)) {
        // Присвоить ссылку статической переменной
        $obj = &new stdclass;
    }
    $obj->property++;
    return $obj;
}

function &get_instance_noref() {
    static $obj;

    echo 'Статический объект: ';
    var_dump($obj);
    if (!isset($obj)) {
        // Присвоить объект статической переменной
        $obj = new stdclass;
    }
    $obj->property++;
    return $obj;
}

$obj1 = get_instance_ref();
$still_obj1 = get_instance_ref();
echo "\n";
$obj2 = get_instance_noref();
$still_obj2 = get_instance_noref();
?>
]]>
    </programlisting>
   </informalexample>
   &example.outputs;
   <screen>
Статический объект: NULL
Статический объект: NULL

Статический объект: NULL
Статический объект: object(stdClass)(1) {
  ["property"]=>
  int(1)
}
   </screen>

   <simpara>
    Этот пример демонстрирует, что при присвоении ссылки статической
    переменной она не <emphasis>запоминается</emphasis>, когда вы
    вызываете функцию <literal>&amp;get_instance_ref()</literal> во
    второй раз.
   </simpara>
   </sect2>
  </sect1>

  <sect1 xml:id="language.variables.variable">
   <title>Переменные переменных</title>

   <simpara>
    Иногда бывает удобно иметь переменными имена переменных. То есть,
    имя переменной, которое может быть определено и изменено
    динамически. Обычная переменная определяется примерно таким
    выражением:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = 'hello';
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    Переменная переменной берет значение переменной и рассматривает
    его как имя переменной. В вышеприведенном примере
    <emphasis>hello</emphasis> может быть использовано как имя
    переменной при помощи двух знаков доллара. То есть:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$$a = 'world';
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    Теперь в дереве символов PHP определены и содержатся две
    переменные: <varname>$a</varname>, содержащая "hello", и
    <varname>$hello</varname>, содержащая "world". Таким образом,
    выражение
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo "$a ${$a}";
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    выведет то же, что и
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo "$a $hello";
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    то есть, они оба выведут: <computeroutput>hello world</computeroutput>.
   </simpara>

   <simpara>
    Для того чтобы использовать переменные переменных с массивами, вы
    должны решить проблему двусмысленности. То есть, если вы напишете
    <varname>$$a[1]</varname>, обработчику необходимо знать, хотите ли
    вы использовать <varname>$a[1]</varname> в качестве переменной,
    либо вам нужна как переменная <varname>$$a</varname>, а затем ее
    индекс [1]. Синтаксис для разрешения этой двусмысленности таков:
    <varname>${$a[1]}</varname> для первого случая и
    <varname>${$a}[1]</varname> для второго.
   </simpara>

   <simpara>
    К свойствам класса также можно получить доступ динамически.
    Переменное имя свойства будет разрешено в том контексте, в котором
    произойдет вызов к нему. Например, в случае выражения
    <varname>$foo->$bar</varname>, локальная область видимости
    будет просканирована на наличие переменной <varname>$bar</varname>, значение
    которой будет использовано в качестве имени свойства объекта <varname>$foo</varname>.
    Это также работает и в том случае, если <varname>$bar</varname>
    осуществляет доступ к элементу массива.
   </simpara>

   <para>
    <example>
     <title>Пример переменной функции</title>
      <programlisting role="php">
<![CDATA[
<?php
class foo {
    var $bar = 'I am bar.';
}

$foo = new foo();
$bar = 'bar';
$baz = array('foo', 'bar', 'baz', 'quux');
echo $foo->$bar . "\n";
echo $foo->$baz[1] . "\n";
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
I am bar.
I am bar.
     </screen>
    </example>
   </para>

   <warning>
    <simpara>
     Пожалуйста, обратите внимание, что переменные переменных не могут
     использоваться с
     <link linkend="language.variables.superglobals">Суперглобальными массивами</link>
     PHP. Переменная <literal>$this</literal> также является особой, на нее
     нельзя ссылаться динамически.
    </simpara>
   </warning>
  
  </sect1>

  <sect1 xml:id="language.variables.external">
   <title>Переменные извне PHP</title>
   
   <sect2 xml:id="language.variables.external.form">
    <title>HTML-формы (GET и POST)</title>

    <simpara>
     Когда происходит отправка данных формы PHP-скрипту, информация из
     этой формы автоматически становится доступной ему. Существует
     много способов получения этой информации, например:
    </simpara>

    <para>
     <example>
      <title>Простая HTML-форма</title>
      <programlisting role="html">
<![CDATA[
<form action="foo.php" method="post">
    Имя:  <input type="text" name="username" /><br />
    Email: <input type="text" name="email" /><br />
    <input type="submit" name="submit" value="Отправь меня!" />
</form>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     В зависимости от вашей индивидуальной установки и личных настроек
     существует много способов доступа к данным из ваших HTML-форм. Вот
     несколько примеров:
    </para>

    <!-- FIXME PHP_6 register_long_arrays removal alert -->
    <para>
     <example>
      <title>Доступ к данным из простой HTML POST-формы</title>
      <programlisting role="php">
<![CDATA[
<?php 
// Доступно, начиная с PHP 4.1.0

   echo $_POST['username'];
   echo $_REQUEST['username'];

   import_request_variables('p', 'p_');
   echo $p_username;

// Начиная с PHP 5.0.0, эти длинные предопределенные
// переменные могут быть отключены директивой register_long_arrays.

   echo $HTTP_POST_VARS['username'];

// Доступно, если директива PHP register_globals = on. Начиная
// с PHP 4.2.0, значение по умолчанию register_globals = off.
// Использование/доверие этому методу не рекомендуется.

   echo $username;
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     GET-форма используется аналогично, за исключением того, что вместо
     POST, вам нужно будет использовать соответствующую предопределенную
     переменную GET. GET относится также к <literal>QUERY_STRING</literal>
     (информация в URL после '?'). Так, например,
     <literal>http://www.example.com/test.php?id=3</literal> содержит
     GET-данные, доступные как <varname>$_GET['id']</varname>. Смотрите
     также <varname>$_REQUEST</varname> и <function>import_request_variables</function>.
    </para>

    <note>
     <para>
      <link linkend="language.variables.superglobals">Суперглобальные массивы</link>, 
      такие как <varname>$_POST</varname> и <varname>$_GET</varname>, стали 
      доступны в PHP 4.1.0
     </para>
    </note>

    <note>
     <para>
      Точки и пробелы в именах переменных преобразуется в знаки
      подчеркивания. Например, <literal>&lt;input name="a.b" /&gt;</literal> станет
      <literal>$_REQUEST["a_b"]</literal>.
     </para>
    </note>

    <para>
     Как уже говорилось, до PHP 4.2.0 значением <link
     linkend="ini.register-globals">register_globals</link>
     по умолчанию было <emphasis>on</emphasis> (включено).
     Сообщество PHP рекомендует всем не
     полагаться на эту директиву, поскольку предпочтительно
     присвоить ей значение <emphasis>off</emphasis> и писать программы
     исходя из этого.
    </para>

    <note>
     <para>
      Конфигурационная директива
      <link linkend="ini.magic-quotes-gpc">magic_quotes_gpc</link>
      влияет на значения Get, Post и Cookie. Если она включена,
      значение (It's "PHP!") автоматически станет (It\'s \"PHP!\").
      Экранирование необходимо при добавлении в базу данных. Смотрите
      также <function>addslashes</function>, <function>stripslashes</function>
      и <link linkend="ini.magic-quotes-sybase">magic_quotes_sybase</link>.
     </para>
    </note>
    
    <simpara>
     PHP также понимает массивы в контексте переменных формы
     (смотрите <link linkend="faq.html">соответствующие ЧАВО</link>).
     К примеру, вы можете сгруппировать связанные переменные вместе
     или использовать эту возможность для получения значений списка
     множественного выбора select. Например, давайте отправим форму
     самой себе, а после отправки отобразим данные:
    </simpara>

    <para>
     <example>
      <title>Более сложные переменные формы</title>
      <programlisting role="php">
<![CDATA[
<?php
if ($_POST) {
    echo '<pre>';
    echo htmlspecialchars(print_r($_POST, true));
    echo '</pre>';
}
?>
<form action="" method="post">
    Имя:  <input type="text" name="personal[name]" /><br />
    Email: <input type="text" name="personal[email]" /><br />
    Пиво: <br />
    <select multiple name="beer[]">
        <option value="warthog">Warthog</option>
        <option value="guinness">Guinness</option>
        <option value="stuttgarter">Stuttgarter Schwabenbräu</option>
    </select><br />
    <input type="submit" value="Отправь меня!" />
</form>
]]>
      </programlisting>
     </example>
    </para>

    <sect3 xml:id="language.variables.external.form.submit">
     <title>Имена переменных кнопки-изображения</title>

     <simpara>
      При отправке формы вместо стандартной кнопки можно использовать
      изображение с помощью тега такого вида:
     </simpara>

     <informalexample>
      <programlisting role="html">
<![CDATA[
<input type="image" src="image.gif" name="sub" />
]]>
      </programlisting>
     </informalexample>

     <simpara>
      Когда пользователь щелкнет где-нибудь на изображении,
      соответствующая форма будет передана на сервер с двумя
      дополнительными переменными - <varname>sub_x</varname> и <varname>sub_y</varname>.
      Они содержат координаты нажатия пользователя на изображение. Опытные
      программисты могут заметить, что на самом деле имена переменных,
      отправленных браузером, содержат точку, а не подчеркивание, но
      PHP автоматически конвертирует точку в подчеркивание.
     </simpara>
    </sect3>

   </sect2>

   <sect2 xml:id="language.variables.external.cookies">
    <title>HTTP Cookies</title>

    <simpara>
     PHP прозрачно поддерживает HTTP cookies как определено в <link
     xlink:href="&spec.cookies;">спецификации Netscape</link>. Cookies - это
     механизм для хранения данных в удаленном браузере и отслеживания и
     идентификации таким образом вернувшихся пользователей. Вы можете
     установить cookies, используя функцию <function>setcookie</function>.
     Cookies являются частью HTTP-заголовка, поэтому функция SetCookie
     должна вызываться до того, как браузеру будет отправлен какой бы то
     ни было вывод. Это ограничение аналогично ограничению функции
     <function>header</function>. Данные, хранящиеся в cookie, доступны
     в соответствующих массивах данных cookie, таких как
     <varname>$_COOKIE</varname>, <varname>$HTTP_COOKIE_VARS</varname>,
     а также в <varname>$_REQUEST</varname>. Подробности и примеры
     смотрите на странице <function>setcookie</function> руководства.
    </simpara>

    <simpara>
     Если вы хотите присвоить множество значений одной переменной cookie,
     вы можете присвоить их как массив. Например:
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
  setcookie("MyCookie[foo]", 'Testing 1', time()+3600);
  setcookie("MyCookie[bar]", 'Testing 2', time()+3600);
?>
]]>
     </programlisting>
    </informalexample>
    
    <simpara>
     Это создаст две разные cookie, хотя в вашем скрипте <varname>MyCookie</varname> будет
     теперь одним массивом. Если вы хотите установить именно одну cookie 
     со множеством значений, примите во внимание сначала применение к
     значениям таких функций, как <function>serialize</function> или
     <function>explode</function>.
    </simpara>

    <simpara>
     Обратите внимание, что cookie заменит предыдущую cookie с тем же
     именем в вашем браузере, если только путь или домен не отличаются.
     Так, для приложения корзины покупок вы, возможно, захотите
     сохранить счетчик. То есть:
    </simpara>

    <example>
     <title>Пример использования <function>setcookie</function></title>
     <programlisting role="php">
<![CDATA[
<?php
if (isset($_COOKIE['count'])) {
    $count = $_COOKIE['count'] + 1;
} else {
    $count = 1;
}
setcookie('count', $count, time()+3600);
setcookie("Cart[$count]", $item, time()+3600);
?>
]]>
     </programlisting>
    </example>

   </sect2>

   <sect2 xml:id="language.variables.external.dot-in-names">
    <title>Точки в именах приходящих переменных</title>

    <para>
     Как правило, PHP не меняет передаваемых скрипту имен переменных.
     Однако следует отметить, что точка не является корректным
     символом в имени переменной PHP. Поэтому рассмотрим такую запись:
     <programlisting role="php">
<![CDATA[
<?php
$varname.ext;  /* неверное имя переменной */
?>
]]>
     </programlisting>
     В данном случае интерпретатор видит переменную
     <varname>$varname</varname>, после которой идет оператор
     конкатенации, а затем голая строка (то есть, не заключенная в
     кавычки строка, не соответствующая ни одному из ключевых или
     зарезервированных слов) 'ext'. Очевидно, что это не даст
     ожидаемого результата.
    </para>

    <para>
     По этой причине важно заметить, что PHP будет автоматически
     заменять любые точки в именах приходящих переменных на символы
     подчеркивания.
    </para>

   </sect2>

   <sect2 xml:id="language.variables.determining-type-of">
    <title>Определение типов переменных</title>

    <para>
     Поскольку PHP определяет и конвертирует типы переменных (в
     большинстве случаев) как надо, не всегда очевидно, какой тип
     имеет данная переменная в конкретный момент времени. PHP
     содержит несколько функций, позволяющих определить тип
     переменной, таких как: <function>gettype</function>,
     <function>is_array</function>, <function>is_float</function>,
     <function>is_int</function>, <function>is_object</function> и
     <function>is_string</function>. Смотрите также раздел
     <link linkend="language.types">Типы</link>.
    </para>
   </sect2>

  </sect1>
     
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
