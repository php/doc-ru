<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: ef81c708faf8d64a78c103fca7d53b7f6cdfacce Maintainer: sergey Status: ready -->
<!-- Reviewed: yes -->

<chapter xml:id="language.functions" xmlns="http://docbook.org/ns/docbook">
 <title>Функции</title>
 
 <sect1 xml:id="functions.user-defined">
  <title>Функции, определяемые пользователем</title>
  
  <para>
   Приведём пример синтаксиса, используемого для описания функций:
  </para>
  <para>
   <example>
    <title>Псевдокод для демонстрации использования функций</title>
    <programlisting role="php">
<![CDATA[
<?php
function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Пример функции.\n";
    return $retval;
}
?>
]]>
    </programlisting>
   </example>
  </para>
  
  <simpara>
   Внутри функции можно использовать любой корректный PHP-код, 
   в том числе другие функции и даже объявления <link linkend="language.oop5.basic.class">классов</link>.
  </simpara>
  <para>
   Имена функций следуют тем же правилам, что и другие метки в PHP.
   Корректное имя функции начинается с буквы или знака подчёркивания,
   за которым следует любое количество букв, цифр или знаков
   подчёркивания. В качестве регулярного выражения оно может быть
   выражено так:
   <code>^[a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*$</code>.
  </para>
  &tip.userlandnaming;
  <simpara>
   Функции не обязаны быть определены до их использования, <emphasis>исключая</emphasis> 
   тот случай, когда функции определяются условно, как это показано
   в двух последующих примерах.
  </simpara>
  <para>
   В случае, когда функция определяется в зависимости от какого-либо условия, например,
   как это показано в двух приведённых ниже примерах, обработка описания функции
   должна <emphasis>предшествовать</emphasis> её вызову.
  </para>
  <para>
   <example>
    <title>Функции, зависящие от условий</title>
    <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* Мы не можем вызвать функцию foo() в этом месте,
   поскольку она ещё не определена, но мы можем 
   обратиться к bar() */

bar();

if ($makefoo) {
  function foo()
  {
    echo "Я не существую до тех пор, пока выполнение программы меня не достигнет.\n";
  }
}

/* Теперь мы благополучно можем вызывать foo(),
   поскольку $makefoo была интерпретирована как true */

if ($makefoo) foo();

function bar() 
{
  echo "Я существую сразу с начала старта программы.\n";
}

?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Вложенные функции</title>
    <programlisting role="php">
<![CDATA[
<?php
function foo() 
{
  function bar() 
  {
    echo "Я не существую пока не будет вызвана foo().\n";
  }
}

/* Мы пока не можем обратиться к bar(),
   поскольку она ещё не определена. */

foo();

/* Теперь мы можем вызвать функцию bar(),
   обработка foo() сделала её доступной. */

bar();

?>  
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Все функции и классы PHP имеют глобальную область видимости - 
   они могут быть вызваны вне функции, даже если были определены
   внутри и наоборот.
  </para>
  <simpara>
   PHP не поддерживает перегрузку функции, также отсутствует возможность
   переопределить или удалить объявленную ранее функцию.
  </simpara>
  <note>
   <simpara>
    Имена функций регистронезависимы для символов ASCII от <literal>A</literal> до <literal>Z</literal>, тем не менее, предпочтительнее
    вызывать функции так, как они были объявлены.
   </simpara>
  </note>   
  <simpara>
   Функции PHP поддерживают как <link linkend="functions.variable-arg-list">
   списки аргументов переменной длины</link>, так и 
   <link linkend="functions.arguments.default">значения аргументов по умолчанию</link>. 
   Смотрите также описания функций
   <function>func_num_args</function>,
   <function>func_get_arg</function> и
   <function>func_get_args</function> для более детальной информации.
  </simpara>
  
  <para>
   Можно вызывать функции PHP рекурсивно.
   <example>
    <title>Рекурсивные функции</title>
    <programlisting role="php">
<![CDATA[
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     Рекурсивный вызов методов/процедур с глубиной более 100-200 уровней рекурсии может вызвать 
     переполнение стека и привести к аварийному завершению скрипта. В частности, бесконечная 
     рекурсия будет считаться программной ошибкой.
    </simpara>
   </note>
  </para>
  
 </sect1>
 
 <sect1 xml:id="functions.arguments">
  <title>Аргументы функции</title>
  
  <simpara>
   Функция может принимать информацию в виде списка аргументов,
   который является списком разделённых запятыми выражений. Аргументы
   вычисляются слева направо.
  </simpara> 
  <para>
   PHP поддерживает передачу аргументов по значению (по умолчанию), <link
   linkend="functions.arguments.by-reference">передачу аргументов по ссылке</link>, 
   и <link linkend="functions.arguments.default">значения по умолчанию</link>. 
   <link linkend="functions.variable-arg-list">Списки аргументов переменной длины
   </link> также поддерживаются, смотрите также описания функций
   <function>func_num_args</function>,
   <function>func_get_arg</function> и
   <function>func_get_args</function> для более детальной информации.
  </para>
  <para>
   <example>
    <title>Передача массива в функцию</title>
    <programlisting role="php">
<![CDATA[
<?php
function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Начиная с PHP 8.0.0, список аргументов функции может содержать завершающую 
   запятую, которая будет проигнорирована. Это полезно в случае, когда список аргументов
   очень длинный, либо если имена переменных длинны, что подталкивает к их
   вертикальному расположению.
  </para>
  <example>
   <title>Function Argument List with trailing Comma</title>
   <programlisting role="php">
<![CDATA[
<?php
function takes_many_args(
    $first_arg,
    $second_arg,
    $a_very_long_argument_name,
    $arg_with_default = 5,
    $again = 'a default string', // Эта завершающая запятая допустима только начиная с  8.0.0.
)
{
    // ...
}
?>
]]>
    </programlisting>
  </example>
  <para>
   Начиная с PHP 8.0.0, передача обязательных аргументов после необязательных аргументов 
   устарела. Обычно это можно решить, отказавшись от значения по умолчанию.
   Единственным исключением из этого правила являются аргументы формы 
   <code>Type $param = null</code>, где &null; по умолчанию делает тип неявно 
   допускающим значение null. Это использование остаётся разрешённым, хотя вместо этого рекомендуется использовать явный тип, 
   допускающий значение null.
   </para>
   <example>
    <title>Передача необязательных аргументов после обязательных аргументов</title>
    <programlisting role="php">
<![CDATA[
<?php
function foo($a = [], $b) {} // Раньше
function foo($a, $b) {}      // Теперь

function bar(A $a = null, $b) {} // Все ещё разрешено
function bar(?A $a, $b) {}       // Рекомендуется
?>
]]>
    </programlisting>
   </example>
  
  <sect2 xml:id="functions.arguments.by-reference">
   <title>Передача аргументов по ссылке</title>
   
   <simpara>
    По умолчанию аргументы в функцию передаются по значению (это означает, что
    если вы измените значение аргумента внутри функции, то вне её значение 
    всё равно останется прежним). Если вы хотите разрешить функции
    модифицировать свои аргументы, вы должны передавать их по ссылке.
   </simpara>
   <para>
    Если вы хотите, чтобы аргумент всегда передавался по ссылке,
    вы можете указать амперсанд (&amp;) перед именем аргумента в описании
    функции:
   </para>
   <para>
    <example>
     <title>Передача аргументов по ссылке</title>
     <programlisting role="php">
<![CDATA[
<?php
function add_some_extra(&$string)
{
    $string .= 'и кое-что ещё.';
}
$str = 'Это строка, ';
add_some_extra($str);
echo $str;    // выведет 'Это строка, и кое-что ещё.'
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Ошибка передачи значения в качестве аргумента, 
    которое должно передаваться по ссылке.
    </para>
  </sect2>
  <sect2 xml:id="functions.arguments.default">
   <title>Значения аргументов по умолчанию</title>
   
   <para>
    Функция может определять значения по умолчанию в стиле C++ для
    скалярных аргументов, например:
   </para>
   <para>
    <example>
     <title>Использование значений по умолчанию в определении функции</title>
     <programlisting role="php">
<![CDATA[
<?php
function makecoffee($type = "капучино")
{
    return "Готовим чашку $type.\n";
}
echo makecoffee();
echo makecoffee(null);
echo makecoffee("эспрессо");
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Готовим чашку капучино.
Готовим чашку .
Готовим чашку эспрессо.
]]>
     </screen>
    </example>
   </para>
   <para>
    PHP также позволяет использовать массивы (<type>array</type>) и специальный тип &null; в 
    качестве значений по умолчанию, например:
   </para>
   <para>
    <example>
     <title>Использование нескалярных типов в качестве значений по умолчанию</title>
     <programlisting role="php">
<![CDATA[
<?php
function makecoffee($types = array("капучино"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "вручную" : $coffeeMaker;
    return "Готовлю чашку ".join(", ", $types)." $device.\n";
}
echo makecoffee();
echo makecoffee(array("капучино", "лавацца"), "в чайнике");
?>
]]>
     </programlisting>
    </example>
    
   </para>
   <simpara>
    Значение по умолчанию должно быть константным выражением, а не
    (к примеру) переменной или вызовом функции/метода класса.
   </simpara>
   <para>
    Обратите внимание, что все аргументы, для которых установлены 
    значения по умолчанию, должны находиться правее аргументов,
    для которых значения по умолчанию не заданы, в противном случае
    ваш код может работать не так, как вы этого ожидаете. Рассмотрим
    следующий пример:
   </para>
   <para>
    <example>
     <title>Некорректное использование значений по умолчанию</title>
     <programlisting role="php">
<![CDATA[
<?php
function makeyogurt($type = "ацидофил", $flavour)
{
    return "Готовим чашку из бактерий $type со вкусом $flavour.\n";
}
 
echo makeyogurt("малины");   // Не будет работать так, как мы могли бы ожидать
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Warning: Missing argument 2 in call to makeyogurt() in 
/usr/local/etc/httpd/htdocs/phptest/functest.html on line 41
Готовим чашку из бактерий малины со вкусом .
]]>
     </screen>
    </example>
   </para>
   <para>
    Теперь сравним его со следующим примером:
   </para>
   <para>
    <example>
     <title>Корректное использование значений по умолчанию</title>
     <programlisting role="php">
<![CDATA[
<?php
function makeyogurt($flavour, $type = "ацидофил")
{
    return "Готовим чашку из бактерий $type со вкусом $flavour.\n";
}
 
echo makeyogurt("малины");   // отрабатывает правильно
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Готовим чашку из бактерий ацидофил со вкусом малины.
]]>
     </screen>
    </example>
   </para>
   <note>
    <simpara>
     Значения по умолчанию могут быть переданы по ссылке.
    </simpara>
   </note> 
  </sect2>
  
  <sect2 xml:id="functions.variable-arg-list">
   <title>Списки аргументов переменной длины</title>
   
   <simpara>
    PHP поддерживает списки аргументов переменной длины для функций,
    определяемых пользователем с помощью добавления 
    многоточия (<literal>...</literal>).
   </simpara>
   
   <note>
    <simpara>
     Также можно добиться аргументов переменной длины, используя функции
     <function>func_num_args</function>,
     <function>func_get_arg</function> и
     <function>func_get_args</function>.
     Этот метод не рекомендуется, поскольку он использовался до введения.
     токена <literal>...</literal>.
    </simpara>
   </note>
   
   <para>
    Список аргументов может содержать многоточие
    <literal>...</literal>, чтобы показать, что функция принимает переменное
    количество аргументов. Аргументы в этом случае будут переданы в виде массива.
    Например:
    
    <example>
     <title>Использование <literal>...</literal> для доступа к аргументам</title>
     <programlisting role="php">
<![CDATA[
<?php
function sum(...$numbers) {
    $acc = 0;
    foreach ($numbers as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
10
]]>
     </screen>
    </example>
   </para>
   
   <para>
    Многоточие (<literal>...</literal>) можно использовать при вызове функции,
    чтобы распаковать массив (<type>array</type>) или <classname>Traversable</classname>
    переменную в список аргументов:
    
    <example>
     <title>Использование <literal>...</literal> для передачи аргументов</title>
     <programlisting role="php">
<![CDATA[
<?php
function add($a, $b) {
    return $a + $b;
}

echo add(...[1, 2])."\n";

$a = [1, 2];
echo add(...$a);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
3
3
]]>
     </screen>
    </example>
   </para>
   
   <para>
    Можно задать несколько аргументов в привычном виде, а затем добавить 
    <literal>...</literal>. В этом случае <literal>...</literal> поместит
    в массив только те аргументы, которые не нашли соответствия указанным 
    в объявлении функции.
   </para>
   
   <para>
    Также можно добавить
    <link linkend="language.types.declarations">объявление типов</link> перед 
    <literal>...</literal>. В этом случае PHP будет следить, чтобы все аргументы
    обработанные многоточием (<literal>...</literal>) были того же типа, что указан в подсказке.
    
    <example>
     <title>Аргументы с подсказкой типов</title>
     <programlisting role="php">
<![CDATA[
<?php
function total_intervals($unit, DateInterval ...$intervals) {
    $time = 0;
    foreach ($intervals as $interval) {
        $time += $interval->$unit;
    }
    return $time;
}

$a = new DateInterval('P1D');
$b = new DateInterval('P2D');
echo total_intervals('d', $a, $b).' days';

// Это не сработает, т.к. null не является объектом DateInterval.
echo total_intervals('d', null);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>       
<![CDATA[
3 days
Catchable fatal error: Argument 2 passed to total_intervals() must be an instance of DateInterval, null given, called in - on line 14 and defined in - on line 2
]]>
     </screen>
    </example>
   </para>
   
   <para>
    В конце концов, можно передавать аргументы 
    <link linkend="functions.arguments.by-reference">по ссылке</link>. Для этого
    перед <literal>...</literal> нужно поставить амперсанд
    (<literal>&amp;</literal>).
   </para>
   
   <sect3 xml:id="functions.variable-arg-list.old">
    <title>Предыдущие версии PHP</title>
    
    <para>
     Для указания того, что функция принимает переменное число аргументов, 
     никакой специальный синтаксис не используется. Для доступа к аргументам 
     необходимо использовать функции
     <function>func_num_args</function>, <function>func_get_arg</function>
     и <function>func_get_args</function>.
    </para>
    
    <para>
     В первом примере выше было показано, как задать список аргументов переменной длины
     для предыдущих версий PHP:
     
     <example>
      <title>Доступ к аргументам в предыдущих версиях PHP</title>
      <programlisting role="php">
<![CDATA[
<?php
function sum() {
    $acc = 0;
    foreach (func_get_args() as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
10
]]>
      </screen>
     </example>
    </para>
   </sect3> 
   
  </sect2>
  
  <sect2 xml:id="functions.named-arguments">
    <title>Именованные аргументы</title>

    <para>
     В PHP 8.0.0 в виде продолжения позиционных параметров появились именованные аргументы.
     С помощью их помощью аргументы 
     функции можно передавать по имени параметра, а не по его позиции.
     Таким образом аргумент становится самодокументированным, независимым от 
     порядка и указанного значения по умолчанию.
    </para>

    <para>
     Именованные аргументы передаются путём добавления через двоеточия имени параметра перед его значением.
     В качестве имён параметров можно использовать зарезервированные ключевые слова.
     Имя параметра должно быть идентификатором, т.е. он не может быть создан 
     динамически.
    </para>

    <example>
     <title>Синтаксис именованного аргумента</title>
     <programlisting role="php">
      <![CDATA[
<?php
myFunction(paramName: $value);
array_foobar(array: $value);

// НЕ поддерживается.
function_name($variableStoringParamName: $value);
?>
]]>
     </programlisting>
    </example>

    <example>
     <title>Позиционные аргументы в сравнении с именованными аргументами</title>
     <programlisting role="php">
      <![CDATA[
<?php
// Использование позиционных аргументов:
array_fill(0, 100, 50);

// Использование именованных аргументов:
array_fill(start_index: 0, num: 100, value: 50);
?>
]]>
     </programlisting>
    </example>

    <para>
     Порядок, в котором передаются именованные аргументы, не имеет значения.
    </para>

    <example>
     <title>Тот же пример, что и выше, но с другим порядком параметров</title>
     <programlisting role="php">
      <![CDATA[
<?php
array_fill(value: 50, num: 100, start_index: 0);
?>
]]>
     </programlisting>
    </example>

    <para>
     Именованные аргументы можно комбинировать с позиционными. В этом случае 
     именованные аргументы должны следовать после позиционных аргументов.
     Также возможно передать только часть необязательных аргументов 
     функции, независимо от их порядка.
    </para>

    <example>
     <title>Объединение именованных аргументов с позиционными аргументами</title>
     <programlisting role="php">
      <![CDATA[
<?php
htmlspecialchars($string, double_encode: false);
// То же самое
htmlspecialchars($string, ENT_COMPAT | ENT_HTML401, 'UTF-8', false);
?>
]]>
     </programlisting>
    </example>

    <para>
     Передача одного и того же параметра несколько раз приводит к выбрасыванию исключения Error.
    </para>

    <example>
     <title>Выбрасывание исключения Error при передаче одного и того же параметра несколько раз</title>
     <programlisting role="php">
      <![CDATA[
<?php
function foo($param) { ... }

foo(param: 1, param: 2);
// Error: Named parameter $param overwrites previous argument
foo(1, param: 2);
// Error: Named parameter $param overwrites previous argument
?>
]]>
     </programlisting>
    </example>

   </sect2>
 </sect1>
 
 <sect1 xml:id="functions.returning-values">
  <title>Возврат значений</title>
  
  <para>
   Значения возвращаются при помощи необязательного оператора возврата.
   Возвращаемые значения могут быть любого типа, в том числе это могут
   быть массивы и объекты. Возврат приводит к завершению выполнения функции и передаче 
   управления обратно к той строке кода, в которой данная функция была
   вызвана. Для получения более детальной информации ознакомьтесь с описанием
   <function>return</function>.
  </para>
  <note>
   <para>
    Если конструкция <function>return</function> не указана, то функция вернёт
    значение &null;.
   </para>
  </note>
  
  <sect2>
   <title>Использование выражения return</title>
   <para>
    <example>
     <title>Использование конструкции <function>return</function></title>
     <programlisting role="php">
<![CDATA[
<?php
function square($num)
{
    return $num * $num;
}
echo square(4);   // выводит '16'.
?>
]]>
     </programlisting>
    </example>
   </para>
   
   <para>
    Функция не может возвращать несколько значений, но аналогичного
    результата можно добиться, возвращая массив.
   </para>
   <para>
    <example>
     <title>Возврат нескольких значений в виде массива</title>
     <programlisting role="php">
<![CDATA[
<?php
function small_numbers()
{
    return array (0, 1, 2);
}
list ($zero, $one, $two) = small_numbers();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Для того, чтобы функция возвращала результат по ссылке, вам 
    необходимо использовать оператор &amp; и при описании функции, 
    и при присвоении переменной возвращаемого значения:
   </para>
   <para>
    <example>
     <title>Возврат результата по ссылке</title>
     <programlisting role="php">
<![CDATA[
<?php
function &returns_reference()
{
    return $someref;
}

$newref =& returns_reference();
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Для получения более детальной информации о ссылках обратитесь
    к разделу документации <link linkend="language.references">Подробно о ссылках</link>.
   </simpara>
  </sect2>
 </sect1>
 
 <sect1 xml:id="functions.variable-functions">
  <title>Обращение к функциям через переменные</title>
  
  <para>
   PHP поддерживает концепцию переменных функций. Это означает, что
   если к имени переменной присоединены круглые скобки, PHP ищет
   функцию с тем же именем, что и результат вычисления переменной, и 
   пытается её выполнить. Эту возможность можно использовать для 
   реализации обратных вызовов, таблиц функций и множества других вещей.
  </para>
  <para>
   Переменные функции не будут работать с такими языковыми конструкциями
   как <function>echo</function>, <function>print</function>,
   <function>unset</function>, <function>isset</function>,
   <function>empty</function>, <function>include</function>,
   <function>require</function> и т.п. 
   Вам необходимо реализовать свою функцию-обёртку для того,
   чтобы приведённые выше конструкции могли работать с переменными
   функциями.
  </para>
  <para>
   <example>
    <title>Работа с функциями посредством переменных</title>
    <programlisting role="php">
<![CDATA[
<?php
function foo() {
    echo "В foo()<br />\n";
}

function bar($arg = '')
{
    echo "В bar(); аргумент был '$arg'.<br />\n";
}

// Функция-обёртка для echo
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // Вызывает функцию foo()

$func = 'bar';
$func('test');  // Вызывает функцию bar()

$func = 'echoit';
$func('test');  // Вызывает функцию echoit()
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Вы также можете вызвать методы объекта используя возможности PHP 
   для работы с переменными функциями.
   <example>
    <title>Обращение к методам класса посредством переменных</title>
    <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Variable()
    {
        $name = 'Bar';
        $this->$name(); // Вызываем метод Bar()
    }
    
    function Bar()
    {
        echo "Это Bar";
    }
}

$foo = new Foo();
$funcname = "Variable";
$foo->$funcname();  // Обращаемся к $foo->Variable()

?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   При вызове статических методов вызов функции "сильнее",
   чем оператор доступа к статическому свойству:
   <example>
    <title>Пример вызова переменного метода со статическим свойством</title>
    <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static $variable = 'статическое свойство';
    static function Variable()
    {
        echo 'Вызов метода Variable';
    }
}

echo Foo::$variable; // Это выведет 'статическое свойство'. Переменная $variable будет разрешена в нужной области видимости.
$variable = "Variable";
Foo::$variable();  // Это вызовет $foo->Variable(), прочитав $variable из этой области видимости.

?>
]]>
    </programlisting>
   </example>
  </para>   
  <para>
   <example>
    <title>Сложные callable-фукнции</title>
    <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static function bar()
    {
        echo "bar\n";
    }
    function baz()
    {
        echo "baz\n";
    }
}

$func = array("Foo", "bar");
$func(); // выведет "bar"
$func = array(new Foo, "baz");
$func(); // выведет "baz"
$func = "Foo::bar";
$func(); // выведет "bar"
?>
]]>
    </programlisting>
   </example>
  </para>
  
  <sect2 role="seealso">
   &reftitle.seealso;
   <para>
    <simplelist>
     <member><function>is_callable</function></member>
     <member><function>call_user_func</function></member>
     <member><function>function_exists</function></member>
     <member><link linkend="language.variables.variable">переменные переменные</link></member>
    </simplelist>
   </para>
  </sect2>
 </sect1>
 
 <sect1 xml:id="functions.internal">
  <title>Встроенные функции</title>
  
  <para>
   В самом PHP содержится достаточно большое количество встроенных функций
   и языковых конструкций. Также есть функции, которые требуют, чтобы PHP был
   собран с определёнными расширениями, в противном случае будут генерироваться
   фатальные ошибки, вызванные использованием неизвестной функции.
   Например, для того чтобы использовать <link linkend="ref.image">функции для работы с изображениями</link>,
   например, <function>imagecreatetruecolor</function>, необходимо собрать PHP с 
   поддержкой <productname>GD</productname>. Или же для того, чтобы воспользоваться 
   функцией <function>mysqli_connect</function>, необходима  поддержка модуля 
   <link linkend="book.mysqli">MySQLi</link>. Тем не менее, есть много встроенных
   функций, которые доступны всегда: например, <link linkend="ref.strings">функции обработки строк</link> и
   <link linkend="ref.var">функции для работы с переменными</link>.
   Вызвав <function>phpinfo</function> или <function>get_loaded_extensions</function>,
   можно узнать, поддержка каких модулей есть в используемом PHP.
   Также следует учесть, что поддержка некоторых дополнительных расширений 
   включена по умолчанию, и что сама документация к PHP разбита по расширениям.
   Ознакомьтесь с разделами <link linkend="configuration">Конфигурация</link>,
   <link linkend="install">Установка</link>, а также с документацией
   непосредственно к дополнительным расширениям для получения более детальной
   информации о том, как настроить PHP.
  </para>
  <para>
   Более подробную информацию о том, как следует читать и интерпретировать
   прототипы функций, вы можете найти в разделе <link linkend="about.prototypes">Как читать определения функции</link>. 
   Очень важно понимать, что возвращает функция,
   или как именно она модифицирует передаваемые аргументы. Например,
   функция <function>str_replace</function> возвращает модифицированную строку,
   в то время как функция <function>usort</function> работает с фактически 
   переданной переменной. Каждая страница документации также содержит
   информацию, которая специфична для данной функции, например, информацию о 
   передаваемых параметрах, изменениях в поведении, возвращаемых
   значениях в случае как удачного, так и неудачного выполнения, доступности
   функции в различных версиях. Знание и применение этих (порой даже незаметных)
   нюансов очень важно для написания корректного PHP-кода.
  </para>
  <note>
   <simpara>
    Если в функцию передаются не те аргументы, которые она ожидает,
    например, массив (<type>array</type>) вместо строки (<type>string</type>), 
    возвращаемое значение функции не определено. Скорее всего
    в этом случае будет возвращён &null;, но это просто соглашение,
    на него нельзя полагаться.
   </simpara>
  </note>
  
  <sect2 role="seealso">
   &reftitle.seealso;
   <para>
    <simplelist>
     <member><function>function_exists</function></member>
     <member><link linkend="funcref">справочник функций</link></member>
     <member><function>get_extension_funcs</function></member>
     <member><function>dl</function></member>
    </simplelist>
   </para>
  </sect2>
 </sect1>
 
 <sect1 xml:id="functions.anonymous">
  <title>Анонимные функции</title>
  
  <simpara>
   Анонимные функции, также известные как замыкания (<literal>closures</literal>),
   позволяют создавать функции, не имеющие определённых имён.
   Они наиболее полезны в качестве значений
   <type>callable</type>-параметров,
   но также могут иметь и множество других применений.
  </simpara>
  <simpara>
   Анонимные функции реализуются с использованием класса <link linkend="class.closure">
   <classname>Closure</classname></link>.
  </simpara>
  <example>
   <title>Пример анонимной функции</title>
   <programlisting role="php">
<![CDATA[
<?php
echo preg_replace_callback('~-([a-z])~', function ($match) {
    return strtoupper($match[1]);
}, 'hello-world');
// выведет helloWorld
?>
]]>
   </programlisting>
  </example>
  
  <simpara>
   Замыкания также могут быть использованы в качестве значений
   переменных; PHP автоматически преобразует такие выражения
   в экземпляры внутреннего класса <classname>Closure</classname>.
   Присвоение замыкания переменной использует тот же синтаксис,
   что и для любого другого присвоения, включая завершающую
   точку с запятой:
  </simpara>
  
  <example>
   <title>Пример присвоения анонимной функции переменной</title>
   <programlisting role="php">
<![CDATA[
<?php
$greet = function($name)
{
    printf("Привет, %s\r\n", $name);
};

$greet('Мир');
$greet('PHP');
?>
]]>
   </programlisting>
  </example>
  
  <simpara>
   Замыкания могут также наследовать переменные из родительской
   области видимости. Любая подобная переменная должна быть
   объявлена в конструкции <literal>use</literal>. Начиная с
   PHP 7.1, эти переменные не должны включать &link.superglobals;,
   <varname>$this</varname> и переменные с теми же именами, что и
   параметры функции.
  </simpara>
  
  
  
  <example>
   <title>Наследование переменных из родительской области видимости</title>
   <programlisting role="php">
<![CDATA[
<?php
$message = 'привет';

// Без "use"
$example = function () {
    var_dump($message);
};
$example();

// Наследуем $message
$example = function () use ($message) {
    var_dump($message);
};
$example();

// Значение унаследованной переменной задано там, где функция определена, 
// но не там, где вызвана
$message = 'мир';
$example();

// Сбросим message
$message = 'привет';

// Наследование по ссылке
$example = function () use (&$message) {
    var_dump($message);
};
$example();

// Изменённое в родительской области видимости значение
// остаётся тем же внутри вызова функции
$message = 'мир';
echo $example();

// Замыкания могут принимать обычные аргументы
$example = function ($arg) use ($message) {
    var_dump($arg . ', ' . $message);
};
$example("привет");
?>
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Notice: Undefined variable: message in /example.php on line 6
NULL
string(5) "привет"
string(5) "привет"
string(5) "привет"
string(5) "мир"
string(11) "привет мир"
]]>
   </screen>
  </example>
  <para>
   Начиная с PHP 8.0.0, список наследуюмых переменных может завершаться запятой, 
   которая будет проигнорирована.
  </para>
  <simpara>
   Наследование переменных из
   родительской области видимости <emphasis>не</emphasis> то же
   самое, что использование глобальных переменных.
   Глобальные переменные существуют в глобальной области видимости,
   которая не меняется, вне зависимости от того, какая функция
   выполняется в данный момент. Родительская область видимости
   - это функция, в которой было объявлено замыкание (не обязательно
   та же самая, из которой оно было вызвано). Смотрите следующий
   пример:
  </simpara>
  
  <example>
   <title>Замыкания и область видимости</title>
   <programlisting role="php">
<![CDATA[
<?php
// Базовая корзина покупок, содержащая список добавленных
// продуктов и количество каждого продукта. Включает метод,
// вычисляющий общую цену элементов корзины с помощью
// callback-замыкания.
class Cart
{
    const PRICE_BUTTER  = 1.00;
    const PRICE_MILK    = 3.00;
    const PRICE_EGGS    = 6.95;

    protected $products = array();
    
    public function add($product, $quantity)
    {
        $this->products[$product] = $quantity;
    }
    
    public function getQuantity($product)
    {
        return isset($this->products[$product]) ? $this->products[$product] :
               FALSE;
    }
    
    public function getTotal($tax)
    {
        $total = 0.00;
        
        $callback =
            function ($quantity, $product) use ($tax, &$total)
            {
                $pricePerItem = constant(__CLASS__ . "::PRICE_" .
                    strtoupper($product));
                $total += ($pricePerItem * $quantity) * ($tax + 1.0);
            };
        
        array_walk($this->products, $callback);
        return round($total, 2);
    }
}

$my_cart = new Cart;

// Добавляем несколько элементов в корзину
$my_cart->add('butter', 1);
$my_cart->add('milk', 3);
$my_cart->add('eggs', 6);

// Выводим общую сумму с 5% налогом на продажу.
print $my_cart->getTotal(0.05) . "\n";
// Результатом будет 54.29
?>
]]>
   </programlisting>
  </example>
  
  <example>
   <title>Автоматическое связывание <literal>$this</literal></title>
   <programlisting role="php">
<![CDATA[
<?php

class Test
{
    public function testing()
    {
        return function() {
            var_dump($this);
        };
    }
}

$object = new Test;
$function = $object->testing();
$function();
    
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
object(Test)#1 (0) {
}
]]>
   </screen>
  </example>
  <para>
   При объявлении в контексте класса, текущий
   класс будет автоматически связан с ним, делая <literal>$this</literal>
   доступным внутри функций класса. Если вы не хотите автоматического
   связывания с текущим классом, используйте <link 
   linkend="functions.anonymous-functions.static">статические анонимные функции</link>.
  </para>
  
  <sect2 xml:id="functions.anonymous-functions.static">
   <title>Статические анонимные функции</title>
   <para>
    Анонимные функции могут быть объявлены статически.
    Это предотвратит их автоматическое связывание с текущим классом.
    Объекты также не будут с ними связаны во время выполнения.
   </para>
   <para>
    <example>
     <title>Попытка использовать <literal>$this</literal> в статической анонимной функции</title>
     <programlisting role="php">
<![CDATA[
<?php

class Foo
{
    function __construct()
    {
        $func = static function() {
            var_dump($this);
        };
        $func();
    }
};
new Foo();

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Notice: Undefined variable: this in %s on line %d
NULL
]]>
     </screen>
    </example>
   </para>
   
   <para>
    <example>
     <title>Попытка связать объект со статической анонимной функцией</title>
     <programlisting role="php">
<![CDATA[
<?php

$func = static function() {
    // тело функции
};
$func = $func->bindTo(new StdClass);
$func();

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Warning: Cannot bind an instance to a static closure in %s on line %d
]]>
     </screen>
    </example>
   </para>
  </sect2>
  <sect2 role="changelog">
   &reftitle.changelog;
   <para>
    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>&Version;</entry>
        <entry>&Description;</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>7.1.0</entry>
        <entry>
         Анонимные функции не могут замыкаться вокруг &link.superglobals;,
         <varname>$this</varname> или любой переменной с тем же именем, что
         и параметр.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
  </sect2>
  
  <sect2 role="notes">
   &reftitle.notes;
   <note>
    <simpara>
     Совместно с замыканиями можно использовать функции
     <function>func_num_args</function>,
     <function>func_get_arg</function> и <function>func_get_args</function>.
    </simpara>
   </note>
  </sect2>
  
 </sect1>
 
 <sect1 xml:id="functions.arrow">
  <title>Стрелочные функции</title>
  
  <simpara>
   Стрелочные функции появились в PHP 7.4, как более лаконичный синтаксис для <link linkend="functions.anonymous">анонимных функций</link>.
  </simpara>
  <simpara>
   И анонимные, и стрелочные функции реализованы с использованием класса <link linkend="class.closure"><classname>Closure</classname></link>.
  </simpara>
  
  <simpara>
   Основной вид записи стрелочных функций:
   <code>fn (argument_list) =&gt; expr</code>.
  </simpara>
  
  <simpara>
   Стрелочные функции поддерживают те же возможности, что и <link linkend="functions.anonymous">анонимные функции</link>, 
   за исключением того, что использование переменных из родительской области всегда выполняется автоматически.
  </simpara>
  
  <simpara>
   Когда переменная, используемая в выражении, определена в родительской области, 
   она будет неявно захвачена по значению.
   В следующем примере функции <varname>$fn1</varname> и 
   <varname>$fn2</varname> ведут себя одинаково.
  </simpara>
  
  <para>
   <example>
    <title>Стрелочные функции захватывают переменные по значению автоматически</title>
    <programlisting role="php">
<![CDATA[
<?php

$y = 1;
 
$fn1 = fn($x) => $x + $y;
// эквивалентно использованию $y по значению:
$fn2 = function ($x) use ($y) {
    return $x + $y;
};

var_export($fn1(3));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
4
]]>
    </screen>
   </example>
  </para>
  <simpara>
   Это также работает во вложенных стрелочных функций:
  </simpara>
  <para>
   <example>
    <title>Стрелочные функции захватывают переменные по значению автоматически, даже когда они вложены</title>
    <programlisting role="php">
<![CDATA[
<?php

$z = 1;
$fn = fn($x) => fn($y) => $x * $y + $z;
// Выведет 51
var_export($fn(5)(10));
?>
]]>
    </programlisting>
   </example>
  </para>
  <simpara>
   Подобно анонимным функциям, 
   синтаксис стрелочных функций допускает произвольные сигнатуры функций, 
   включая типы параметров и возвращаемых значений, значения по умолчанию, переменные, 
   а также передачу и возврат по ссылке.
   Ниже приведены корректные примеры стрелочных функций: 
  </simpara>
  <para>
   <example>
    <title>Примеры использования стрелочных функций</title>
    <programlisting role="php">
<![CDATA[
<?php

fn(array $x) => $x;
static fn(): int => $x;
fn($x = 42) => $x;
fn(&$x) => $x;
fn&($x) => $x;
fn($x, ...$rest) => $rest;

?>
]]>
    </programlisting>
   </example>
  </para>
  <simpara>
   Стрелочные функции используют привязку переменных по значению.
   Это примерно эквивалентно выполнению <code>use($x)</code> для каждой 
   переменной <varname>$x</varname>, используемой внутри стрелочной функции.
   Привязка по значению означает, что невозможно изменить какие-либо значения 
   из внешней области.
   Вместо этого можно использовать <link linkend="functions.anonymous">анонимные функции</link> 
   для привязок по ссылкам.
  </simpara>
  <para>
   <example>
    <title>Значения из внешней области видимости не могут быть изменены стрелочными функциями</title>
    <programlisting role="php">
<![CDATA[
<?php

$x = 1;
$fn = fn() => $x++; // Ничего не изменит
$fn();
var_export($x);  // Выведет 1

?>
]]>
    </programlisting>
   </example>
  </para>
  
  <sect2 role="changelog">
   &reftitle.changelog;
   <para>
    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>&Version;</entry>
        <entry>&Description;</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>7.4.0</entry>
        <entry>
         Стали доступны стрелочные функции.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
  </sect2>
  
  <sect2 role="notes">
   &reftitle.notes;
   <note>
    <simpara>
     Можно использовать <function>func_num_args</function>, 
     <function>func_get_arg</function> и <function>func_get_args</function> 
     в стрелочной функции.
    </simpara>
   </note>
  </sect2>
 </sect1>
 
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
