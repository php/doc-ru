<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: b7db81dd3f683e16ae6b461df91c54d85313a3df Maintainer: shein Status: ready -->
<!-- Reviewed: no -->
<!-- $Revision$ -->
<chapter xml:id="language.functions" xmlns="http://docbook.org/ns/docbook">
 <title>Функции</title>
 
 <sect1 xml:id="functions.user-defined">
  <title>Функции, определяемые пользователем</title>
  
  <para>
   Приведем  пример синтаксиса, используемого для описания функций:
  </para>
  <para>
   <example>
    <title>Псевдокод для демонстрации использования функций</title>
    <programlisting role="php">
<![CDATA[
<?php
function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Example function.\n";
    return $retval;
}
?>
]]>
    </programlisting>
   </example>
  </para>
  
  <simpara>
   Внутри функции можно использовать любой корректный PHP-код, 
   в том числе другие функции и даже объявления <link linkend="language.oop5.basic.class">классов</link>.
  </simpara>
  <para>
   Имена функций следуют тем же правилам, что и другие метки в PHP.
   Корректное имя функции начинается с буквы или знака подчеркивания,
   за которым следует любое количество букв, цифр или знаков
   подчеркивания. В качестве регулярного выражения оно может быть
   выражено так:
   <literal>[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*</literal>.
  </para>
  &tip.userlandnaming;
  <simpara>
   Функции не обязаны быть определены до их использования, <emphasis>исключая</emphasis> 
   тот случай, когда функции определяются условно, как это показано
   в двух последующих примерах.
  </simpara>
  <para>
   В случае, когда функция определяется в зависимости от какого-либо условия, например,
   как это показано в двух приведенных ниже примерах, обработка описания функции
   должна <emphasis>предшествовать</emphasis> ее вызову.
  </para>
  <para>
   <example>
    <title>Функции, зависящие от условий</title>
    <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* Мы не можем вызвать функцию foo() в этом месте,
   поскольку она еще не определена, но мы можем 
   обратиться к bar() */

bar();

if ($makefoo) {
  function foo()
  {
    echo "Я не существую до тех пор, пока выполнение программы меня не достигнет.\n";
  }
}

/* Теперь мы благополучно можем вызывать foo(),
   поскольку $makefoo была интерпретирована как true */

if ($makefoo) foo();

function bar() 
{
  echo "Я существую сразу с начала старта программы.\n";
}

?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Вложенные функции</title>
    <programlisting role="php">
<![CDATA[
<?php
function foo() 
{
  function bar() 
  {
    echo "Я не существую пока не будет вызвана foo().\n";
  }
}

/* Мы пока не можем обратиться к bar(),
   поскольку она еще не определена. */

foo();

/* Теперь мы можем вызвать функцию bar(),
   обработка foo() сделала ее доступной. */

bar();

?>  
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Все функции и классы PHP имеют глобальную область видимости - 
   они могут быть вызваны вне функции, даже если были определены
   внутри и наоборот.
  </para>
  <simpara>
   PHP не поддерживает перегрузку функции, также отсутствует возможность
   переопределить или удалить объявленную ранее функцию.
  </simpara>
  <note>
   <simpara>
    Имена функций регистронезависимы, тем не менее, более предпочтительно
    вызывать функции так, как они были объявлены.
   </simpara>
  </note>   
  <simpara>
   Функции PHP поддерживают как <link linkend="functions.variable-arg-list">
   списки аргументов переменной длины</link>, так и 
   <link linkend="functions.arguments.default">значения аргументов по умолчанию</link>. 
   Смотрите также описания функций
   <function>func_num_args</function>,
   <function>func_get_arg</function>, и
   <function>func_get_args</function> для более детальной информации.
  </simpara>
  
  <para>
   Можно вызывать функции PHP рекурсивно.
   <example>
    <title>Рекурсивные функции</title>
    <programlisting role="php">
<![CDATA[
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     Рекурсивный вызов методов/процедур с глубиной более 100-200 уровней рекурсии может вызвать 
     переполнение стека и привести к аварийному завершению скрипта. В частности, бесконечная 
     рекурсия будет считаться программной ошибкой.
    </simpara>
   </note>
  </para>
  
 </sect1>
 
 <sect1 xml:id="functions.arguments">
  <title>Аргументы функции</title>
  
  <simpara>
   Функция может принимать информацию в виде списка аргументов,
   который является списком разделенных запятыми выражений. Аргументы
   вычисляются слева направо.
  </simpara> 
  <para>
   PHP поддерживает передачу аргументов по значению (по умолчанию), <link
   linkend="functions.arguments.by-reference">передачу аргументов по ссылке</link>, 
   и <link linkend="functions.arguments.default">значения по умолчанию</link>. 
   <link linkend="functions.variable-arg-list">Списки аргументов переменной длины
   </link> также поддерживаются, смотрите также описания функций
   <function>func_num_args</function>,
   <function>func_get_arg</function> и
   <function>func_get_args</function> для более детальной информации.
  </para>
  <para>
   <example>
    <title>Передача массива в функцию</title>
    <programlisting role="php">
<![CDATA[
<?php
function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <sect2 xml:id="functions.arguments.by-reference">
   <title>Передача аргументов по ссылке</title>
   
   <simpara>
    По умолчанию аргументы в функцию передаются по значению (это означает, что
    если вы измените значение аргумента внутри функции, то вне ее значение 
    все равно останется прежним). Если вы хотите разрешить функции
    модифицировать свои аргументы, вы должны передавать их по ссылке.
   </simpara>
   <para>
    Если вы хотите, что бы аргумент всегда передавался по ссылке,
    вы можете указать амперсанд (&amp;) перед именем аргумента в описании
    функции:
   </para>
   <para>
    <example>
     <title>Передача аргументов по ссылке</title>
     <programlisting role="php">
<![CDATA[
<?php
function add_some_extra(&$string)
{
    $string .= 'и кое-что еще.';
}
$str = 'Это строка, ';
add_some_extra($str);
echo $str;    // выведет 'Это строка, и кое-что еще.'
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="functions.arguments.default">
   <title>Значения аргументов по умолчанию</title>
   
   <para>
    Функция может определять значения по умолчанию в стиле C++ для
    скалярных аргументов, например:
   </para>
   <para>
    <example>
     <title>Использование значений по умолчанию в определении функции</title>
     <programlisting role="php">
<![CDATA[
<?php
function makecoffee($type = "капучино")
{
    return "Готовим чашку $type.\n";
}
echo makecoffee();
echo makecoffee(null);
echo makecoffee("эспрессо");
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Готовим чашку капучино.
Готовим чашку .
Готовим чашку эспрессо.
]]>
     </screen>
    </example>
   </para>
   <para>
    PHP также позволяет использовать массивы (<type>array</type>) и специальный тип &null; в 
    качестве значений по умолчанию, например:
   </para>
   <para>
    <example>
     <title>Использование нескалярных типов в качестве значений по умолчанию</title>
     <programlisting role="php">
<![CDATA[
<?php
function makecoffee($types = array("капуччино"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "вручную" : $coffeeMaker;
    return "Готовлю чашку ".join(", ", $types)." $device.\n";
}
echo makecoffee();
echo makecoffee(array("капуччино", "лавацца"), "в чайнике");
?>
]]>
     </programlisting>
    </example>
    
   </para>
   <simpara>
    Значение по умолчанию должно быть константным выражением, а не
    (к примеру) переменной или вызовом функции/метода класса.
   </simpara>
   <para>
    Обратите внимание, что все аргументы, для которых установлены 
    значения по умолчанию, должны находиться правее аргументов,
    для которых значения по умолчанию не заданы, в противном случае
    ваш код может работать не так, как вы этого ожидаете. Рассмотрим
    следующий пример:
   </para>
   <para>
    <example>
     <title>Некорректное использование значений по умолчанию</title>
     <programlisting role="php">
<![CDATA[
<?php
function makeyogurt($type = "ацидофил", $flavour)
{
    return "Готовим чашку из бактерий $type со вкусом $flavour.\n";
}
 
echo makeyogurt("малины");   // Не будет работать так, как мы могли бы ожидать
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Warning: Missing argument 2 in call to makeyogurt() in 
/usr/local/etc/httpd/htdocs/phptest/functest.html on line 41
Готовим чашку из бактерий малины со вкусом .
]]>
     </screen>
    </example>
   </para>
   <para>
    Теперь сравним его со следующим примером:
   </para>
   <para>
    <example>
     <title>Корректное использование значений по умолчанию</title>
     <programlisting role="php">
<![CDATA[
<?php
function makeyogurt($flavour, $type = "ацидофил")
{
    return "Готовим чашку из бактерий $type со вкусом $flavour.\n";
}
 
echo makeyogurt("малины");   // отрабатывает правильно
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Готовим чашку из бактерий ацидофил со вкусом малины.
]]>
     </screen>
    </example>
   </para>
   <note>
    <simpara>
     Начиная с PHP 5, значения по умолчанию могут быть переданы по ссылке.
    </simpara>
   </note> 
  </sect2>
  
  <sect2 xml:id="functions.arguments.type-declaration">
   <title>Объявление типов</title>
   
   <note>
    <para>
     Объявление типов также известно, как подсказки для типов в PHP 5.
    </para>
   </note>
   
   <para>
    Объявления типов позволяют функциям строго задавать тип передаваемых параметров. Передача в 
    функцию значений несоответствующего типа будет приводить к ошибке: в PHP 5 это будет
    обрабатываемая фатальная ошибка, а в PHP 7 будет выбрасываться исключение 
    <classname>TypeError</classname>.
   </para>
   
   <para>
    Чтобы объявить тип агрумента, необходимо перед его именем добавить имя требуемого типа.
    Также можно объявить тип &null;, чтобы указать, что значением по умолчанию аргумента является
    &null;.
   </para>
   
   <sect3 xml:id="functions.arguments.type-declaration.types">
    <title>Допустимые типы</title>
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Тип</entry>
        <entry>Описание</entry>
        <entry>Минимальная версия PHP</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>Имя класса/интерфейса</entry>
        <entry>
         Агрумент должен быть &instanceof;, что и имя класса или интерфейса.
        </entry>
        <entry>PHP 5.0.0</entry>
       </row>
       <row>
        <entry><literal>self</literal></entry>
        <entry>
         Этот параметр должен быть &instanceof; того же класса, в методе
         которого он указан. self можно использовать только в методах
         класса, либо объекта класса.
        </entry>
        <entry>PHP 5.0.0</entry>
       </row>
       <row>
        <entry><type>array</type></entry>
        <entry>
         Аргумент должен быть типа <type>array</type>.
        </entry>
        <entry>PHP 5.1.0</entry>
       </row>
       <row>
        <entry><type>callable</type></entry>
        <entry>
         Аргумент должен быть корректным <type>callable</type> типом.
        </entry>
        <entry>PHP 5.4.0</entry>
       </row>
       <row>
        <entry><type>bool</type></entry>
        <entry>
         Аргумент должен быть типа <type>boolean</type>.
        </entry>
        <entry>PHP 7.0.0</entry>
       </row>
       <row>
        <entry><type>float</type></entry>
        <entry>
         Аргумент должен быть <type>float</type> типа.
        </entry>
        <entry>PHP 7.0.0</entry>
       </row>
       <row>
        <entry><type>int</type></entry>
        <entry>
         Аргумент должен быть типа <type>integer</type>.
        </entry>
        <entry>PHP 7.0.0</entry>
       </row>
       <row>
        <entry><type>string</type></entry>
        <entry>
         Аргумент должен иметь тип <type>string</type>.
        </entry>
        <entry>PHP 7.0.0</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
    <warning>
     <para>
      Псевдонимы для вышеперечисленных скалярных типов не поддерживаются.
      Вместо этого они рассматриваются как имена классов или интерфейсов.
      К примеру, используя <literal>boolean</literal> как параметр или
      возвращаемое значение, потребует, чтобы эти аргумент или
      возвращаемое значение были &instanceof; класса или интерфейса
      <literal>boolean</literal>, а не типа <type>bool</type>:
     </para>
     <para>
      <example>
       <programlisting role="php">
<![CDATA[
 <?php
 function test(boolean $param) {}
 test(true);
 ?>
 ]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
 Fatal error: Uncaught TypeError: Argument 1 passed to test() must be an instance of boolean, boolean given, called in - on line 1 and defined in -:1
 ]]>
       </screen>
      </example>
     </para>
    </warning>
   </sect3>
   
   <sect3 xml:id="functions.arguments.type-declaration.examples">
    &reftitle.examples;
    <example>
     <title>Основные объявления типов-классов</title>
     <programlisting role="php">
<![CDATA[
<?php
class C {}
class D extends C {}

// Это не является расширением класса C.
class E {}

function f(C $c) {
    echo get_class($c)."\n";
}

f(new C);
f(new D);
f(new E);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
C
D

Fatal error: Uncaught TypeError: Argument 1 passed to f() must be an instance of C, instance of E given, called in - on line 14 and defined in -:8
Stack trace:
#0 -(14): f(Object(E))
#1 {main}
  thrown in - on line 8
]]>
     </screen>
    </example>
    
    <example>
     <title>Основные объявления типов-интерфейсов</title>
     <programlisting role="php">
<![CDATA[
<?php
interface I { public function f(); }
class C implements I { public function f() {} }

// Это не реализует интерфейс I.
class E {}

function f(I $i) {
    echo get_class($i)."\n";
}

f(new C);
f(new E);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
C

Fatal error: Uncaught TypeError: Argument 1 passed to f() must implement interface I, instance of E given, called in - on line 13 and defined in -:8
Stack trace:
#0 -(13): f(Object(E))
#1 {main}
  thrown in - on line 8
]]>
      </screen>
    </example>
    
    <example>
     <title>Объявление типа Null</title>
     <programlisting role="php">
<![CDATA[
<?php
class C {}

function f(C $c = null) {
    var_dump($c);
}

f(new C);
f(null);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
object(C)#1 (0) {
}
NULL
]]>
      </screen>
    </example>
   </sect3>
   
   <sect3 xml:id="functions.arguments.type-declaration.strict">
    <title>Строгая типизация</title>
    
    <para>
     По умолчанию, PHP будет пытаться привести значения несоответствующих типов 
     к скалярному типу, если это возможно. Например, если в функцию передается
     <type>integer</type>, а тип аргумента объявлен <type>string</type>, в итоге 
     функция получит преобразованное <type>string</type> значение.
    </para>
    
    <para>
     Для отдельных файлов можно включать режим строгой типизации. В этом режиме 
     в функцию можно передавать значения только тех типов, которые объявлены для
     аргументов. В противном случае будет выбрасываться исключение
     <classname>TypeError</classname>. Есть лишь одно исключение - <type>integer</type> 
     можно передать в функцию, которая ожидает значение типа <type>float</type>.
     Вызовы функций внутри встроенных функций не будут затронуты
     директивой <literal>strict_types</literal>.
    </para>
    
    <para>
     Для включения режима строгой типизации используется выражение &declare; в объявлении
     <literal>strict_types</literal>:
    </para>
    
    <caution>
     <para>
      Включение режима строгой типизации также повлияет на 
      <link linkend="functions.returning-values.type-declaration">объявления типов возвращаемых
       значений</link>.
     </para>
    </caution>
    
    <note>
     <para>
      Режим строгой типизации распространяется на вызовы функций совершенные 
      <emphasis>из</emphasis> файла, в котором этот режим включен, а не на функции, которые в 
      этом файле объявлены. Если файл без строгой типизации вызывает функцию, которая объявлена в
      файле с включенным режимом, значения аргументов будут приведены к нужным типам и ошибок 
      не последует.
     </para>
    </note>
    
    <note>
     <para>
      Строгая типизация применима только к скалярным типам и работает только в PHP 7.0.0 и выше. 
      Равно как и сами объявления скалярных типов добавлены в этой версии.
     </para>
    </note>
    
    <example>
     <title>Строгая типизация</title>
     <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1.5, 2.5));
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
int(3)

Fatal error: Uncaught TypeError: Argument 1 passed to sum() must be of the type integer, float given, called in - on line 9 and defined in -:4
Stack trace:
#0 -(9): sum(1.5, 2.5)
#1 {main}
  thrown in - on line 4
]]>
     </screen>
    </example>
    
    <example>
     <title>Слабая типизация</title>
     <programlisting role="php">
<![CDATA[
<?php
function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2));

// Будут приведены к целым числам: обратите внимание на результат ниже!
var_dump(sum(1.5, 2.5));
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
int(3)
int(3)
]]>
      </screen>
    </example>
    
    <example>
     <title>Обработка исключения <classname>TypeError</classname></title>
     <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum(int $a, int $b) {
    return $a + $b;
}

try {
    var_dump(sum(1, 2));
    var_dump(sum(1.5, 2.5));
} catch (TypeError $e) {
    echo 'Ошибка: '.$e->getMessage();
}
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
int(3)
Error: Argument 1 passed to sum() must be of the type integer, float given, called in - on line 10
]]>
      </screen>
    </example>
   </sect3>
  </sect2>
  <sect2 xml:id="functions.variable-arg-list">
   <title>Списки аргументов переменной длины</title>
   
   <simpara>
    PHP поддерживает списки аргументов переменной длины для функций,
    определяемых пользователем. Для версий PHP 5.6 и выше это делается 
    добавлением многоточия (<literal>...</literal>). Для версий 5.5 и старше
    используются функции <function>func_num_args</function>,
    <function>func_get_arg</function> и
    <function>func_get_args</function>.
   </simpara>
   
   <sect3 xml:id="functions.variable-arg-list.new">
    <title><literal>...</literal> в PHP 5.6+</title>
    
    <para>
     В версиях PHP 5.6 и выше список аргументов может содержать многоточие
     <literal>...</literal>, чтобы показать, что функция принимает переменное
     количество аргументов. Аргументы в этом случае будут переданы в виде массива.
     Например:
     
     <example>
      <title>Использование <literal>...</literal> для доступа к аргументам</title>
      <programlisting role="php">
<![CDATA[
<?php
function sum(...$numbers) {
    $acc = 0;
    foreach ($numbers as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
10
]]>
      </screen>
     </example>
    </para>
    
    <para>
     Многоточие (<literal>...</literal>) можно использовать при вызове функции,
     чтобы распаковать массив (<type>array</type>) или <classname>Traversable</classname>
     переменную в список аргументов:
     
     <example>
      <title>Использование <literal>...</literal> для передачи аргументов</title>
      <programlisting role="php">
<![CDATA[
<?php
function add($a, $b) {
    return $a + $b;
}

echo add(...[1, 2])."\n";

$a = [1, 2];
echo add(...$a);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
3
3
]]>
      </screen>
     </example>
    </para>
    
    <para>
     Можно задать несколько аргументов в привычном виде, а затем добавить 
     <literal>...</literal>. В этом случае <literal>...</literal> поместит
     в массив только те аргументы, которые не нашли соответствия указанным 
     в объявлении функции.
    </para>
    
    <para>
     Также можно добавить
     <link linkend="language.oop5.typehinting">подсказку типа</link> перед 
     <literal>...</literal>. В этом случае PHP будет следить, чтобы все аргументы
     обработанные многоточием (<literal>...</literal>) были того же типа, что указан в подсказке.
     
     <example>
      <title>Аргументы с подсказкой типов</title>
      <programlisting role="php">
<![CDATA[
<?php
function total_intervals($unit, DateInterval ...$intervals) {
    $time = 0;
    foreach ($intervals as $interval) {
        $time += $interval->$unit;
    }
    return $time;
}

$a = new DateInterval('P1D');
$b = new DateInterval('P2D');
echo total_intervals('d', $a, $b).' days';

// Это не сработает, т.к. null не является объектом DateInterval.
echo total_intervals('d', null);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>       
<![CDATA[
3 days
Catchable fatal error: Argument 2 passed to total_intervals() must be an instance of DateInterval, null given, called in - on line 14 and defined in - on line 2
]]>
      </screen>
     </example>
    </para>
    
    <para>
     В конце концов, можно передавать аргументы 
     <link linkend="functions.arguments.by-reference">по ссылке</link>. Для этого
     перед <literal>...</literal> нужно поставить амперсанд
     (<literal>&amp;</literal>).
    </para>
   </sect3>
   
   <sect3 xml:id="functions.variable-arg-list.old">
    <title>Предыдущие версии PHP</title>
    
    <para>
     Для указания того, что функция принимает переменное число аргументов, 
     никакой специальный синтаксис не используется. Для доступа к аргументам 
     необходимо использовать функции
     <function>func_num_args</function>, <function>func_get_arg</function>
     и <function>func_get_args</function>.
    </para>
    
    <para>
     В первом примере выше было показано, как задать список аргументов переменной длины
     для версий PHP 5.5 и более ранних:
     
     <example>
      <title>Доступ к аргументам в PHP 5.5 и ранних версий</title>
      <programlisting role="php">
<![CDATA[
<?php
function sum() {
    $acc = 0;
    foreach (func_get_args() as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
10
]]>
      </screen>
     </example>
    </para>
   </sect3>       
   
  </sect2>
 </sect1>
 
 <sect1 xml:id="functions.returning-values">
  <title>Возврат значений</title>
  
  <para>
   Значения возвращаются при помощи необязательного оператора возврата.
   Возвращаемые значения могут быть любого типа, в том числе это могут
   быть массивы и объекты. Возврат приводит к завершению выполнения функции и передаче 
   управления обратно к той строке кода, в которой данная функция была
   вызвана. Для получения более детальной информации ознакомьтесь с описанием
   <function>return</function>.
  </para>
  <note>
   <para>
    Если конструкция <function>return</function> не указана, то функция вернет
    значение &null;.
   </para>
  </note>
  
  <sect2>
   <title>Использование выражения return</title>
   <para>
    <example>
     <title>Использование конструкции <function>return</function></title>
     <programlisting role="php">
<![CDATA[
<?php
function square($num)
{
    return $num * $num;
}
echo square(4);   // выводит '16'.
?>
]]>
     </programlisting>
    </example>
   </para>
   
   <para>
    Функция не может возвращать несколько значений, но аналогичного
    результата можно добиться, возвращая массив.
   </para>
   <para>
    <example>
     <title>Возврат нескольких значений в виде массива</title>
     <programlisting role="php">
<![CDATA[
<?php
function small_numbers()
{
    return array (0, 1, 2);
}
list ($zero, $one, $two) = small_numbers();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Для того, чтобы функция возвращала результат по ссылке, вам 
    необходимо использовать оператор &amp; и при описании функции, 
    и при присвоении переменной возвращаемого значения:
   </para>
   <para>
    <example>
     <title>Возврат результата по ссылке</title>
     <programlisting role="php">
<![CDATA[
<?php
function &returns_reference()
{
    return $someref;
}

$newref =& returns_reference();
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Для получения более детальной информации о ссылках обратитесь
    к разделу документации <link linkend="language.references">Подробно о ссылках</link>.
   </simpara>
  </sect2>
  
  <sect2 xml:id="functions.returning-values.type-declaration">
   <title>Объявление типов возвращаемых значений</title>
   
   <para>
    В PHP 7 добавлена возможность объявлять тип возвращаемого значения. Аналогично 
    <link linkend="functions.arguments.type-declaration">объявлению типов аргументов</link>
    можно задать тип значения, которое будет возвращаться функцией.
    <link linkend="functions.arguments.type-declaration.types">Типы</link>, которые можно
    объявить для возвращаемых значений те же, что и для аргументов фукнций.
   </para>
   
   <para>
    <link linkend="functions.arguments.type-declaration.strict">Режим строгой типизации</link>
    также работает при объявлении типа возвращаемого значения. В обычном режиме слабой 
    типизации возвращаемое из функции значение приводится к корректному типу. При строгой
    типизации возвращаемое значение должно быть заданного типа, иначе будет выброшено 
    исключение <classname>TypeError</classname>.
   </para>
   
   <note>
    <para>
     Если переопределяется родительский метод, возвращаемое значение дочернего метода должно
     быть того же типа, что и родительского. Если в родительском методе не задан тип возвращаемого
     значения, то и дочерний метод этот тип может не объявлять.
    </para>
   </note>
   
   <sect3 xml:id="functions.returning-values.type-declaration.examples">
    &reftitle.examples;
    
    <example>
     <title>Обычное объявление типа возвращаемого значения</title>
     <programlisting role="php">
<![CDATA[
<?php
function sum($a, $b): float {
    return $a + $b;
}

// Будет возвращаться значение типа float.
var_dump(sum(1, 2));
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
float(3)
]]>
     </screen>
    </example>
    
    <example>
     <title>То же в режиме строгой типизации</title>
     <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum($a, $b): int {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1, 2.5));
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
int(3)

Fatal error: Uncaught TypeError: Return value of sum() must be of the type integer, float returned in - on line 5 in -:5
Stack trace:
#0 -(9): sum(1, 2.5)
#1 {main}
  thrown in - on line 5
]]>
     </screen>
    </example>
    
    <example>
     <title>Возврат объектов</title>
     <programlisting role="php">
<![CDATA[
<?php
class C {}

function getC(): C {
    return new C;
}

var_dump(getC());
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
object(C)#1 (0) {
}
]]>
     </screen>
    </example>
   </sect3>
  </sect2>
 </sect1>
 
 <sect1 xml:id="functions.variable-functions">
  <title>Обращение к функциям через переменные</title>
  
  <para>
   PHP поддерживает концепцию переменных функций. Это означает, что
   если к имени переменной присоединены круглые скобки, PHP ищет
   функцию с тем же именем, что и результат вычисления переменной, и 
   пытается ее выполнить. Эту возможность можно использовать для 
   реализации обратных вызовов, таблиц функций и множества других вещей.
  </para>
  <para>
   Переменные функции не будут работать с такими языковыми конструкциями
   как <function>echo</function>, <function>print</function>,
   <function>unset</function>, <function>isset</function>,
   <function>empty</function>, <function>include</function>,
   <function>require</function> и другими подобными им операторами. 
   Вам необходимо реализовывать свою функцию-обертку (wrapper) для того,
   чтобы приведенные выше конструкции могли работать с переменными
   функциями.
  </para>
  <para>
   <example>
    <title>Работа с функциями посредством переменных</title>
    <programlisting role="php">
<![CDATA[
<?php
function foo() {
    echo "In foo()<br />\n";
}

function bar($arg = '')
{
    echo "In bar(); argument was '$arg'.<br />\n";
}

// Функция-обертка для echo
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // Вызывает функцию foo()

$func = 'bar';
$func('test');  // Вызывает функцию bar()

$func = 'echoit';
$func('test');  // Вызывает функцию echoit()
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Вы также можете вызвать методы объекта, используя возможности PHP 
   для работы с переменными функциями.
   <example>
    <title>Обращение к методам класса посредством переменных</title>
    <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Variable()
    {
        $name = 'Bar';
        $this->$name(); // Вызываем метод Bar()
    }
    
    function Bar()
    {
        echo "This is Bar";
    }
}

$foo = new Foo();
$funcname = "Variable";
$foo->$funcname();  // Обращаемся к $foo->Variable()

?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   При вызове статических методов, вызов функции "сильнее"
   чем оператор доступа к статическому свойству:
   <example>
    <title>Пример вызова переменного метода со статическим свойством</title>
    <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static $variable = 'static property';
    static function Variable()
    {
        echo 'Method Variable called';
    }
}

echo Foo::$variable; // Это выведет 'static property'. Переменная $variable будет разрешена в нужной области видимости.
$variable = "Variable";
Foo::$variable();  // Это вызовет $foo->Variable(), прочитав $variable из этой области видимости.

?>
]]>
    </programlisting>
   </example>
  </para>   
  <para>
   С версии PHP 5.4.0, можно вызывать <type>callable</type> функцию помещенную в переменную.
   <example>
    <title>Сallable-фукнции</title>
    <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static function bar()
    {
        echo "bar\n";
    }
    function baz()
    {
        echo "baz\n";
    }
}

$func = array("Foo", "bar");
$func(); // prints "bar"
$func = array(new Foo, "baz");
$func(); // prints "baz"
$func = "Foo::bar";
$func(); // выведет "bar" в PHP 7.0.0 и выше; в предыдущих версиях это приведет к фатальной ошибке
?>
]]>
    </programlisting>
   </example>
  </para>
  
  <para>
   Смотрите также <function>is_callable</function>, <function>call_user_func</function>,
   <link linkend="language.variables.variable">Переменные переменные</link> и 
   <function>function_exists</function>.
  </para>
  
  <sect2 role="changelog">
   &reftitle.changelog;
   <para>
    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>&Version;</entry>
        <entry>&Description;</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>7.0.0</entry>
        <entry>
         'ClassName::methodName' доступна как функция-переменная.
        </entry>
       </row>
       <row>
        <entry>5.4.0</entry>
        <entry>
         Массивы, являющиеся корректными callable-методами, доступны как функции-переменные.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
  </sect2>
 </sect1>
 
 <sect1 xml:id="functions.internal">
  <title>Встроенные функции</title>
  
  <para>
   В самом PHP содержится достаточно большое количество встроенных функций
   и языковых конструкций. Также есть функции, которые требуют, чтобы PHP был
   собран со специфическими расширениями, в противном случае вы получите
   сообщение о фатальной ошибке, вызванной использованием неизвестной функции.
   Например, для того чтобы использовать <link linkend="ref.image">функции для работы с изображениями</link>,
   например, <function>imagecreatetruecolor</function>, вам необходимо собрать PHP с 
   поддержкой <productname>GD</productname>.  Или же для того, чтобы воспользоваться 
   функцией <function>mysql_connect</function>, вам необходима  поддержка модуля 
   <link linkend="ref.mysql">MySQL</link>. Тем не менее, есть много встроенных
   функций, которые доступны всегда: например <link linkend="ref.strings">функции обработки строк</link> и
   <link linkend="ref.var">функции для работы с переменными</link>.
   Вызвав <function>phpinfo</function> или <function>get_loaded_extensions</function>,
   вы можете узнать, поддержка каких модулей есть в используемом вами PHP.
   Также следует учесть, что поддержка некоторых дополнительных расширений 
   включена по умолчанию, и что сама документация к PHP разбита по расширениям.
   Ознакомьтесь с разделами <link linkend="configuration">Конфигурация</link>,
   <link linkend="install">Установка</link>, а также с документацией
   непосредственно к дополнительным расширениям для получения более детальной
   информации о том, как настроить ваш PHP.
  </para>
  <para>
   Более подробную информацию о том, как следует читать и интерпретировать
   прототипы функций, вы можете найти в разделе <link linkend="about.prototypes">Как правильно 
   читать описания функций</link>. Очень важно понимать, что возвращает функция,
   или как именно она модифицирует передаваемые аргументы. Например,
   функция <function>str_replace</function> возвращает модифицированную строку,
   в то время как функция <function>usort</function> работает с фактически 
   переданной переменной. Каждая страница документации также содержит
   информацию, которая специфична для данной функции, например, информацию о 
   передаваемых параметрах, изменениях в поведении, возвращаемых
   значениях в случае как удачного, так и неудачного выполнения, доступности
   функции в различных версиях. Знание и применение этих (порой даже незаметных)
   нюансов очень важно для написания корректного PHP-кода.
  </para>
  <note>
   <simpara>
    Если в функцию передаются не те аргументы, которые она ожидает,
    например, массив (<type>array</type>) вместо строки (<type>string</type>), 
    возвращаемое значение функции не определено. Скорее всего
    в этом случае будет возвращен &null;, но это просто соглашение,
    на него нельзя полагаться.
   </simpara>
  </note>
  <para>
   Ознакомьтесь также с описанием функции <function>function_exists</function>,  
   <link linkend="funcref">справочником функций</link> и функциями
   <function>get_extension_funcs</function> и 
   <function>dl</function>.
  </para>
 </sect1>
 
 <sect1 xml:id="functions.anonymous">
  <title>Анонимные функции</title>
  
  <simpara>
   Анонимные функции, также известные как замыкания (<literal>closures</literal>),
   позволяют создавать функции, не имеющие определенных имен.
   Они наиболее полезны в качестве значений
   <link linkend="language.types.callback">callback</link>-параметров,
   но также могут иметь и множество других применений.
  </simpara>
  <simpara>
   Анонимные функции реализуются с использованием класса <link linkend="class.closure">
   <classname>Closure</classname></link>.
  </simpara>
  <example>
   <title>Пример анонимной функции</title>
   <programlisting role="php">
<![CDATA[
<?php
echo preg_replace_callback('~-([a-z])~', function ($match) {
    return strtoupper($match[1]);
}, 'hello-world');
// выведет helloWorld
?>
]]>
   </programlisting>
  </example>
  
  <simpara>
   Замыкания также могут быть использованы в качестве значений
   переменных; PHP автоматически преобразует такие выражения
   в экземпляры внутреннего класса <classname>Closure</classname>.
   Присвоение замыкания переменной использует тот же синтаксис,
   что и для любого другого присвоения, включая завершающую
   точку с запятой:
  </simpara>
  
  <example>
   <title>Пример присвоения анонимной функции переменной</title>
   <programlisting role="php">
<![CDATA[
<?php
$greet = function($name)
{
    printf("Hello %s\r\n", $name);
};

$greet('World');
$greet('PHP');
?>
]]>
   </programlisting>
  </example>
  
  <simpara>
   Замыкания могут также наследовать переменные из родительской
   области видимости. Любая подобная переменная должна быть
   объявлена в конструкции <literal>use</literal>. Начиная с
   PHP 7.1, эти переменные не должны включать &link.superglobals;,
   <varname>$this</varname> и переменные с теми же именами, что и
   параметры функции.
  </simpara>
  
  
  
  <example>
   <title>Наследование переменных из родительской области видимости</title>
   <programlisting role="php">
<![CDATA[
<?php
$message = 'hello';

// Без "use"
$example = function () {
    var_dump($message);
};
$example();

// Наследуем $message
$example = function () use ($message) {
    var_dump($message);
};
$example();

// Значение унаследованной переменной задано там, где функция определена, 
// но не там, где вызвана
$message = 'world';
$example();

// Сбросим message
$message = 'hello';

// Наследование по ссылке
$example = function () use (&$message) {
    var_dump($message);
};
$example();

// Измененное в родительской области видимости значение
// остается тем же внутри вызова функции
$message = 'world';
echo $example();

// Замыкания могут принимать обычные аргументы
$example = function ($arg) use ($message) {
    var_dump($arg . ' ' . $message);
};
$example("hello");
?>
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Notice: Undefined variable: message in /example.php on line 6
NULL
string(5) "hello"
string(5) "hello"
string(5) "hello"
string(5) "world"
string(11) "hello world"
]]>
   </screen>
  </example>
  <simpara>
   Наследование переменных из
   родительской области видимости <emphasis>не</emphasis> то же
   самое, что использование глобальных переменных.
   Глобальные переменные существуют в глобальной области видимости,
   которая не меняется, вне зависимости от того, какая функция
   выполняется в данный момент. Родительская область видимости
   - это функция, в которой было объявлено замыкание (не обязательно
   та же самая, из которой оно было вызвано). Смотрите следующий
   пример:
  </simpara>
  
  <example>
   <title>Замыкания и область видимости</title>
   <programlisting role="php">
<![CDATA[
<?php
// Базовая корзина покупок, содержащая список добавленных
// продуктов и количество каждого продукта. Включает метод,
// вычисляющий общую цену элементов корзины с помощью
// callback-замыкания.
class Cart
{
    const PRICE_BUTTER  = 1.00;
    const PRICE_MILK    = 3.00;
    const PRICE_EGGS    = 6.95;

    protected $products = array();
    
    public function add($product, $quantity)
    {
        $this->products[$product] = $quantity;
    }
    
    public function getQuantity($product)
    {
        return isset($this->products[$product]) ? $this->products[$product] :
               FALSE;
    }
    
    public function getTotal($tax)
    {
        $total = 0.00;
        
        $callback =
            function ($quantity, $product) use ($tax, &$total)
            {
                $pricePerItem = constant(__CLASS__ . "::PRICE_" .
                    strtoupper($product));
                $total += ($pricePerItem * $quantity) * ($tax + 1.0);
            };
        
        array_walk($this->products, $callback);
        return round($total, 2);
    }
}

$my_cart = new Cart;

// Добавляем несколько элементов в корзину
$my_cart->add('butter', 1);
$my_cart->add('milk', 3);
$my_cart->add('eggs', 6);

// Выводим общую сумму с 5% налогом на продажу.
print $my_cart->getTotal(0.05) . "\n";
// Результатом будет 54.29
?>
]]>
   </programlisting>
  </example>
  
  <example>
   <title>Автоматическое связывание <literal>$this</literal></title>
   <programlisting role="php">
<![CDATA[
<?php

class Test
{
    public function testing()
    {
        return function() {
            var_dump($this);
        };
    }
}

$object = new Test;
$function = $object->testing();
$function();
    
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
object(Test)#1 (0) {
}
]]>
   </screen>
   &example.outputs.53;
   <screen>
<![CDATA[
Notice: Undefined variable: this in script.php on line 8
NULL]]>
   </screen>
  </example>
  <para>
   Начиная с PHP 5.4.0, при объявлении в контексте класса, текущий
   класс будет автоматически связан с ним, делая <literal>$this</literal>
   доступным внутри функций класса. Если вы не хотите автоматического
   связывания с текущим классом, используйте <link 
   linkend="functions.anonymous-functions.static">статические анонимные функции</link>
  </para>
  
  <sect2 xml:id="functions.anonymous-functions.static">
   <title>Статические анонимные функции</title>
   <para>
    Начиная с PHP 5.4, анонимные функции могут быть объявлены статически.
    Это предотвратит их автоматическое связывание с текущим классом.
    Объекты также не будут с ними связаны во время выполнения.
   </para>
   <para>
    <example>
     <title>Попытка использовать <literal>$this</literal> в статической анонимной функции</title>
     <programlisting role="php">
<![CDATA[
<?php

class Foo
{
    function __construct()
    {
        $func = static function() {
            var_dump($this);
        };
        $func();
    }
};
new Foo();

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Notice: Undefined variable: this in %s on line %d
NULL
]]>
     </screen>
    </example>
   </para>
   
   <para>
    <example>
     <title>Попытка связать объект со статической анонимной функцией</title>
     <programlisting role="php">
<![CDATA[
<?php

$func = static function() {
    // тело функции
};
$func = $func->bindTo(new StdClass);
$func();

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Warning: Cannot bind an instance to a static closure in %s on line %d
]]>
     </screen>
    </example>
   </para>
  </sect2>
  <sect2 role="changelog">
   &reftitle.changelog;
   <para>
    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>&Version;</entry>
        <entry>&Description;</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>7.1.0</entry>
        <entry>
         Анонимные функции не могут замыкаться вокрук &link.superglobals;,
         <varname>$this</varname> или переменных с теми же именами, что
         и параметры функции.
        </entry>
       </row>
       <row>
        <entry>5.4.0</entry>
        <entry>
         Стало возможным использовать <varname>$this</varname>
         в анонимных функциях, и объявлять их статически.
        </entry>
       </row>
       <row>
        <entry>5.3.0</entry>
        <entry>
         Появление анонимных функций.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
  </sect2>
  
  <sect2 role="notes">
   &reftitle.notes;
   <note>
    <simpara>
     Совместно с замыканиями можно использовать функции
     <function>func_num_args</function>,
     <function>func_get_arg</function> и <function>func_get_args</function>.
    </simpara>
   </note>
  </sect2>
  
 </sect1>
 
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
