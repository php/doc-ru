<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: b22f4a798a435fb159af88806341ce9cbe9f38c2 Maintainer: sergey Status: ready -->
<!-- Reviewed: no -->
<chapter xml:id="language.functions" xmlns="http://docbook.org/ns/docbook">
 <title>Функции</title>

 <sect1 xml:id="functions.user-defined">
  <title>Функции, определяемые пользователем</title>

  <para>
   Приведём пример синтаксиса, используемого для описания функций:
  </para>
  <para>
   <example>
    <title>Псевдокод для демонстрации использования функций</title>
    <programlisting role="php">
<![CDATA[
<?php
function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Пример функции.\n";
    return $retval;
}
?>
]]>
    </programlisting>
   </example>
  </para>

  <simpara>
   Внутри функции можно использовать любой корректный PHP-код,
   в том числе другие функции и даже объявления <link linkend="language.oop5.basic.class">классов</link>.
  </simpara>
  <para>
   Имена функций следуют тем же правилам, что и другие метки в PHP.
   Корректное имя функции начинается с буквы или знака подчёркивания,
   за которым следует любое количество букв, цифр или знаков
   подчёркивания. В качестве регулярного выражения оно может быть
   выражено так:
   <code>^[a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*$</code>.
  </para>
  &tip.userlandnaming;
  <simpara>
   Функции не обязаны быть определены до их использования, <emphasis>исключая</emphasis>
   тот случай, когда функции определяются условно, как это показано
   в двух последующих примерах.
  </simpara>
  <para>
   В случае, когда функция определяется в зависимости от какого-либо условия, например,
   как это показано в двух приведённых ниже примерах, обработка описания функции
   должна <emphasis>предшествовать</emphasis> её вызову.
  </para>
  <para>
   <example>
    <title>Функции, зависящие от условий</title>
    <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* Мы не можем вызвать функцию foo() в этом месте,
   поскольку она ещё не определена, но мы можем
   обратиться к bar() */

bar();

if ($makefoo) {
  function foo()
  {
    echo "Я не существую до тех пор, пока выполнение программы меня не достигнет.\n";
  }
}

/* Теперь мы благополучно можем вызывать foo(),
   поскольку $makefoo была интерпретирована как true */

if ($makefoo) foo();

function bar()
{
  echo "Я существую сразу с начала старта программы.\n";
}

?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Вложенные функции</title>
    <programlisting role="php">
<![CDATA[
<?php
function foo()
{
  function bar()
  {
    echo "Я не существую пока не будет вызвана foo().\n";
  }
}

/* Мы пока не можем обратиться к bar(),
   поскольку она ещё не определена. */

foo();

/* Теперь мы можем вызвать функцию bar(),
   обработка foo() сделала её доступной. */

bar();

?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Все функции и классы PHP имеют глобальную область видимости -
   они могут быть вызваны вне функции, даже если были определены
   внутри и наоборот.
  </para>
  <simpara>
   PHP не поддерживает перегрузку функции, также отсутствует возможность
   переопределить или удалить объявленную ранее функцию.
  </simpara>
  <note>
   <simpara>
    Имена функций регистронезависимы для символов ASCII от <literal>A</literal> до <literal>Z</literal>, тем не менее, предпочтительнее
    вызывать функции так, как они были объявлены.
   </simpara>
  </note>
  <simpara>
   Функции PHP поддерживают как <link linkend="functions.variable-arg-list">
   списки аргументов переменной длины</link>, так и
   <link linkend="functions.arguments.default">значения аргументов по умолчанию</link>.
   Смотрите также описания функций
   <function>func_num_args</function>,
   <function>func_get_arg</function> и
   <function>func_get_args</function> для более детальной информации.
  </simpara>

  <para>
   Можно вызывать функции PHP рекурсивно.
   <example>
    <title>Рекурсивные функции</title>
    <programlisting role="php">
<![CDATA[
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     Рекурсивный вызов методов/процедур с глубиной более 100-200 уровней рекурсии может вызвать
     переполнение стека и привести к аварийному завершению скрипта. В частности, бесконечная
     рекурсия будет считаться программной ошибкой.
    </simpara>
   </note>
  </para>

 </sect1>

 <sect1 xml:id="functions.arguments">
  <title>Аргументы функции</title>

  <simpara>
   Функция может принимать информацию в виде списка аргументов,
   который является списком разделённых запятыми выражений. Аргументы
   вычисляются слева направо перед фактическим вызовом функции (<emphasis>энергичное</emphasis> вычисление).
  </simpara>
  <para>
   PHP поддерживает передачу аргументов по значению (по умолчанию), <link
   linkend="functions.arguments.by-reference">передачу аргументов по ссылке</link>,
   и <link linkend="functions.arguments.default">значения по умолчанию</link>.
   <link linkend="functions.variable-arg-list">Списки аргументов
    переменной длины</link> и <link linkend="functions.named-arguments">именованные аргументы</link> также поддерживаются.
  </para>
  <para>
   <example>
    <title>Передача массива в функцию</title>
    <programlisting role="php">
<![CDATA[
<?php
function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Начиная с PHP 8.0.0, список аргументов функции может содержать завершающую
   запятую, которая будет проигнорирована. Это полезно в случае, когда список аргументов
   очень длинный, либо если имена переменных длинны, что подталкивает к их
   вертикальному расположению.
  </para>
  <example>
   <title>Список аргументов функции с завершающей запятой</title>
   <programlisting role="php">
<![CDATA[
<?php
function takes_many_args(
    $first_arg,
    $second_arg,
    $a_very_long_argument_name,
    $arg_with_default = 5,
    $again = 'a default string', // Эта завершающая запятая допустима только начиная с  8.0.0.
)
{
    // ...
}
?>
]]>
    </programlisting>
  </example>

  <sect2 xml:id="functions.arguments.by-reference">
   <title>Передача аргументов по ссылке</title>

   <simpara>
    По умолчанию аргументы в функцию передаются по значению (это означает, что
    если вы измените значение аргумента внутри функции, то вне её значение
    всё равно останется прежним). Если вы хотите разрешить функции
    модифицировать свои аргументы, вы должны передавать их по ссылке.
   </simpara>
   <para>
    Если вы хотите, чтобы аргумент всегда передавался по ссылке,
    вы можете указать амперсанд (&amp;) перед именем аргумента в описании
    функции:
   </para>
   <para>
    <example>
     <title>Передача аргументов по ссылке</title>
     <programlisting role="php">
<![CDATA[
<?php
function add_some_extra(&$string)
{
    $string .= 'и кое-что ещё.';
}
$str = 'Это строка, ';
add_some_extra($str);
echo $str;    // выведет 'Это строка, и кое-что ещё.'
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Передача значения в качестве аргумента,
    которое должно передаваться по ссылке, является ошибкой.
    </para>
  </sect2>
  <sect2 xml:id="functions.arguments.default">
   <title>Значения аргументов по умолчанию</title>

   <para>
    Функция может определять значения по умолчанию для аргументов,
    используя синтаксис, подобный присвоению переменной.
    Значение по умолчанию используется только в том случае, если параметр не указан;
    в частности, обратите внимание, что передача &null;
    <emphasis>не</emphasis> присваивает значение по умолчанию.
   </para>
   <para>
    <example>
     <title>Использование значений по умолчанию в определении функции</title>
     <programlisting role="php">
<![CDATA[
<?php
function makecoffee($type = "капучино")
{
    return "Готовим чашку $type.\n";
}
echo makecoffee();
echo makecoffee(null);
echo makecoffee("эспрессо");
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Готовим чашку капучино.
Готовим чашку .
Готовим чашку эспрессо.
]]>
     </screen>
    </example>
   </para>
   <para>
    Значениями параметров по умолчанию могут быть скалярные значения, массивы (<type>array</type>),
    специальный тип &null;, и, начиная с версии PHP 8.1.0, объекты,
    использующие синтаксис <link linkend="language.oop5.basic.new">new ClassName()</link>.
   </para>
   <para>
    <example>
     <title>Использование нескалярных типов в качестве значений по умолчанию</title>
     <programlisting role="php">
<![CDATA[
<?php
function makecoffee($types = array("капучино"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "вручную" : $coffeeMaker;
    return "Готовлю чашку ".join(", ", $types)." $device.\n";
}
echo makecoffee();
echo makecoffee(array("капучино", "лавацца"), "в чайнике");
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Использование объектов в качестве значений по умолчанию (начиная с PHP 8.1.0)</title>
     <programlisting role="php">
<![CDATA[
<?php
class DefaultCoffeeMaker {
    public function brew() {
        return 'Приготовление кофе.';
    }
}
class FancyCoffeeMaker {
    public function brew() {
        return 'Приготовление прекрасного кофе специально для вас.';
    }
}
function makecoffee($coffeeMaker = new DefaultCoffeeMaker)
{
    return $coffeeMaker->brew();
}
echo makecoffee();
echo makecoffee(new FancyCoffeeMaker);
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Значение по умолчанию должно быть константным выражением, а не
    (к примеру) переменной или вызовом функции/метода класса.
   </simpara>
   <para>
    Обратите внимание, что любые необязательные аргументы должны быть указаны после любых обязательных аргументов,
    иначе они не могут быть опущены при вызове.
    Рассмотрим следующий пример:
   </para>
   <para>
    <example>
     <title>Некорректное использование значений по умолчанию</title>
     <programlisting role="php">
<![CDATA[
<?php
function makeyogurt($container = "миску", $flavour)
{
    return "Делаем $container с $flavour йогуртом.\n";
}

echo makeyogurt("малиновым"); // "малиновым" - это $container, не $flavour
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Fatal error: Uncaught ArgumentCountError: Too few arguments
to function makeyogurt(), 1 passed in example.php on line 42
]]>
     </screen>
    </example>
   </para>
   <para>
    Теперь сравним его со следующим примером:
   </para>
   <para>
    <example>
     <title>Корректное использование значений по умолчанию</title>
     <programlisting role="php">
<![CDATA[
<?php
function makeyogurt($flavour, $container = "миску")
{
    return "Делаем $container с $flavour йогуртом.\n";
}

echo makeyogurt("малиновым"); // "малиновым" - это $flavour
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Делаем миску с малиновым йогуртом.
]]>
     </screen>
    </example>
   </para>
   <para>
    Начиная с PHP 8.0.0, <link linkend="functions.named-arguments">именованные аргументы</link>
    можно использовать для пропуска нескольких необязательных параметров.
   </para>
   <para>
    <example>
     <title>Правильное использование аргументов функций по умолчанию</title>
     <programlisting role="php">
<![CDATA[
<?php
function makeyogurt($container = "миску", $flavour = "малиновым", $style = "греческим")
{
    return "Делаем $container с $flavour $style йогуртом.\n";
}
echo makeyogurt(style: "натуральным");
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Делаем миску с малиновым натуральным йогуртом.
]]>
     </screen>
    </example>
   </para>
   <para>
    Начиная с PHP 8.0.0, объявление обязательных аргументов после необязательных
    аргументов является <emphasis>устаревшим</emphasis>.
    Обычно это можно решить отказавшись от значения по умолчанию, поскольку оно никогда не будет использоваться.
    Исключением из этого правила являются аргументы вида <code>Type $param = null</code>,
    где &null; по умолчанию делает тип неявно обнуляемым.
    Такое использование остаётся допустимым, хотя рекомендуется использовать
    явный <link linkend="language.types.declarations.nullable">тип nullable</link>.
    <example>
     <title>Объявление необязательных аргументов после обязательных аргументов</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo($a = [], $b) {} // По умолчанию не используется; устарел, начиная с версии PHP 8.0.0
function foo($a, $b) {}      // Функционально эквивалентны, без уведомления об устаревании
function bar(A $a = null, $b) {} // Все еще разрешено; $a является обязательным, но допускающим значение null
function bar(?A $a, $b) {}       // Рекомендуется
?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <simpara>
     Начиная с PHP 7.1.0, опущение параметра, не заданного по умолчанию,
     выбрасывает исключение <classname>ArgumentCountError</classname>;
     в предыдущих версиях это вызывало предупреждение.
    </simpara>
   </note>
   <note>
    <simpara>
     Значения по умолчанию могут быть переданы по ссылке.
    </simpara>
   </note>
  </sect2>

  <sect2 xml:id="functions.variable-arg-list">
   <title>Списки аргументов переменной длины</title>

   <simpara>
    PHP поддерживает списки аргументов переменной длины для функций,
    определяемых пользователем с помощью добавления
    многоточия (<literal>...</literal>).
   </simpara>

   <para>
    Список аргументов может содержать многоточие
    (<literal>...</literal>), чтобы показать, что функция принимает переменное
    количество аргументов. Аргументы в этом случае будут переданы в виде массива:

    <example>
     <title>Использование <literal>...</literal> для доступа к аргументам</title>
     <programlisting role="php">
<![CDATA[
<?php
function sum(...$numbers) {
    $acc = 0;
    foreach ($numbers as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
10
]]>
     </screen>
    </example>
   </para>

   <para>
    Многоточие (<literal>...</literal>) можно использовать при вызове функции,
    чтобы распаковать массив (<type>array</type>) или <classname>Traversable</classname>
    переменную в список аргументов:

    <example>
     <title>Использование <literal>...</literal> для передачи аргументов</title>
     <programlisting role="php">
<![CDATA[
<?php
function add($a, $b) {
    return $a + $b;
}

echo add(...[1, 2])."\n";

$a = [1, 2];
echo add(...$a);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
3
3
]]>
     </screen>
    </example>
   </para>

   <para>
    Можно задать несколько аргументов в привычном виде, а затем добавить
    <literal>...</literal>. В этом случае <literal>...</literal> поместит
    в массив только те аргументы, которые не нашли соответствия указанным
    в объявлении функции.
   </para>

   <para>
    Также можно добавить
    <link linkend="language.types.declarations">объявление типа</link> перед
    <literal>...</literal>. В этом случае все аргументы,
    обработанные многоточием (<literal>...</literal>), должны соответствовать этому типу параметра.

    <example>
     <title>Аргументы с подсказкой типа</title>
     <programlisting role="php">
<![CDATA[
<?php
function total_intervals($unit, DateInterval ...$intervals) {
    $time = 0;
    foreach ($intervals as $interval) {
        $time += $interval->$unit;
    }
    return $time;
}

$a = new DateInterval('P1D');
$b = new DateInterval('P2D');
echo total_intervals('d', $a, $b).' days';

// Это не сработает, т.к. null не является объектом DateInterval.
echo total_intervals('d', null);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
3 days
Catchable fatal error: Argument 2 passed to total_intervals() must be an instance of DateInterval, null given, called in - on line 14 and defined in - on line 2
]]>
     </screen>
    </example>
   </para>

   <para>
    В конце концов, можно передавать аргументы
    <link linkend="functions.arguments.by-reference">по ссылке</link>. Для этого
    перед <literal>...</literal> нужно поставить амперсанд
    (<literal>&amp;</literal>).
   </para>

  </sect2>

  <sect2 xml:id="functions.named-arguments">
    <title>Именованные аргументы</title>

    <para>
     В PHP 8.0.0 в виде продолжения позиционных параметров появились именованные аргументы.
     С их помощью аргументы
     функции можно передавать по имени параметра, а не по его позиции.
     Таким образом аргумент становится самодокументированным, независимым от
     порядка и указанного значения по умолчанию.
    </para>

    <para>
     Именованные аргументы передаются путём добавления через двоеточия имени параметра перед его значением.
     В качестве имён параметров можно использовать зарезервированные ключевые слова.
     Имя параметра должно быть идентификатором, т.е. он не может быть создан
     динамически.
    </para>

    <example>
     <title>Синтаксис именованного аргумента</title>
     <programlisting role="php">
<![CDATA[
<?php
myFunction(paramName: $value);
array_foobar(array: $value);

// НЕ поддерживается.
function_name($variableStoringParamName: $value);
?>
]]>
     </programlisting>
    </example>

    <example>
     <title>Позиционные аргументы в сравнении с именованными аргументами</title>
     <programlisting role="php">
<![CDATA[
<?php
// Использование позиционных аргументов:
array_fill(0, 100, 50);

// Использование именованных аргументов:
array_fill(start_index: 0, count: 100, value: 50);
?>
]]>
     </programlisting>
    </example>

    <para>
     Порядок, в котором передаются именованные аргументы, не имеет значения.
    </para>

    <example>
     <title>Тот же пример, что и выше, но с другим порядком параметров</title>
     <programlisting role="php">
<![CDATA[
<?php
array_fill(value: 50, count: 100, start_index: 0);
?>
]]>
     </programlisting>
    </example>

    <para>
     Именованные аргументы можно комбинировать с позиционными. В этом случае
     именованные аргументы должны следовать после позиционных аргументов.
     Также возможно передать только часть необязательных аргументов
     функции, независимо от их порядка.
    </para>

    <example>
     <title>Объединение именованных аргументов с позиционными аргументами</title>
     <programlisting role="php">
<![CDATA[
<?php
htmlspecialchars($string, double_encode: false);
// То же самое
htmlspecialchars($string, ENT_QUOTES | ENT_SUBSTITUTE | ENT_HTML401, 'UTF-8', false);
?>
]]>
     </programlisting>
    </example>

    <para>
     Передача одного и того же параметра несколько раз приводит к выбрасыванию исключения Error.
    </para>

    <example>
     <title>Ошибка, возникающая при передаче одного и того же параметра несколько раз</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo($param) { ... }

foo(param: 1, param: 2);
// Error: Named parameter $param overwrites previous argument
foo(1, param: 2);
// Error: Named parameter $param overwrites previous argument
?>
]]>
     </programlisting>
    </example>

   <para>
    Начиная с PHP 8.1.0, можно использовать именованные аргументы после распаковки аргументов.
    Именованный аргумент <emphasis>не должен</emphasis> переопределять уже распакованный аргумент.
   </para>

   <example>
    <title>Пример использования именованных аргументов после распаковки</title>
    <programlisting role="php">
<![CDATA[
<?php
function foo($a, $b, $c = 3, $d = 4) {
  return $a + $b + $c + $d;
}
var_dump(foo(...[1, 2], d: 40)); // 46
var_dump(foo(...['b' => 2, 'a' => 1], d: 40)); // 46
var_dump(foo(...[1, 2], b: 20)); // Фатальная ошибка. Именованный аргумент $b переопределяет предыдущий аргумент
?>
]]>
    </programlisting>
   </example>

   </sect2>
 </sect1>

 <sect1 xml:id="functions.returning-values">
  <title>Возврат значений</title>

  <para>
   Значения возвращаются при помощи необязательного оператора возврата.
   Возвращаемые значения могут быть любого типа, в том числе это могут
   быть массивы и объекты. Возврат приводит к завершению выполнения функции и передаче
   управления обратно к той строке кода, в которой данная функция была
   вызвана. Для получения более детальной информации ознакомьтесь с описанием
   <function>return</function>.
  </para>
  <note>
   <para>
    Если конструкция <function>return</function> не указана, то функция вернёт
    значение &null;.
   </para>
  </note>

  <sect2>
   <title>Использование выражения return</title>
   <para>
    <example>
     <title>Использование конструкции <function>return</function></title>
     <programlisting role="php">
<![CDATA[
<?php
function square($num)
{
    return $num * $num;
}
echo square(4);   // выводит '16'.
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    Функция не может возвращать несколько значений, но аналогичного
    результата можно добиться, возвращая массив.
   </para>
   <para>
    <example>
     <title>Возврат нескольких значений в виде массива</title>
     <programlisting role="php">
<![CDATA[
<?php
function small_numbers()
{
    return [0, 1, 2];
}
// Деструктуризация массива будет собирать каждый элемент массива индивидуально
[$zero, $one, $two] = small_numbers();

// До версии 7.1.0 единственной эквивалентной альтернативой было использование конструкции list().
list($zero, $one, $two) = small_numbers();

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Для того, чтобы функция возвращала результат по ссылке, вам
    необходимо использовать оператор &amp; и при описании функции,
    и при присвоении переменной возвращаемого значения:
   </para>
   <para>
    <example>
     <title>Возврат результата по ссылке</title>
     <programlisting role="php">
<![CDATA[
<?php
function &returns_reference()
{
    return $someref;
}

$newref =& returns_reference();
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Для получения более детальной информации о ссылках обратитесь
    к разделу документации <link linkend="language.references">Подробно о ссылках</link>.
   </simpara>
  </sect2>
 </sect1>

 <sect1 xml:id="functions.variable-functions">
  <title>Обращение к функциям через переменные</title>

  <para>
   PHP поддерживает концепцию переменных функций. Это означает, что
   если к имени переменной присоединены круглые скобки, PHP ищет
   функцию с тем же именем, что и результат вычисления переменной, и
   пытается её выполнить. Эту возможность можно использовать для
   реализации обратных вызовов, таблиц функций и множества других вещей.
  </para>
  <para>
   Переменные функции не будут работать с такими языковыми конструкциями
   как <function>echo</function>, <function>print</function>,
   <function>unset</function>, <function>isset</function>,
   <function>empty</function>, <function>include</function>,
   <function>require</function> и т.п.
   Вам необходимо реализовать свою функцию-обёртку для того,
   чтобы приведённые выше конструкции могли работать с переменными
   функциями.
  </para>
  <para>
   <example>
    <title>Работа с функциями посредством переменных</title>
    <programlisting role="php">
<![CDATA[
<?php
function foo() {
    echo "В foo()<br />\n";
}

function bar($arg = '')
{
    echo "В bar(); аргумент был '$arg'.<br />\n";
}

// Функция-обёртка для echo
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // Вызывает функцию foo()

$func = 'bar';
$func('test');  // Вызывает функцию bar()

$func = 'echoit';
$func('test');  // Вызывает функцию echoit()
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Вы также можете вызвать методы объекта используя возможности PHP
   для работы с переменными функциями.
   <example>
    <title>Обращение к методам класса посредством переменных</title>
    <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Variable()
    {
        $name = 'Bar';
        $this->$name(); // Вызываем метод Bar()
    }

    function Bar()
    {
        echo "Это Bar";
    }
}

$foo = new Foo();
$funcname = "Variable";
$foo->$funcname();  // Обращаемся к $foo->Variable()

?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   При вызове статических методов вызов функции "сильнее",
   чем оператор доступа к статическому свойству:
   <example>
    <title>Пример вызова переменного метода со статическим свойством</title>
    <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static $variable = 'статическое свойство';
    static function Variable()
    {
        echo 'Вызов метода Variable';
    }
}

echo Foo::$variable; // Это выведет 'статическое свойство'. Переменная $variable будет разрешена в этой области видимости.
$variable = "Variable";
Foo::$variable();  // Это вызовет $foo->Variable(), прочитав $variable из этой области видимости.

?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Сложные callable-функции</title>
    <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static function bar()
    {
        echo "bar\n";
    }
    function baz()
    {
        echo "baz\n";
    }
}

$func = array("Foo", "bar");
$func(); // выведет "bar"
$func = array(new Foo, "baz");
$func(); // выведет "baz"
$func = "Foo::bar";
$func(); // выведет "bar"
?>
]]>
    </programlisting>
   </example>
  </para>

  <sect2 role="seealso">
   &reftitle.seealso;
   <para>
    <simplelist>
     <member><function>is_callable</function></member>
     <member><function>call_user_func</function></member>
     <member><function>function_exists</function></member>
     <member><link linkend="language.variables.variable">переменные переменных</link></member>
    </simplelist>
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="functions.internal">
  <title>Встроенные функции</title>

  <para>
   В самом PHP содержится достаточно большое количество встроенных функций
   и языковых конструкций. Также есть функции, которые требуют, чтобы PHP был
   собран с определёнными модулями, в противном случае будут генерироваться
   фатальные ошибки, вызванные использованием неизвестной функции.
   Например, для того чтобы использовать <link linkend="ref.image">функции для работы с изображениями</link>,
   например, <function>imagecreatetruecolor</function>, необходимо собрать PHP с
   поддержкой <productname>GD</productname>. Или же для того, чтобы воспользоваться
   функцией <function>mysqli_connect</function>, необходима  поддержка модуля
   <link linkend="book.mysqli">MySQLi</link>. Тем не менее, есть много встроенных
   функций, которые доступны всегда: например, <link linkend="ref.strings">функции обработки строк</link> и
   <link linkend="ref.var">функции для работы с переменными</link>.
   Вызвав <function>phpinfo</function> или <function>get_loaded_extensions</function>,
   можно узнать, поддержка каких модулей есть в используемом PHP.
   Также следует учесть, что поддержка некоторых дополнительных модулей
   включена по умолчанию, и что сама документация к PHP разбита по модулям.
   Ознакомьтесь с разделами <link linkend="configuration">Конфигурация</link>,
   <link linkend="install">Установка</link>, а также с документацией
   непосредственно к дополнительным модулям для получения более детальной
   информации о том, как настроить PHP.
  </para>
  <para>
   Более подробную информацию о том, как следует читать и интерпретировать
   прототипы функций, вы можете найти в разделе <link linkend="about.prototypes">Как читать определения функции</link>.
   Очень важно понимать, что возвращает функция,
   или как именно она модифицирует передаваемые аргументы. Например,
   функция <function>str_replace</function> возвращает модифицированную строку,
   в то время как функция <function>usort</function> работает с фактически
   переданной переменной. Каждая страница документации также содержит
   информацию, которая специфична для данной функции, например, информацию о
   передаваемых параметрах, изменениях в поведении, возвращаемых
   значениях в случае как удачного, так и неудачного выполнения, доступности
   функции в различных версиях. Знание и применение этих (порой даже незаметных)
   нюансов очень важно для написания корректного PHP-кода.
  </para>
  <note>
   <simpara>
    Если в функцию передаются не те аргументы, которые она ожидает,
    например, массив (<type>array</type>) вместо строки (<type>string</type>),
    возвращаемое значение функции не определено. Скорее всего
    в этом случае будет возвращён &null;, но это просто соглашение,
    на него нельзя полагаться.
    Начиная с PHP 8.0.0, в этом случае должно
    быть выброшено исключение <classname>TypeError</classname>.
   </simpara>
  </note>

  <note>
   <para>
    Скалярные типы для встроенных функций по умолчанию являются допускающими значение &null; в принудительном режиме.
    Начиная с PHP 8.1.0, передача &null; в параметр встроенной функции, который не объявлен как допускающий значение &null;,
    не рекомендуется и в принудительном режиме выдаётся уведомление об устаревании,
    чтобы соответствовать поведению пользовательских функций, где скалярные типы должны быть явно помечены как допускающие значение &null;.
   </para>

   <para>
    Например, функция <function>strlen</function> ожидает, что параметр <literal>$string</literal> будет строкой (&string;),
    не допускающей значение &null;.
    По историческим причинам PHP позволяет передавать &null; для этого параметра в принудительном режиме
    и параметр неявно приводится к строке (<type>string</type>), в результате чего получается значение <literal>""</literal>.
    В строгом режиме выбрасывается исключение <classname>TypeError</classname>.
   </para>

   <example>
    <programlisting role="php">
<![CDATA[
<?php
var_dump(strlen(null));
// "Deprecated: Passing null to parameter #1 ($string) of type string is deprecated" начиная с PHP 8.1.0
// int(0)

var_dump(str_contains("foobar", null));
// "Deprecated: Passing null to parameter #2 ($needle) of type string is deprecated" начиная с PHP 8.1.0
// bool(true)
?>
]]>
    </programlisting>
   </example>
  </note>

  <sect2 role="seealso">
   &reftitle.seealso;
   <para>
    <simplelist>
     <member><function>function_exists</function></member>
     <member><link linkend="funcref">справочник функций</link></member>
     <member><function>get_extension_funcs</function></member>
     <member><function>dl</function></member>
    </simplelist>
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="functions.anonymous">
  <title>Анонимные функции</title>

  <simpara>
   Анонимные функции, также известные как замыкания (<literal>closures</literal>),
   позволяют создавать функции, не имеющие определённых имён.
   Они наиболее полезны в качестве значений
   <type>callable</type>-параметров,
   но также могут иметь и множество других применений.
  </simpara>
  <simpara>
   Анонимные функции реализуются с использованием класса <link linkend="class.closure">
   <classname>Closure</classname></link>.
  </simpara>
  <example>
   <title>Пример анонимной функции</title>
   <programlisting role="php">
<![CDATA[
<?php
echo preg_replace_callback('~-([a-z])~', function ($match) {
    return strtoupper($match[1]);
}, 'hello-world');
// выведет helloWorld
?>
]]>
   </programlisting>
  </example>

  <simpara>
   Замыкания также могут быть использованы в качестве значений
   переменных; PHP автоматически преобразовывает такие выражения
   в экземпляры внутреннего класса <classname>Closure</classname>.
   Присвоение замыкания переменной использует тот же синтаксис,
   что и для любого другого присвоения, включая завершающую
   точку с запятой:
  </simpara>

  <example>
   <title>Пример присвоения анонимной функции переменной</title>
   <programlisting role="php">
<![CDATA[
<?php
$greet = function($name) {
    printf("Привет, %s\r\n", $name);
};

$greet('Мир');
$greet('PHP');
?>
]]>
   </programlisting>
  </example>

  <simpara>
   Замыкания могут также наследовать переменные из родительской
   области видимости. Любая подобная переменная должна быть
   объявлена в конструкции <literal>use</literal>. Начиная с
   PHP 7.1, эти переменные не должны включать &link.superglobals;,
   <varname>$this</varname> и переменные с теми же именами, что и
   параметры функции.
   Объявление типа возвращаемого значения функции должно быть помещено
    <emphasis>после</emphasis> конструкции <literal>use</literal>.
  </simpara>

  <example>
   <title>Наследование переменных из родительской области видимости</title>
   <programlisting role="php">
<![CDATA[
<?php
$message = 'привет';

// Без "use"
$example = function () {
    var_dump($message);
};
$example();

// Наследуем $message
$example = function () use ($message) {
    var_dump($message);
};
$example();

// Значение унаследованной переменной задано там, где функция определена,
// но не там, где вызвана
$message = 'мир';
$example();

// Сбросим message
$message = 'привет';

// Наследование по ссылке
$example = function () use (&$message) {
    var_dump($message);
};
$example();

// Изменённое в родительской области видимости значение
// остаётся тем же внутри вызова функции
$message = 'мир';
echo $example();

// Замыкания могут принимать обычные аргументы
$example = function ($arg) use ($message) {
    var_dump($arg . ', ' . $message);
};
$example("привет");

// Объявление типа возвращаемого значения идет после конструкции use
$example = function () use ($message): string {
    return "привет, $message";
};
var_dump($example());
?>
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Notice: Undefined variable: message in /example.php on line 6
NULL
string(12) "привет"
string(12) "привет"
string(12) "привет"
string(6) "мир"
string(20) "привет, мир"
string(20) "привет, мир"
]]>
   </screen>
  </example>
  <para>
   Начиная с PHP 8.0.0, список наследуемых переменных может завершаться запятой,
   которая будет проигнорирована.
  </para>
  <simpara>
   Наследование переменных из
   родительской области видимости <emphasis>не</emphasis> то же
   самое, что использование глобальных переменных.
   Глобальные переменные существуют в глобальной области видимости,
   которая не меняется, вне зависимости от того, какая функция
   выполняется в данный момент. Родительская область видимости —
   это функция, в которой было объявлено замыкание (не обязательно
   та же самая, из которой оно было вызвано). Смотрите следующий
   пример:
  </simpara>

  <example>
   <title>Замыкания и область видимости</title>
   <programlisting role="php">
<![CDATA[
<?php
// Базовая корзина покупок, содержащая список добавленных
// продуктов и количество каждого продукта. Включает метод,
// вычисляющий общую цену элементов корзины с помощью
// callback-замыкания.
class Cart
{
    const PRICE_BUTTER  = 1.00;
    const PRICE_MILK    = 3.00;
    const PRICE_EGGS    = 6.95;

    protected $products = array();

    public function add($product, $quantity)
    {
        $this->products[$product] = $quantity;
    }

    public function getQuantity($product)
    {
        return isset($this->products[$product]) ? $this->products[$product] :
               FALSE;
    }

    public function getTotal($tax)
    {
        $total = 0.00;

        $callback =
            function ($quantity, $product) use ($tax, &$total)
            {
                $pricePerItem = constant(__CLASS__ . "::PRICE_" .
                    strtoupper($product));
                $total += ($pricePerItem * $quantity) * ($tax + 1.0);
            };

        array_walk($this->products, $callback);
        return round($total, 2);
    }
}

$my_cart = new Cart;

// Добавляем несколько элементов в корзину
$my_cart->add('butter', 1);
$my_cart->add('milk', 3);
$my_cart->add('eggs', 6);

// Выводим общую сумму с 5% налогом на продажу.
print $my_cart->getTotal(0.05) . "\n";
// Результатом будет 54.29
?>
]]>
   </programlisting>
  </example>

  <example>
   <title>Автоматическое связывание <literal>$this</literal></title>
   <programlisting role="php">
<![CDATA[
<?php

class Test
{
    public function testing()
    {
        return function() {
            var_dump($this);
        };
    }
}

$object = new Test;
$function = $object->testing();
$function();

?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
object(Test)#1 (0) {
}
]]>
   </screen>
  </example>
  <para>
   При объявлении в контексте класса, текущий
   класс будет автоматически связан с ним, делая <literal>$this</literal>
   доступным внутри функций класса. Если вы не хотите автоматического
   связывания с текущим классом, используйте <link
   linkend="functions.anonymous-functions.static">статические анонимные функции</link>.
  </para>

  <sect2 xml:id="functions.anonymous-functions.static">
   <title>Статические анонимные функции</title>
   <para>
    Анонимные функции могут быть объявлены статически.
    Это предотвратит их автоматическое связывание с текущим классом.
    Объекты также не будут с ними связаны во время выполнения.
   </para>
   <para>
    <example>
     <title>Попытка использовать <literal>$this</literal> в статической анонимной функции</title>
     <programlisting role="php">
<![CDATA[
<?php

class Foo
{
    function __construct()
    {
        $func = static function() {
            var_dump($this);
        };
        $func();
    }
};
new Foo();

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Notice: Undefined variable: this in %s on line %d
NULL
]]>
     </screen>
    </example>
   </para>

   <para>
    <example>
     <title>Попытка связать объект со статической анонимной функцией</title>
     <programlisting role="php">
<![CDATA[
<?php

$func = static function() {
    // тело функции
};
$func = $func->bindTo(new stdClass);
$func();

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Warning: Cannot bind an instance to a static closure in %s on line %d
]]>
     </screen>
    </example>
   </para>
  </sect2>
  <sect2 role="changelog">
   &reftitle.changelog;
   <para>
    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>&Version;</entry>
        <entry>&Description;</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>7.1.0</entry>
        <entry>
         Анонимные функции не могут замыкаться вокруг &link.superglobals;,
         <varname>$this</varname> или любой переменной с тем же именем, что
         и параметр.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
  </sect2>

  <sect2 role="notes">
   &reftitle.notes;
   <note>
    <simpara>
     Внутри замыканий можно использовать функции
     <function>func_num_args</function>,
     <function>func_get_arg</function> и <function>func_get_args</function>.
    </simpara>
   </note>
  </sect2>

 </sect1>

 <sect1 xml:id="functions.arrow">
  <title>Стрелочные функции</title>

  <simpara>
   Стрелочные функции появились в PHP 7.4 как
   лаконичный синтаксис для <link linkend="functions.anonymous">анонимных функций</link>.
  </simpara>
  <simpara>
   И анонимные, и стрелочные функции реализованы
   через класс <link linkend="class.closure"><classname>Closure</classname></link>.
  </simpara>

  <simpara>
   Основной вид записи стрелочных функций:
   <code>fn (argument_list) =&gt; expr</code>.
  </simpara>

  <simpara>
   Стрелочные функции работают так же,
   как <link linkend="functions.anonymous">анонимные функции</link>,
   за исключением того, что доступ к переменным
   родительской области выполняется автоматически.
  </simpara>

  <simpara>
   Когда стрелочная функция использует переменную,
   которую определили в родительской области,
   переменная неявно захватывается по значению.
   В следующем примере функции <varname>$fn1</varname> и
   <varname>$fn2</varname> ведут себя одинаково.
  </simpara>

  <para>
   <example>
    <title>Стрелочные функции захватывают переменные по значению автоматически</title>
    <programlisting role="php">
<![CDATA[
<?php

$y = 1;

$fn1 = fn($x) => $x + $y;
// эквивалентно использованию $y по значению:
$fn2 = function ($x) use ($y) {
    return $x + $y;
};

var_export($fn1(3));

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
4
]]>
    </screen>
   </example>
  </para>
  <simpara>
   Это также работает во вложенных стрелочных функциях:
  </simpara>
  <para>
   <example>
    <title>Стрелочные функции захватывают переменные по значению автоматически, даже когда они вложены</title>
    <programlisting role="php">
<![CDATA[
<?php

$z = 1;
$fn = fn($x) => fn($y) => $x * $y + $z;
// Выведет 51
var_export($fn(5)(10));

?>
]]>
    </programlisting>
   </example>
  </para>
  <simpara>
   Подобно анонимным функциям,
   синтаксис стрелочных функций допускает произвольные сигнатуры функций,
   включая типы параметров и возвращаемых значений, значения по умолчанию, переменные,
   а также передачу и возврат по ссылке.
   Ниже приведены корректные примеры стрелочных функций:
  </simpara>
  <para>
   <example>
    <title>Примеры использования стрелочных функций</title>
    <programlisting role="php">
<![CDATA[
<?php

fn(array $x) => $x;
static fn(): int => $x;
fn($x = 42) => $x;
fn(&$x) => $x;
fn&($x) => $x;
fn($x, ...$rest) => $rest;

?>
]]>
    </programlisting>
   </example>
  </para>
  <simpara>
   Стрелочные функции используют привязку переменных по значению.
   Это примерно эквивалентно выполнению <code>use($x)</code> для каждой
   переменной <varname>$x</varname>, используемой внутри стрелочной функции.
   Привязка по значению означает, что невозможно изменить какие-либо значения
   из внешней области.
   Вместо этого можно использовать <link linkend="functions.anonymous">анонимные функции</link>
   для привязок по ссылкам.
  </simpara>
  <para>
   <example>
    <title>Стрелочные функции не умеют изменять значения из внешней области видимости</title>
    <programlisting role="php">
<![CDATA[
<?php

$x = 1;
$fn = fn() => $x++; // Ничего не изменит
$fn();
var_export($x);  // Выведет 1

?>
]]>
    </programlisting>
   </example>
  </para>

  <sect2 role="changelog">
   &reftitle.changelog;
   <para>
    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>&Version;</entry>
        <entry>&Description;</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>7.4.0</entry>
        <entry>
         Стали доступны стрелочные функции.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
  </sect2>

  <sect2 role="notes">
   &reftitle.notes;
   <note>
    <simpara>
     Можно вызывать функции <function>func_num_args</function>,
     <function>func_get_arg</function> и <function>func_get_args</function>
     в стрелочной функции.
    </simpara>
   </note>
  </sect2>
 </sect1>

 <sect1 xml:id="functions.first_class_callable_syntax">
  <title>Синтаксис callable-объектов первого класса</title>

  <para>
   Синтаксис callable-функций как объектов первого класса
   представили в PHP 8.1.0 как способ, которым создают
   <link linkend="functions.anonymous">анонимные функции</link>
   из <link linkend="language.types.callable">callable-объектов</link>.
   Он заменяет существующий синтаксис вызываемых объектов
   со строками и массивами.
   Преимущество синтаксиса состоит в том,
   что он доступен для статического анализа
   и использует область видимости точки, в которой callable-объект был получен.
  </para>

  <para>
   Синтаксис <code>CallableExpr(...)</code>
   создаёт объект <classname>Closure</classname> из callable-объекта.
   Часть <code>CallableExpr</code> принимает любое выражение,
   которое можно непосредственно вызвать в грамматике PHP:
   <example>
    <title>Простой пример синтаксиса callable-объекта первого класса</title>
    <programlisting role="php">
<![CDATA[
<?php

class Foo {
   public function method() {}
   public static function staticmethod() {}
   public function __invoke() {}
}
$obj = new Foo();
$classStr = 'Foo';
$methodStr = 'method';
$staticmethodStr = 'staticmethod';
$f1 = strlen(...);
$f2 = $obj(...);  // Вызываемый объект
$f3 = $obj->method(...);
$f4 = $obj->$methodStr(...);
$f5 = Foo::staticmethod(...);
$f6 = $classStr::$staticmethodStr(...);
// Традиционный callable-синтаксис со строками и массивами
$f7 = 'strlen'(...);
$f8 = [$obj, 'method'](...);
$f9 = [Foo::class, 'staticmethod'](...);

?>
]]>
    </programlisting>
   </example>
  </para>

  <note>
   <para>
    Многоточие <code>...</code> — часть синтаксиса, а не пропуск.
   </para>
  </note>

  <para>
   У выражения <code>CallableExpr(...)</code> та же семантика,
   что и у метода <methodname>Closure::fromCallable</methodname>.
   То есть, в отличие от callable-синтаксиса
   со строками и массивами, синтаксис <code>CallableExpr(...)</code>
   учитывает область видимости в той точке, в которой он создан:
   <example>
    <title>
     Сравнение области действия синтаксиса <code>CallableExpr(...)</code>
     и традиционного callable-синтаксиса
    </title>
    <programlisting role="php">
<![CDATA[
<?php

class Foo {
    public function getPrivateMethod() {
        return [$this, 'privateMethod'];
    }
    private function privateMethod() {
        echo __METHOD__, "\n";
    }
}
$foo = new Foo;
$privateMethod = $foo->getPrivateMethod();
$privateMethod();
// Fatal error: Call to private method Foo::privateMethod() from global scope
// Причина фатальной ошибки в том, что вызов выполнен за пределами класса Foo, и с этого момента будет проверяться видимость.

class Foo1 {
    public function getPrivateMethod() {
        // Использует область видимости, в которой получен callable-объект.
        return $this->privateMethod(...); // Идентично вызову Closure::fromCallable([$this, 'privateMethod']);
    }
    private function privateMethod() {
        echo __METHOD__, "\n";
    }
}
$foo1 = new Foo1;
$privateMethod = $foo1->getPrivateMethod();
$privateMethod();  // Foo1::privateMethod

?>
]]>
    </programlisting>
   </example>

  </para>

  <note>
   <para>
    Создание объекта этим синтаксисом (например, <code>new Foo(...)</code>)
    не поддерживается, поскольку синтаксис <code>new Foo()</code>
    не признаётся вызовом.
   </para>
  </note>

  <note>
   <para>
    Синтаксис callable-объектов первого класса
    нельзя комбинировать
    с <link linkend="language.oop5.basic.nullsafe">оператором Nullsafe</link>.
    Оба следующих результата приводят к ошибке времени компиляции:
    <example>
     <programlisting role="php">
<![CDATA[
<?php

$obj?->method(...);
$obj?->prop->method(...);

?>
]]>
     </programlisting>
    </example>
   </para>
  </note>
 </sect1>

</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
