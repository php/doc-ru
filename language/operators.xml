<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 995eaea8640022c0337a0e5d1bcab4a9df92d8e2 Maintainer: shein Status: ready -->
<!-- $Revision$ -->
<!-- Reviewed: yes -->
<chapter xml:id="language.operators" xmlns="http://docbook.org/ns/docbook">
 <title>Операторы</title>
 <simpara>
  Оператором называется нечто, принимающее одно или более значений (или выражений,
  если говорить на жаргоне программирования), и вычисляющее новое
  значение (таким образом, вся конструкция может рассматриваться как выражение).
 </simpara>
 <para>
  Операторы можно сгруппировать по количеству принимаемых ими значений. Унарные
  операторы принимают только одно значение, например, <literal>!</literal>
  (<link linkend="language.operators.logical">оператор логического отрицания</link>)
  или <literal>++</literal> (<link linkend="language.operators.increment">инкремент</link>).
  Бинарные операторы принимают два значения; это, например, знакомые
  всем <link linkend="language.operators.arithmetic">арифметические операторы</link>
  <literal>+</literal> (плюс) и <literal>-</literal> (минус), большинство поддерживаемых в
  PHP операторов входят именно в эту категорию. Ну и, наконец, есть всего один
  <link linkend="language.operators.comparison.ternary">тернарный оператор</link>,
  <literal>? :</literal>, принимающий три значения, обычно его так и называют -- "тернарный
  оператор" (хотя, возможно, более точным названием было бы "условный оператор").
 </para>
 <para>
  Полный список PHP-операторов вы можете найти в разделе
  "<link linkend="language.operators.precedence">Порядок выполнения операторов</link>".
  В этом разделе также описан порядок выполнения операторов и их ассоциативность, которые
  точно определяют, как вычисляются выражения с несколькими разными операторами.
 </para>
 
 <sect1 xml:id="language.operators.precedence">
  <title>Приоритет оператора</title>
  <para>
   Приоритет оператора определяет, насколько "тесно" он связывает между собой два
   выражения. Например, выражение  <literal>1 + 5 * 3</literal> вычисляется как
   <literal>16</literal>, а не <literal>18</literal>, поскольку оператор умножения ("*") имеет
   более высокий приоритет, чем оператор сложения ("+"). Круглые скобки могут
   использоваться для принудительного указания порядка выполнения операторов. Например,
   выражение <literal>(1 + 5) * 3</literal> вычисляется как <literal>18</literal>.
  </para>
  <para>
   Если операторы имеют равный приоритет, то будут ли они выполняться справа налево или
   слева направо определяется их ассоциативностью. К примеру, "-" является 
   лево-ассоциативным оператором. Следовательно <literal>1 - 2 - 3</literal> сгруппируется 
   как <literal>(1 - 2) - 3</literal> и пересчитается в <literal>-4</literal>. С другой стороны
   "=" - право-ассоциативный оператор, так что <literal>$a = $b = $c</literal> сгруппируется
   как <literal>$a = ($b = $c)</literal>.
  </para>
  <para>
   Неассоциативные операторы с одинаковым приоритетом не могут использоваться совместно.
   К примеру <literal>1 &lt; 2 &gt; 1</literal> не будет работать в PHP. Выражение
   <literal>1 &lt;= 1 == 1</literal>, с другой стороны, будет, поскольку <literal>==</literal>
   имеет более низкий приоритет чем <literal>&lt;=</literal>.
  </para>
  <para>
   Использование скобок, кроме случаев когда они строго необходимы, может улучшить
   читаемость кода, группируя явно, а не полагаясь на приоритеты и ассоциативность.
  </para>
  <para>
   В следующей таблице приведен список операторов, отсортированный по
   убыванию их приоритетов. Операторы, размещенные в одной строке имеют
   одинаковый приоритет и порядок их выполнения определяется исходя из
   их ассоциативности.
   <table>
    <title>Порядок выполнения операторов</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Ассоциативность</entry>
       <entry>Оператор</entry>
       <entry>Дополнительная информация</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>неассоциативна</entry>
       <entry>
        <literal>clone</literal>
        <literal>new</literal>
       </entry>
       <entry><link linkend="language.oop5.cloning">clone</link> и <link linkend="language.oop5.basic.new">new</link></entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry>[</entry>
       <entry><function>array</function></entry>
      </row>
      <row>
       <entry>правая</entry>
       <entry><literal>**</literal></entry>
       <entry><link linkend="language.operators.arithmetic">арифметические операторы</link></entry>
      </row>
      <row>
       <entry>правая</entry>
       <entry>
        <literal>++</literal> 
        <literal>--</literal> 
        <literal>~</literal> 
        <literal>(int)</literal> 
        <literal>(float)</literal> 
        <literal>(string)</literal> 
        <literal>(array)</literal>
        <literal>(object)</literal> 
        <literal>(bool)</literal> 
        <literal>@</literal>
       </entry>
       <entry>
        <link linkend="language.types">типы</link> и <link linkend="language.operators.increment">инкремент/декремент</link>
       </entry>
      </row>
      <row>
       <entry>неассоциативна</entry>
       <entry>instanceof</entry>
       <entry>
        <link linkend="language.types">типы</link>
       </entry>
      </row>
      <row>
       <entry>правая</entry>
       <entry>!</entry>
       <entry>
        <link linkend="language.operators.logical">логические операторы</link>
       </entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry>
        <literal>*</literal>
        <literal>/</literal>
        <literal>%</literal>
       </entry>
       <entry>
        <link linkend="language.operators.arithmetic">арифметические операторы</link>
       </entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry>
        <literal>+</literal> 
        <literal>-</literal> 
        <literal>.</literal>
       </entry>
       <entry>
        <link linkend="language.operators.arithmetic">арифметические операторы</link>&listendand;
        <link linkend="language.operators.string">строковые операторы</link></entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry>
        <literal>&lt;&lt;</literal> 
        <literal>&gt;&gt;</literal>
       </entry>
       <entry>
        <link linkend="language.operators.bitwise">побитовые операторы</link>
       </entry>
      </row>
      <row>
       <entry>неассоциативна</entry>
       <entry>
        <literal>&lt;</literal> 
        <literal>&lt;=</literal> 
        <literal>&gt;</literal> 
        <literal>&gt;=</literal>
       </entry>
       <entry>
        <link linkend="language.operators.comparison">операторы сравнения</link>
       </entry>
      </row>
      <row>
       <entry>неассоциативна</entry>
       <entry>
        <literal>==</literal>
        <literal>!=</literal> 
        <literal>===</literal> 
        <literal>!==</literal> 
        <literal>&lt;&gt;</literal>
        <literal>&lt;=&gt;</literal>
       </entry>
       <entry>
        <link linkend="language.operators.comparison">операторы сравнения</link>
       </entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry><literal>&amp;</literal></entry>
       <entry>
        <link linkend="language.operators.bitwise">побитовые операторы</link>&listendand;
        <link linkend="language.references">ссылки</link></entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry><literal>^</literal></entry>
       <entry>
        <link linkend="language.operators.bitwise">побитовые операторы</link>
       </entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry><literal>|</literal></entry>
       <entry>
        <link linkend="language.operators.bitwise">побитовые операторы</link>
       </entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry><literal>&amp;&amp;</literal></entry>
       <entry>
        <link linkend="language.operators.logical">логические операторы</link>
       </entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry><literal>||</literal></entry>
       <entry>
        <link linkend="language.operators.logical">логические операторы</link>
       </entry>
      </row>
      <row>
       <entry>правая</entry>
       <entry><literal>??</literal></entry>
       <entry>
        <link linkend="language.operators.comparison">операторы сравнения</link>
       </entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry><literal>? :</literal></entry>
       <entry>
        <link linkend="language.operators.comparison.ternary">тернарный оператор</link>
       </entry>
      </row>
      <row>
       <entry>правая</entry>
       <entry>
        <literal>=</literal> 
        <literal>+=</literal> 
        <literal>-=</literal> 
        <literal>*=</literal> 
        <literal>**=</literal> 
        <literal>/=</literal> 
        <literal>.=</literal> 
        <literal>%=</literal> 
        <literal>&amp;=</literal> 
        <literal>|=</literal> 
        <literal>^=</literal> 
        <literal>&lt;&lt;=</literal> 
        <literal>&gt;&gt;=</literal>
       </entry>
       <entry>
        <link linkend="language.operators.assignment">операторы присваивания</link>
       </entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry><literal>and</literal></entry>
       <entry>
        <link linkend="language.operators.logical">логические операторы</link>
       </entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry><literal>xor</literal></entry>
       <entry>
        <link linkend="language.operators.logical">логические операторы</link>
       </entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry><literal>or</literal></entry>
       <entry>
        <link linkend="language.operators.logical">логические операторы</link>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
  <para>
   <example>
    <title>Ассоциативность</title>
    <programlisting role="php">
<![CDATA[
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
// ассоциативность тернарного оператора отличается от  C/C++
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Приоритет и ассоциативность оператора определяет только то, как группируется 
    выражение, а не порядок его вычисления. Обычно PHP не указывает, в каком порядке 
    вычисляются выражения и кода, который предполагает специфичный порядок вычисления
    следует избегать, потому, что поведение может меняться в разных версиях PHP или
    в зависимости от окружающего кода.
    
    <example>
     <title>Неопределенный порядок вычисления</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 1;
echo $a + $a++; // может вывести как 2 так и 3

$i = 1;
$array[$i] = $i++; // может установить индекс как 1 так 2
?>
]]>
      </programlisting>
     </example>
     <example>
      <title><literal>+</literal>, <literal>-</literal> и <literal>.</literal> имеют одинаковый приоритет</title>
      <programlisting role="php">
<![CDATA[
<?php
$x = 4;
// следующий код может выдать неожиданный результат:
echo "x минус 1 равно " . $x-1 . ", ну я надеюсь\n";
// поскольку он вычисляется таким образом::
echo (("x минус один равно " . $x) - 1) . ", ну я надеюсь\n";
// требуемый приоритет следует задать скобками:
echo "x минус 1 равно " . ($x-1) . ", ну я надеюсь\n";
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
-1, or so I hope
-1, or so I hope
x минус один равно 3, ну я надеюсь
]]>
      </screen>
     </example>
   </para>
   <note>
    <para>
     Несмотря на то, что <literal>=</literal> имеет более низкий приоритет чем большинство
     других операторов, PHP все же позволяет делать так: <literal>if (!$a = foo())</literal>,
     в этом примере результат выполнения <literal>foo()</literal> будет присвоен
     <varname>$a</varname>.
    </para>
   </note>
  </sect1>
  
  <sect1 xml:id="language.operators.arithmetic">
   <title>Арифметические операторы</title>
   <simpara>
    Помните школьные основы арифметики? Описанные ниже операторы работают так же.
   </simpara>
   <table>
    <title>Арифметические операции</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>+$a</entry>
       <entry>Идентичность</entry>
       <entry>
        Конвертация <varname>$a</varname> в <type>int</type> или
        <type>float</type>, что более подходит.
       </entry>
      </row>
      <row>
       <entry>-$a</entry>
       <entry>Отрицание</entry>
       <entry>Смена знака <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a + $b</entry>
       <entry>Сложение</entry>
       <entry>Сумма <varname>$a</varname> и <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>Вычитание</entry>
       <entry>Разность <varname>$a</varname> и <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>Умножение</entry>
       <entry>Произведение <varname>$a</varname> и <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>Деление</entry>
       <entry>Частное от деления <varname>$a</varname> на <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>Деление по модулю</entry>
       <entry>Целочисленный остаток от деления <varname>$a</varname> на <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a ** $b</entry>
       <entry>Возведение в степень</entry>
       <entry>Возведение <varname>$a</varname> в степень <varname>$b</varname>.
        Добавлено в PHP 5.6.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    Операция деления ("/") возвращает число с плавающей точкой, кроме случая,
    когда оба значения являются целыми числами (или строками, которые преобразуются
    в целые числа), которые делятся нацело - в этом случае возвращается целое значение.
    Для целочисленного деления используйте <function>intdiv</function>.
   </simpara>
   <simpara>
    При делении по модулю операнды преобразуются в целые числа (удалением дробной части)
    до начала операции. Для деления по модую чисел с плавающей точкой используйте
    <function>fmod</function>.
   </simpara>
   <para>
    Результат операции остатка от деления <literal>%</literal> будет иметь тот же знак,
    что и делимое — то есть, результат <literal>$a % $b</literal>
    будет иметь тот же знак, что и <varname>$a</varname>. Например:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

echo (5 % 3)."\n";           // выводит 2
echo (5 % -3)."\n";          // выводит 2
echo (-5 % 3)."\n";          // выводит -2
echo (-5 % -3)."\n";         // выводит -2

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Также вы можете ознакомиться с разделом документации
    <link linkend="ref.math">Математические функции</link>.
   </simpara>
   
  </sect1>
  
  <sect1 xml:id="language.operators.assignment">
   <title>Оператор присваивания</title>
   <simpara>
    Базовый оператор присваивания обозначается как "=". На первый взгляд
    может показаться, что это оператор "равно". На самом деле это не так.
    В действительности, оператор присваивания означает, что левый операнд
    получает значение правого выражения, (т.е. устанавливается значением).
   </simpara>
   <para>
    Результатом выполнения оператора присваивания является само присвоенное значение.
    Таким образом, результат выполнения "<literal>$a = 3</literal>" будет равен
    3. Это позволяет делать трюки наподобие:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = ($b = 4) + 5; // $a теперь равно 9, а $b было присвоено 4.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    В дополнение к базовому оператору присваивания имеются "комбинированные операторы"
    для всех  <link linkend="language.operators">бинарных арифметических</link> операций,
    операций объединения массивов и строковых операций, которые позволяют
    использовать некоторое значение в выражении, а затем установить его как
    результат данного выражения. Например:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = 3;
$a += 5; // устанавливает $a в 8, как если бы мы написали: $a = $a + 5;
$b = "Hello ";
$b .= "There!"; // устанавливает $b в "Hello There!",  как и $b = $b . "There!";

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Обратите внимание, что присвоение копирует оригинальную переменную в новую
    (присвоение по значению), таким образом все последующие изменения
    одной из переменных никак не отразятся на другой. Это также следует учитывать,
    если вам надо скопировать что-то типа большого массива в длинном цикле.
   </para>
   <para>
    Исключением из обычного для PHP способа присваивания по значению явлаются объекты
    (<type>object</type>), которые, начиная с версии PHP 5, присваиваются по ссылке.
    Принудительно скопировать объекты по значению можно с помощью
    специального ключевого слова <link linkend="language.oop5.cloning">clone</link>.
   </para>
   
   <sect2 xml:id="language.operators.assignment.reference">
    <title>Присваивание по ссылке</title>
    <para>
     Присваивание по ссылке также поддерживается, для него используется синтаксис
     <computeroutput>$var = &amp;$othervar;</computeroutput>.
     'Присваивание по ссылке' означает, что обе переменные указывают на
     одни и те же данные и никакого копирования не происходит.
    </para>
    <para>
     <example>
      <title>Присваивание по ссылке</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 3;
$b = &$a; // $b - это ссылка на $a

print "$a\n"; // печатает 3
print "$b\n"; // печатает 3

$a = 4; // меняем $a

print "$a\n"; // печатает 4
print "$b\n"; // также печатает 4, так как $b является ссылкой на $a,
              // а значение переменной $a успело измениться
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Начиная с версии PHP 5, оператор <link linkend="language.oop5.basic.new">new</link>
     автоматически возвращает ссылку, поэтому присваивание результата операции
     <link linkend="language.oop5.basic.new">new</link> по ссылке начиная с версии PHP 5.3
     генерирует ошибку уровня <constant>E_DEPRECATED</constant>, а в более ранних
     версиях - ошибку уровня <constant>E_STRICT</constant>.
    </para>
    <para>
     Например, следующий код выдаст предупреждение:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

/* Следующая строка сгенерирует следующее сообщение об ошибке:
 * Deprecated: Assigning the return value of new by reference is deprecated in...
 * (Устаревший код: Присвоение результата работы new по ссылке устарело в...)
 */
$o = &new C;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Для получения более полной информации о ссылках и их возможностях обратитесь к
     разделу <link linkend="language.references">Подробно о ссылках</link>.
    </para>
   </sect2>
  </sect1>
  
  <sect1 xml:id="language.operators.bitwise">
   <title>Побитовые операторы</title>
   <simpara>
    Побитовые операторы позволяют считывать и устанавливать конкретные биты
    целых чисел.
   </simpara>
   <table>
    <title>Побитовые операторы</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><userinput>$a &amp; $b</userinput></entry>
       <entry>И</entry>
       <entry>Устанавливаются только те биты, которые установлены и в <varname>$a</varname>, и в <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><userinput>$a | $b</userinput></entry>
       <entry>Или</entry>
       <entry>Устанавливаются те биты, которые установлены в <varname>$a</varname> или в <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><userinput>$a ^ $b</userinput></entry>
       <entry>Исключающее или</entry>
       <entry>
        Устанавливаются только те биты, которые установлены либо только в <varname>$a</varname>,
        либо только в <varname>$b</varname>, но не в обоих одновременно.
       </entry>
      </row>
      <row>
       <entry><userinput>~ $a</userinput></entry>
       <entry>Отрицание</entry>
       <entry>
        Устанавливаются те биты, которые не установлены в <varname>$a</varname>, и наоборот.
       </entry>
      </row>
      <row>
       <entry><userinput>$a &lt;&lt; $b</userinput></entry>
       <entry>Сдвиг влево</entry>
       <entry>
        Все биты переменной <varname>$a</varname> сдвигаются на <varname>$b</varname>
        позиций влево (каждая позиция подразумевает "умножение на 2")
       </entry>
      </row>
      <row>
       <entry><userinput>$a &gt;&gt; $b</userinput></entry>
       <entry>Сдвиг вправо</entry>
       <entry>
        Все биты переменной <varname>$a</varname> сдвигаются на <varname>$b</varname> позиций вправо
        (каждая позиция подразумевает "деление на 2")
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Побитовый сдвиг в PHP - это арифметическая операция.
    Биты, сдвинутые за границы числа, отбрасываются.
    Сдвиг влево дополняет число нулями справа, сдвигая в то же время знаковый бит числа
    влево, что означает что знак операнда не сохраняется.
    Сдвиг вправо сохраняет копию сдвинутого знакового бита слева, что означает
    что знак операнда сохраняется.
   </para>
   <para>
    Используйте скобки для обеспечения необходимого
    <link linkend="language.operators.precedence"> приоритета операторов</link>.
    Например, <literal>$a &amp; $b == true</literal> сначала проверяет
    на равенство, а потом выполняет побитовое и; тогда как
    <literal>($a &amp; $b) == true</literal> сначала выполняет побитовое и,
    а потом выполняет проверку на равенство.
   </para>
   <para>
    Если оба операдна для <literal>&amp;</literal>, <literal>|</literal> и
    <literal>^</literal> строки, то операция будет производиться с кодами ASCII всех
    символов строки и в результате вернет строку. Во всех остальных случаях, оба операнда
    будут <link linkend="language.types.integer.casting">преобразованы к целому</link> и
    результатом будет целое число.
   </para>
   <para>
    Если операнд для <literal>~</literal> строка, то операция будет производиться с кодами
    ASCII всех символов строки и в результате вернет строку, в ином случае как операнд,
    так и результат, будут считаться цемыми.
   </para>
   <para>
    Оба операнда и результат выполнения <literal>&lt;&lt;</literal> и 
    <literal>&gt;&gt;</literal> всегда считаются за целое.
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
       Опция настроек PHP error_reporting использует побитовые значения, обеспечивая
       реальную демонстрацию гашения значений битов. Чтобы показать все ошибки кроме
       замечаний, инструкции в файле php.ini предлагают использовать:
       <userinput>E_ALL &amp; ~E_NOTICE</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
       Начинаем со значения E_ALL:
       <computeroutput>00000000000000000111011111111111</computeroutput>
       Затем берем значение E_NOTICE...
       <computeroutput>00000000000000000000000000001000</computeroutput>
       ... и инвертируем его с помощью <literal>~</literal>:
       <computeroutput>11111111111111111111111111110111</computeroutput>
       Наконец, используем побитовое И (&amp;), чтобы установить только те биты,
       которые установлены в единицу в обоих значениях:
       <computeroutput>00000000000000000111011111110111</computeroutput>
      </literallayout>
     </para>
     <para>
      <literallayout>
       Другой способ достичь этого - использовать ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR, <literal>^</literal>),
       чтобы получить только те биты, которые установлены в единицу
       либо только в одном, либо только в другом значении:
       <userinput>E_ALL ^ E_NOTICE</userinput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
       Опция error_reporting также может быть использована для демонстрации
       установки битов. Показать только ошибки и обрабатываемые ошибки можно
       следующим образом:
       <userinput>E_ERROR | E_RECOVERABLE_ERROR</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
       Здесь мы комбинируем E_ERROR
       <computeroutput>00000000000000000000000000000001</computeroutput>
       и
       <computeroutput>00000000000000000001000000000000</computeroutput>
       с помощью оператора ИЛИ (<literal>|</literal>),
       чтобы получить биты, установленные хотя бы в одном операнде:
       <computeroutput>00000000000000000001000000000001</computeroutput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <example>
     <title>Побитовыми операции И, ИЛИ и ИСКЛЮЧАЮЩЕЕ ИЛИ (AND, OR и XOR) над целыми числами</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Не обращайте внимания на этот верхний раздел кода,
 * это просто форматирование для более ясного вывода.
 */

$format = '(%1$2d = %1$04b) = (%2$2d = %2$04b)'
        . ' %3$s (%4$2d = %4$04b)' . "\n";

echo <<<EOH
 ---------     ---------  -- ---------
 результат     значение   оп   тест
 ---------     ---------  -- ---------
EOH;


/*
 * Вот сами примеры.
 */

$values = array(0, 1, 2, 4, 8);
$test = 1 + 4;

echo "\n Побитовое И (AND) \n";
foreach ($values as $value) {
    $result = $value & $test;
    printf($format, $result, $value, '&', $test);
}

echo "\n Побитовое (включающее) ИЛИ (OR) \n";
foreach ($values as $value) {
    $result = $value | $test;
    printf($format, $result, $value, '|', $test);
}

echo "\n Побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR) \n";
foreach ($values as $value) {
    $result = $value ^ $test;
    printf($format, $result, $value, '^', $test);
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
 ---------     ---------  -- ---------
 результат     значение   оп   тест
 ---------     ---------  -- ---------
 Побитовое И (AND)
( 0 = 0000) = ( 0 = 0000) & ( 5 = 0101)
( 1 = 0001) = ( 1 = 0001) & ( 5 = 0101)
( 0 = 0000) = ( 2 = 0010) & ( 5 = 0101)
( 4 = 0100) = ( 4 = 0100) & ( 5 = 0101)
( 0 = 0000) = ( 8 = 1000) & ( 5 = 0101)

 Побитовое (включающее) ИЛИ (OR)
( 5 = 0101) = ( 0 = 0000) | ( 5 = 0101)
( 5 = 0101) = ( 1 = 0001) | ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) | ( 5 = 0101)
( 5 = 0101) = ( 4 = 0100) | ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) | ( 5 = 0101)

 Побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR)
( 5 = 0101) = ( 0 = 0000) ^ ( 5 = 0101)
( 4 = 0100) = ( 1 = 0001) ^ ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) ^ ( 5 = 0101)
( 1 = 0001) = ( 4 = 0100) ^ ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) ^ ( 5 = 0101)
]]>
     </screen>
    </example>
   </para>
   <para>
    <example>
     <title>Побитовая операция ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR) над строками</title>
     <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // Выводит '5'

echo "12" ^ "9"; // Выводит символ Backspace (ascii 8)
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; // Выводит ascii значения #0 #4 #0 #0 #0
                        // 'a' ^ 'e' = #4

echo 2 ^ "3"; // Выводит 1
              // 2 ^ ((int)"3") == 1

echo "2" ^ 3; // Выводит 1
              // ((int)"2") ^ 3 == 1
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Побитовый сдвиг над целыми числами</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Несколько примеров.
 */

echo "\n--- СДВИГ ВПРАВО НАД ПОЛОЖИТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---\n";

$val = 4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'слева была вставлена копия знакового бита');

$val = 4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places);

$val = 4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'биты были выдвинуты за правый край');

$val = 4;
$places = 4;
$res = $val >> $places;
p($res, $val, '>>', $places, 'то же, что и выше; нельзя сдвинуть дальше 0');


echo "\n--- СДВИГ ВПРАВО НАД ОТРИЦАТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---\n";

$val = -4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'слева была вставлена копия знакового бита');

$val = -4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places, 'биты были выдвинуты за правый край');

$val = -4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'то же, что и выше; нельзя сдвинуть дальше -1');


echo "\n--- СДВИГ ВЛЕВО НАД ПОЛОЖИТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---\n";

$val = 4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'правый край был дополнен нулями');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 4;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = 4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places, 'знаковые биты были выдвинуты');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'биты были выдвинуты за левый край');


echo "\n--- СДВИГ ВЛЕВО НАД ОТРИЦАТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---\n";

$val = -4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'правый край был дополнен нулями');

$val = -4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = -4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'биты были выдвинуты за левый край, включая знаковый бит');


/*
 * Не обращайте внимания на этот нижний раздел кода,
 * это просто форматирование для более ясного вывода.
 */

function p($res, $val, $op, $places, $note = '') {
    $format = '%0' . (PHP_INT_SIZE * 8) . "b\n";

    printf("Выражение: %d = %d %s %d\n", $res, $val, $op, $places);

    echo " Десятичный вид:\n";
    printf("  val=%d\n", $val);
    printf("  res=%d\n", $res);

    echo " Двоичный вид:\n";
    printf('  val=' . $format, $val);
    printf('  res=' . $format, $res);

    if ($note) {
        echo " ЗАМЕЧАНИЕ: $note\n";
    }

    echo "\n";
}
?>
]]>
     </programlisting>
     &example.outputs.32bit;
     <screen>
<![CDATA[

--- СДВИГ ВПРАВО НАД ПОЛОЖИТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---
Выражение: 2 = 4 >> 1
 Десятичный вид:
  val=4
  res=2
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000010
 ЗАМЕЧАНИЕ: слева была вставлена копия знакового бита 

Выражение: 1 = 4 >> 2
 Десятичный вид:
  val=4
  res=1
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000001

Выражение: 0 = 4 >> 3
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были выдвинуты за правый край

Выражение: 0 = 4 >> 4
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 ЗАМЕЧАНИЕ: то же, что и выше; нельзя сдвинуть дальше 0


--- СДВИГ ВПРАВО НА ОТРИЦАТЕЛЬНЫХ ЦЕЛЫХ ЧИСЛАХ ---
Выражение: -2 = -4 >> 1
 Десятичный вид:
  val=-4
  res=-2
 Двоичный вид:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111110
 ЗАМЕЧАНИЕ: слева была вставлена копия знакового бита

Выражение: -1 = -4 >> 2
 Десятичный вид:
  val=-4
  res=-1
 Двоичный вид:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 ЗАМЕЧАНИЕ: биты были выдвинуты за правый край

Выражение: -1 = -4 >> 3
 Десятичный вид:
  val=-4
  res=-1
 Двоичный вид:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 ЗАМЕЧАНИЕ: то же, что и выше; нельзя сдвинуть дальше -1


--- СДВИГ ВЛЕВО НАД ПОЛОЖИТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---
Выражение: 8 = 4 << 1
 Десятичный вид:
  val=4
  res=8
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000001000
 ЗАМЕЧАНИЕ: правый край был дополнен нулями

Выражение: 1073741824 = 4 << 28
 Десятичный вид:
  val=4
  res=1073741824
 Двоичный вид:
  val=00000000000000000000000000000100
  res=01000000000000000000000000000000

Выражение: -2147483648 = 4 << 29
 Десятичный вид:
  val=4
  res=-2147483648
 Двоичный вид:
  val=00000000000000000000000000000100
  res=10000000000000000000000000000000
 ЗАМЕЧАНИЕ: знаковые биты были выдвинуты

Выражение: 0 = 4 << 30
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были выдвинуты за левый край


--- СДВИГ ВЛЕВО НАД ОТРИЦАТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---
Выражение: -8 = -4 << 1
 Десятичный вид:
  val=-4
  res=-8
 Двоичный вид:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111000
 ЗАМЕЧАНИЕ: правый край был дополнен нулями

Выражение: -2147483648 = -4 << 29
 Десятичный вид:
  val=-4
  res=-2147483648
 Двоичный вид:
  val=11111111111111111111111111111100
  res=10000000000000000000000000000000

Выражение: 0 = -4 << 30
 Десятичный вид:
  val=-4
  res=0
 Двоичный вид:
  val=11111111111111111111111111111100
  res=00000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были выдвинуты за левый край, включая знаковый бит
]]>
     </screen>
     &example.outputs.64bit;
     <screen>
<![CDATA[

--- СДВИГ ВПРАВО НАД ПОЛОЖИТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---
Выражение: 2 = 4 >> 1
 Десятичный вид:
  val=4
  res=2
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000010
 ЗАМЕЧАНИЕ: слева была вставлена копия знакового бита

Выражение: 1 = 4 >> 2
 Десятичный вид:
  val=4
  res=1
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000001

Выражение: 0 = 4 >> 3
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были выдвинуты за правый край

Выражение: 0 = 4 >> 4
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 ЗАМЕЧАНИЕ: то же, что и выше; нельзя сдвинуть дальше 0


--- СДВИГ ВПРАВО НАД ОТРИЦАТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---
Выражение: -2 = -4 >> 1
 Десятичный вид:
  val=-4
  res=-2
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111110
 ЗАМЕЧАНИЕ: слева была вставлена копия знакового бита

Выражение: -1 = -4 >> 2
 Десятичный вид:
  val=-4
  res=-1
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 ЗАМЕЧАНИЕ: биты были выдвинуты за правый край

Выражение: -1 = -4 >> 3
 Десятичный вид:
  val=-4
  res=-1
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 ЗАМЕЧАНИЕ: то же, что и выше; нельзя сдвинуть дальше -1


--- СДВИГ ВЛЕВО НАД ПОЛОЖИТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---
Выражение: 8 = 4 << 1
 Десятичный вид:
  val=4
  res=8
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000001000
 ЗАМЕЧАНИЕ: правый край был дополнен нулями

Выражение: 4611686018427387904 = 4 << 60
 Десятичный вид:
  val=4
  res=4611686018427387904
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0100000000000000000000000000000000000000000000000000000000000000

Выражение: -9223372036854775808 = 4 << 61
 Десятичный вид:
  val=4
  res=-9223372036854775808
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=1000000000000000000000000000000000000000000000000000000000000000
 ЗАМЕЧАНИЕ: знаковые биты были выдвинуты

Выражение: 0 = 4 << 62
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были выдвинуты за левый край


--- СДВИГ ВЛЕВО НАД ОТРИЦАТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---
Выражение: -8 = -4 << 1
 Десятичный вид:
  val=-4
  res=-8
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111000
 ЗАМЕЧАНИЕ: правый край был дополнен нулями

Выражение: -9223372036854775808 = -4 << 61
 Десятичный вид:
  val=-4
  res=-9223372036854775808
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1000000000000000000000000000000000000000000000000000000000000000

Выражение: 0 = -4 << 62
 Десятичный вид:
  val=-4
  res=0
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=0000000000000000000000000000000000000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были выдвинуты за левый край, включая знаковый бит
]]>
     </screen>
    </example>
   </para>
   <warning>
    <para>
     В PHP до версии 7.0 никогда не используйте отрицательный побитовый сдвиг, либо сдвиг
     превышающий разрядность операционной системы - это может привести к
     неопределенному результату. Другими словами, не сдвигайте больше чем на 31 бит на 
     32-битных системах и больше чем на 63 бита на 64-битных.
    </para>
    <para>
     Используйте функции из расширения <link linkend="book.gmp">gmp</link> для побитовых
     операций над числами, большими чем <literal>PHP_INT_MAX</literal>.
    </para>
   </warning>
   <para>
    Смотрите также
    <function>pack</function>,
    <function>unpack</function>,
    <function>gmp_and</function>,
    <function>gmp_or</function>,
    <function>gmp_xor</function>,
    <function>gmp_testbit</function>,
    <function>gmp_clrbit</function>
   </para>
  </sect1>
  
  <sect1 xml:id="language.operators.comparison">
   <title>Операторы сравнения</title>
   <simpara>
    Операторы сравнения, как это видно из их названия, позволяют сравнивать между собой
    два значения. Возможно вам будет интересно также ознакомиться с разделом  
    <link linkend="types.comparisons">Сравнение типов</link>, в котором приведено большое
    количество соответствующих примеров.
   </simpara>
   <table>
    <title>Операторы сравнения</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>Равно</entry>
       <entry>&true; если <varname>$a</varname> равно <varname>$b</varname>
        после преобразования типов.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Тождественно равно</entry>
       <entry>
        &true; если <varname>$a</varname> равно <varname>$b</varname> и имеет тот же тип.
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Не равно</entry>
       <entry>&true; если <varname>$a</varname> не равно <varname>$b</varname>
        после преобразования типов.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Не равно</entry>
       <entry>&true; если <varname>$a</varname> не равно <varname>$b</varname>
        после преобразования типов.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Тождественно не равно</entry>
       <entry>
        &true; если <varname>$a</varname> не равно <varname>$b</varname> или они разных типов.
       </entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>Меньше</entry>
       <entry>&true; если <varname>$a</varname> строго меньше <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>Больше</entry>
       <entry>&true; если <varname>$a</varname> строго больше <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>Меньше или равно</entry>
       <entry>&true; если <varname>$a</varname> меньше или равно <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>Больше или равно</entry>
       <entry>&true; если <varname>$a</varname> больше или равно <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &lt;=&gt; $b</entry>
       <entry>Спейсшип (космический корабль)</entry>
       <entry>
        Число типа <type>integer</type> меньше, больше или равное нулю, когда
        <varname>$a</varname> соответственно меньше, больше или равно
        <varname>$b</varname>. Доступно PHP 7.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    В случае, если вы сравниваете число со строкой или две строки, содержащие числа,
    каждая строка будет <link linkend="language.types.string.conversion">преобразована в
    число</link>, и сравниваться они будут как числа. Эти правила также распространяются на
    оператор <link linkend="control-structures.switch">switch</link>.
    Преобразование типов не происходит при использовании === или !==
    так как в этом случае кроме самих значений сравниваются еще и типы.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a"); // 0 == 0 -> true
var_dump("1" == "01"); // 1 == 1 -> true
var_dump("10" == "1e1"); // 10 == 10 -> true
var_dump(100 == "1e2"); // 100 == 100 -> true

switch ("a") {
case 0:
    echo "0";
    break;
case "a": // Эта ветка никогда не будет достигнута, так как "a" уже сопоставленно с 0
    echo "a";
    break;
}
?>
]]>
     </programlisting>
     <programlisting role="php">
<![CDATA[
<?php  
// Целые
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1
 
// С плавающей точкой
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1
 
// Строки
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1
 
echo "a" <=> "aa"; // -1
echo "zz" <=> "aa"; // 1
 
// Массивы
echo [] <=> []; // 0
echo [1, 2, 3] <=> [1, 2, 3]; // 0
echo [1, 2, 3] <=> []; // 1
echo [1, 2, 3] <=> [1, 2, 1]; // 1
echo [1, 2, 3] <=> [1, 2, 4]; // -1
 
// Объекты
$a = (object) ["a" => "b"]; 
$b = (object) ["a" => "b"]; 
echo $a <=> $b; // 0
 
$a = (object) ["a" => "b"]; 
$b = (object) ["a" => "c"]; 
echo $a <=> $b; // -1
 
$a = (object) ["a" => "c"]; 
$b = (object) ["a" => "b"]; 
echo $a <=> $b; // 1
 
// сравниваются только значения
$a = (object) ["a" => "b"]; 
$b = (object) ["b" => "b"]; 
echo $a <=> $b; // 1

?>
]]>
      
     </programlisting>
    </informalexample>
   </para>
   
   <para>
    Для различных типов сравнение происходит в соответствии со следующей
    таблицей (по порядку).
   </para>
   <table xml:id="language.operators.comparison.types">
    <title>Сравнение различных типов</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Тип операнда 1</entry>
       <entry>Тип операнда 2</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>null</type> или <type>string</type></entry>
       <entry><type>string</type></entry>
       <entry>&null; преобразуется в "", числовое или лексическое сравнение</entry>
      </row>
      <row>
       <entry><type>bool</type> или <type>null</type></entry>
       <entry>что угодно</entry>
       <entry>Преобразуется в <type>bool</type>, &false; &lt; &true;</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry><type>object</type></entry>
       <entry>Встроенные классы могут определять свои собственные правила сравнения,
        объекты разных классов не сравниваются, объекты одного класса - сравниваются
        свойства тем же способом, что и в массивах (PHP 4), в PHP 5 есть свое собственное <link
        linkend="language.oop5.object-comparison">объяснение</link>
       </entry>
      </row>
      <row>
       <entry><type>string</type>, <type>resource</type> или <type>number</type></entry>
       <entry><type>string</type>, <type>resource</type> или <type>number</type></entry>
       <entry>Строки и ресурсы переводятся в числа, обычная математика</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry><type>array</type></entry>
       <entry>Массивы с меньшим числом элементов считаются меньше,
        если ключ из первого операнда не найден во втором операнде
        - массивы не могут сравниваться, иначе идет сравнение соответствующих
        значений (смотри пример ниже)</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry>что угодно</entry>
       <entry><type>array</type> всегда больше</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry>что угодно</entry>
       <entry><type>object</type> всегда больше</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   
   <para>
    <example>
     <title>Логические/null сравнение</title>
     <programlisting role="php">
<![CDATA[
<?php
// Логические значения и null всегда сравниваются как логические
var_dump(1 == TRUE);  // TRUE - то же, что и (bool)1 == TRUE
var_dump(0 == FALSE); // TRUE - то же, что и (bool)0 == FALSE
var_dump(100 < TRUE); // FALSE - то же, что и (bool)100 < TRUE
var_dump(-10 < FALSE);// FALSE - то же, что и (bool)-10 < FALSE
var_dump(min(-100, -10, NULL, 10, 100)); // NULL - (bool)NULL < (bool)-100 это FALSE < TRUE
?>
]]>
     </programlisting>
    </example>
   </para>
   
   <para>
    <example>
     <title>Алгоритм сравнения обычных массивов</title>
     <programlisting role="php">
<![CDATA[
<?php
// Так сравниваются массивы при сравнении стандартными операторами
function standard_array_compare($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }
    foreach ($op1 as $key => $val) {
        if (!array_key_exists($key, $op2)) {
            return null; // не могут быть сравнимы
        } elseif ($val < $op2[$key]) {
            return -1;
        } elseif ($val > $op2[$key]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?>
]]>
     </programlisting>
    </example>
   </para>
   
   <para>
    Смотрите также <function>strcasecmp</function>, <function>strcmp</function>,
    <link linkend="language.operators.array">операторы массивов</link>,
    и раздел руководства<link linkend="language.types">Типы</link>.
   </para>
   
   <warning>
    <title>Сравнение чисел с плавающей точкой</title>
    
    <para>
     Из-за особого внутреннего представления <type>float</type>, не нужно
     проверять на равенство два <type>float</type>-числа.
    </para>
    
    <para>
     Для более подробной информации смотрите документацию по типу <type>float</type>.
    </para>
   </warning>
   
   <sect2 xml:id="language.operators.comparison.ternary">
    <title>Тернарный оператор</title>
    <para>
     Еще одним условным оператором является тернарный оператор "?:".
     <example>
      <title>Присваивание значения по умолчанию</title>
      <programlisting role="php">
<![CDATA[
<?php
// Пример использования тернарного оператора
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// Приведенный выше код аналогичен следующему блоку с использованием if/else
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}

?>
]]>
      </programlisting>
     </example>
     Выражение <literal>(expr1) ? (expr2) : (expr3)</literal>
     интерпретируется как <replaceable>expr2</replaceable>, если
     <replaceable>expr1</replaceable> имеет значение &true;, или как
     <replaceable>expr3</replaceable> если
     <replaceable>expr1</replaceable> имеет значение &false;.
    </para>
    <para>
     Начиная с версии PHP 5.3 также стало возможным не писать среднюю часть
     тернарного оператора. Выражение <literal>expr1 ?: expr3</literal>
     возвращает <replaceable>expr1</replaceable> если <replaceable>expr1</replaceable>
     имеет значение &true;, и <replaceable>expr3</replaceable> в другом случае.
    </para>
    <note>
     <simpara>
      Пожалуйста учтите, что тернарный оператор является выражением
      и трактуется не как переменная, а как результат выражения. Это важно знать,
      если вы хотите вернуть переменную по ссылке.
      Выражение <literal>return $var == 42 ? $a : $b;</literal> не будет
      работать в функции, возвращающей значение по ссылке, а в более поздних
      версиях PHP также будет выдано предупреждение.
     </simpara>
    </note>
    <note>
     <para>
      Рекомендуется избегать "нагромождения" тернарных выражений.
      Поведение PHP неочевидно при использовании нескольких тернарных операторов
      в одном выражении:
      <example>
       <title>Неочевидное поведение тернарного оператора</title>
       <programlisting role="php">
<![CDATA[
<?php
// на первый взгляд, следующий код должен вывести 'true'
echo (true?'true':false?'t':'f');

// однако, он выводит 't'
// это происходит потому, что тернарные выражения вычисляются слева направо

// это намного более очевидная версия вышеприведенного кода
echo ((true ? 'true' : false) ? 't' : 'f');

// здесь вы можете видеть, что первое выражение вычисляется в 'true', которое
// в свою очередь вычисляется в (bool)true, таким образом возвращая истинную ветвь
// второго тернарного выражения.
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2>
   <sect2 xml:id="language.operators.comparison.coalesce">
    <!-- я вот хз, как правильно перевести -->
    <title>Оператор null coalescing</title>
    <para>
     Также, начиная с PHP 7, добавился новый оператор "??" (или null coalescing).
     <example>
      <title>Присваивание значения по умолчанию</title>
      <programlisting role="php">
<![CDATA[
<?php
// Пример использования оператора
$action = $_POST['action'] ?? 'default';

// Пример выше аналогичен следующему коду
if (isset($_POST['action'])) {
    $action = $_POST['action'];
} else {
    $action = 'default';
}

?>
]]>
      </programlisting>
     </example>
     Выражение <literal>(expr1) ?? (expr2)</literal> вычисляется так:
     <replaceable>expr2</replaceable>, если <replaceable>expr1</replaceable> равен
     &null;, и <replaceable>expr1</replaceable> в ином случае.
    </para>
    <para>
     На практике, этот оператор не вызывает предупреждения, если левый операнд не
     существует, прям как <function>isset</function>. Это очень полезно для ключей массива.
    </para>
    <note>
     <simpara>
      Пожалуйста помните, что этот оператор является выражением, и он приравнивается к
      выражению, а не значению переменной. Это может быть важным, если вы хотите
      вернуть значение по ссылке. Выражение <literal>return $foo ?? $bar;</literal> в
      функции возвращающей ссылку будет не работать, а выводить предупреждение.
     </simpara>
    </note>
    <note>
     <para>
      Пожалуйста помните, что этот оператор позволяет использовать простую вложенность:
      <example>
       <title>Вложенный оператор null coalescing</title>
       <programlisting role="php">
<![CDATA[
<?php

$foo = null;
$bar = null;
$baz = 1;
$qux = 2;

echo $foo ?? $bar ?? $baz ?? $qux; // выведет 1

?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2> 
  </sect1>
  
  <sect1 xml:id="language.operators.errorcontrol">
   <title>Оператор управления ошибками</title>
   <simpara>
    PHP поддерживает один оператор управления ошибками: знак (@).
    В случае, если он предшествует какому-либо выражению в PHP-коде, любые
    сообщения об ошибках, генерируемые этим выражением, будут проигнорированы.
   </simpara>
   <simpara>
    Если вы установили собственную функцию обработки ошибок с помощью
    <function>set_error_handler</function>, то она все равно будет вызвана,
    однако, если внутри этой функции будет вызвана функция
    <function>error_reporting</function>, то она вернет 0, если функция,
    вызвавшая данную ошибку, была подавлена с помощью @.
   </simpara>
   <simpara>
    В случае, если установлена опция <link linkend="ini.track-errors"><option>track_errors</option></link>,
    все генерируемые сообщения об ошибках будут сохраняться в переменной
    <varname>$php_errormsg</varname>.
    Эта переменная будет перезаписываться при каждой новой ошибке,
    поэтому в случае необходимости проверяйте ее сразу же.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Преднамеренная ошибка при работе с файлами
$my_file = @file ('non_existent_file') or
    die ("Ошибка при открытии файла: сообщение об ошибке было таким: '$php_errormsg'");

// работает для любых выражений, а не только для функций
$value = @$cache[$key];
// В случае если ключа $key нет, сообщение об ошибке (notice) не будет отображено

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     Оператор @ работает только с
     <link linkend="language.expressions">выражениями</link>.
     Есть простое правило: если что-то возвращает
     значение, значит вы можете использовать перед ним оператор
     @. Например, вы можете использовать @ перед
     именем переменной, произвольной функцией или вызовом <function>include</function>,
     константой и так далее. В то же время вы не можете использовать этот оператор
     перед определением функции или класса, условными конструкциями, такими как  <literal>if</literal>,
     &foreach; и т.д.
    </simpara>
   </note>
   <simpara>
    Также ознакомьтесь с описанием функции <function>error_reporting</function>
    и разделом руководства
    <link linkend="ref.errorfunc">Обработка ошибок и функции логирования</link>.
   </simpara>
   <warning>
    <para>
     На сегодняшний день оператор "@" подавляет вывод сообщений даже о критических
     ошибках, прерывающих работу скрипта. Помимо всего прочего, это означает, что если вы
     использовали "@" для подавления ошибок, возникающих при работе какой-либо
     функции, в случае если она недоступна или написана неправильно, дальнейшая
     работа скрипта будет остановлена без каких-либо уведомлений.
    </para>
   </warning>
  </sect1>
  
  <sect1 xml:id="language.operators.execution">
   <title>Операторы исполнения</title>
   <para>
    PHP поддерживает один оператор исполнения: обратные кавычки (``). Обратите
    внимание, что это не одинарные кавычки! PHP попытается выполнить строку,
    заключенную в обратные кавычки, как консольную команду, и вернет
    полученный вывод (т.е. он не просто выводится на экран, а, например, может
    быть присвоен переменной). Использование обратных кавычек аналогично
    использованию функции <function>shell_exec</function>.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     Обратные кавычки недоступны, в случае, если включен &safemode; или
     отключена функция <function>shell_exec</function>.
    </para>
   </note>
   <note>
    <para>
     В отличие от некоторых других языков, обратные кавычки не
     будут работать внутри строк в двойных кавычках.
    </para>
   </note>
   <para>
    Ознакомьтесь также со следующими разделами документации:
    <link linkend="ref.exec">Функции для выполнения программ</link>,
    <function>popen</function>  <function>proc_open</function>, и
    <link linkend="features.commandline">Использование PHP в командной строке</link>.
   </para>
  </sect1>
  
  <sect1 xml:id="language.operators.increment">
   <title>Операторы инкремента и декремента</title>
   <para>
    PHP поддерживает префиксные и постфиксные операторы инкремента и декремента
    в стиле C.
   </para>
   <note>
    <simpara>
     Операторы инкремента/декремента не влияют на булевы значения.
     Декремент &null; также не даст никакого эффекта, однако инкремент
     даст значение <literal>1</literal>.
    </simpara>
   </note>
   <table>
    <title>Операторы инкремента и декремента</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Действие</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>Префиксный инкремент</entry>
       <entry>Увеличивает <varname>$a</varname> на единицу, затем возвращает значение <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>Постфиксный инкремент</entry>
       <entry>Возвращает значение <varname>$a</varname>, затем увеличивает <varname>$a</varname> на единицу.</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>Префиксный декремент</entry>
       <entry>Уменьшает <varname>$a</varname> на единицу, затем возвращает значение <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>Постфиксный декремент</entry>
       <entry>Возвращает значение <varname>$a</varname>, затем уменьшает <varname>$a</varname> на единицу.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Приведем пример простого скрипта:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>Постфиксный инкремент</h3>";
$a = 5;
echo "Должно быть 5: " . $a++ . "<br />\n";
echo "Должно быть 6: " . $a . "<br />\n";

echo "<h3>Префиксный инкремент</h3>";
$a = 5;
echo "Должно быть 6: " . ++$a . "<br />\n";
echo "Должно быть 6: " . $a . "<br />\n";

echo "<h3>Постфиксный декремент</h3>";
$a = 5;
echo "Должно быть 5: " . $a-- . "<br />\n";
echo "Должно быть 4: " . $a . "<br />\n";

echo "<h3>Префиксный декремент</h3>";
$a = 5;
echo "Должно быть 4: " . --$a . "<br />\n";
echo "Должно быть 4: " . $a . "<br />\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    PHP следует соглашениям Perl (в отличие от С) касательно выполнения
    арифметических операций с символьными переменными. Например, в PHP и Perl
    <literal>$a = 'Z'; $a++;</literal> присвоит <literal>$a</literal>
    значение <literal>'AA'</literal>, в то время как в C
    <literal>a = 'Z'; a++;</literal> присвоит <literal>a</literal>
    значение <literal>'['</literal> (ASCII значение
    <literal>'Z'</literal> равно 90, а ASCII значение
    <literal>'['</literal> равно 91). Следует учесть, что к
    символьным переменным можно применять операцию инкремента,
    в то время как операцию декремента применять нельзя, кроме того,
    поддерживаются только ASCII символы (a-z и A-Z).
    Попытка инкремента/декремента других символьных переменных не
    будет иметь никакого эффекта, исходная строка останется
    неизменной.
    <example>
     <title>Арифметические операции с символьными переменными</title>
     <programlisting role="php">
<![CDATA[
<?php
echo '== Буквы ==' . PHP_EOL;
$s = 'W';
for ($n=0; $n<6; $n++) {
    echo ++$s . PHP_EOL;
}
// С цифрами несколько по другому
echo '== Цифры ==' . PHP_EOL;
$d = 'A8';
for ($n=0; $n<6; $n++) {
    echo ++$d . PHP_EOL;
}
$d = 'A08';
for ($n=0; $n<6; $n++) {
    echo ++$d . PHP_EOL;
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
== Буквы ==
X
Y
Z
AA
AB
AC
== Цифры ==
A9
B0
B1
B2
B3
B4
A09
A10
A11
A12
A13
A14
]]>
     </screen>
    </example>
   </para>
   <para>
    Инкрементирование или декрементирование булевых переменных не приводит ни к какому результату.
   </para>
  </sect1>
  
  <sect1 xml:id="language.operators.logical">
   <title>Логические операторы</title>
   
   <table>
    <title>Логические операторы</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>И</entry>
       <entry>&true; если и <varname>$a</varname>, и <varname>$b</varname> &true;.</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>Или</entry>
       <entry>&true; если или <varname>$a</varname>, или <varname>$b</varname> &true;.</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>Исключающее или</entry>
       <entry>&true; если <varname>$a</varname>, или <varname>$b</varname> &true;, но не оба.</entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>Отрицание</entry>
       <entry>&true; если <varname>$a</varname> не &true;.</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>И</entry>
       <entry>&true; если и <varname>$a</varname>, и <varname>$b</varname> &true;.</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>Или</entry>
       <entry>&true; если или <varname>$a</varname>, или <varname>$b</varname> &true;.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    Смысл двух разных вариантов для операторов "and" и "or" в том, что
    они работают с различными приоритетами (смотрите таблицу
    <link linkend="language.operators.precedence">Приоритет выполнения операторов</link>).
   </simpara>
   <example>
    <title>Объяснение логических операторов</title>
    <programlisting role="php">
<![CDATA[
<?php

// --------------------
// foo() никогда не буде вызвана, так как эти операторы являются шунтирующими (short-circuit)

$a = (false && foo());
$b = (true  || foo());
$c = (false and foo());
$d = (true  or  foo());

// --------------------
// "||" имеет больший приоритет, чем "or"

// Результат выражения (false || true) присваивается переменной $e
// Действует как: ($e = (false || true))
$e = false || true;

// Константа false присваивается $f, а затем значение true игнорируется
// Действует как: (($f = false) or true)
$f = false or true;

var_dump($e, $f);

// --------------------
// "&&" имеет больший приоритет, чем "and"

// Результат выражения (true && false) присваивается переменной $g
// Действует как: ($g = (true && false))
$g = true && false;

// Константа true присваивается $h, а затем значение false игнорируется
// Действует как: (($h = true) and false)
$h = true and false;

var_dump($g, $h);
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
bool(true)
bool(false)
bool(false)
bool(true)
]]>
    </screen>
   </example>
  </sect1>
  
  <sect1 xml:id="language.operators.string">
   <title>Строковые операторы</title>
   <simpara>
    В PHP есть два оператора для работы со строками (<type>string</type>).
    Первый - оператор конкатенации ('.'), который возвращает строку, представляющую
    собой соединение левого и правого аргумента. Второй - оператор присваивания с
    конкатенацией ('<literal>.=</literal>'), который присоединяет правый аргумент к левому.
    Для получения более полной информации ознакомьтесь с разделом
    <link linkend="language.operators.assignment">Операторы присваивания</link>.
   </simpara>
   
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = "Hello ";
$b = $a . "World!"; // $b теперь содержит строку "Hello World!"

$a = "Hello ";
$a .= "World!";     // $a теперь содержит строку "Hello World!"
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Также ознакомьтесь с разделами документации
    <link linkend="language.types.string">Строки</link> и
    <link linkend="ref.strings">Функции для работы со строками</link>.
   </para>
  </sect1>
  
  <sect1 xml:id="language.operators.array">
   <title>Операторы, работающие с массивами</title>
   <table>
    <title>Операторы, работающие с массивами</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>Объединение</entry>
       <entry>Объединение массива <varname>$a</varname> и массива <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a == $b</entry>
       <entry>Равно</entry>
       <entry>&true; в случае, если <varname>$a</varname> и <varname>$b</varname> содержат одни и те же пары ключ/значение.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Тождественно равно</entry>
       <entry>&true; в случае, если <varname>$a</varname> и <varname>$b</varname>
        содержат одни и те же пары ключ/значение в том же самом порядке и того же типа.
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Не равно</entry>
       <entry>&true;, если массив <varname>$a</varname> не равен массиву <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Не равно</entry>
       <entry>&true;, если массив <varname>$a</varname> не равен массиву <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Тождественно не равно</entry>
       <entry>&true;, если массив <varname>$a</varname> не равен тождественно массиву <varname>$b</varname>.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Оператор <literal>+</literal> возвращает левый массив, к которому
    был присоединен правый массив. Для ключей, которые существуют в
    обоих массивах, будут использованы значения из левого массива, а
    соответствующие им элементы из правого массива будут проигнорированы.
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "apple", "b" => "banana");
$b = array("a" => "pear", "b" => "strawberry", "c" => "cherry");

$c = $a + $b; // Объединение $a и $b
echo "Union of \$a and \$b: \n";
var_dump($c);

$c = $b + $a; // Объединение $b и $a
echo "Union of \$b and \$a: \n";
var_dump($c);

$a += $b; // Объединение $a += $b, это $a и $b
echo "Объединение of \$a += \$b: \n";
var_dump($a);
?>
]]>
     </programlisting>
    </informalexample>
    После своего выполнения скрипт напечатает следующее:
    <screen role="php">
<![CDATA[
Union of $a and $b:
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}
Union of $b and $a:
array(3) {
  ["a"]=>
  string(4) "pear"
  ["b"]=>
  string(10) "strawberry"
  ["c"]=>
  string(6) "cherry"
}

Объединение $a += $b:
array(3) {
  'a' =>
  string(5) "apple"
  'b' =>
  string(6) "banana"
  'c' =>
  string(6) "cherry"
}
]]>
    </screen>
   </para>
   <para>
    При сравнении элементы массива считаются идентичными, если совпадает
    и ключ, и соответствующее ему значение.
   </para>
   <para>
    <example>
     <title>Сравнение массивов</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("apple", "banana");
$b = array(1 => "banana", "0" => "apple");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Также ознакомьтесь с разделами
    <link linkend="language.types.array">Массивы</link> и
    <link linkend="ref.array">Функции для работы с массивами</link>.
   </para>
  </sect1>
  <sect1 xml:id="language.operators.type">
   <title>Оператор проверки типа</title>
   <para>
    Оператор <literal>instanceof</literal> используется для определения того,
    является ли текущий объект экземпляром указанного
    <link linkend="language.oop5.basic.class">класса</link>.
    <example>
     <title>Использование <literal>instanceof</literal> с классами</title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

class NotMyClass
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof NotMyClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    Оператор <literal>instanceof</literal> также может быть использован
    для определения, наследует ли определенный объект какому-либо классу:
    <example>
     <title>Использование <literal>instanceof</literal> с наследуемыми классами</title>
     <programlisting role="php">
<![CDATA[
<?php
class ParentClass
{
}

class MyClass extends ParentClass
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof ParentClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Для проверки <emphasis>непринадлежности</emphasis> объекта некоторому классу,
    используйте <link linkend="language.operators.logical">логический оператор
    <literal>not</literal></link>.
    <example>
     <title>Использование <literal>instanceof</literal> для проверки того, что объект
      <emphasis>не</emphasis> является экземпляром класса</title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

$a = new MyClass;
var_dump(!($a instanceof stdClass));
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Ну и наконец, <literal>instanceof</literal> может быть также использован для проверки
    реализации объектом некоторого <link
    linkend="language.oop5.interfaces">интерфейса</link>:
    <example>
     <title>Использование <literal>instanceof</literal> для класса</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof MyInterface);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Хотя <literal>instanceof</literal> обычно используется с прямо указанным именем класса,
    он также может быть использован с другим объектом или строковой переменной:
    <example>
     <title>Использование <literal>instanceof</literal> с другими переменными</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;
$b = new MyClass;
$c = 'MyClass';
$d = 'NotMyClass';

var_dump($a instanceof $b); // $b это объект класса MyClass
var_dump($a instanceof $c); // $c это строка 'MyClass'
var_dump($a instanceof $d); // $d это строка 'NotMyClass'
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    Оператор instanceof не генерирует никаких ошибок, если проверяемая переменная не
    является объектом. В этом случае он просто возвращает &false;. Константы, тем не менее,
    не допускаются.
    <example>
     <title>Пример использования оператора <literal>instanceof</literal> для проверки других переменных</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = NULL;
$c = imagecreate(5, 5);
var_dump($a instanceof stdClass); // $a это целое типа integer
var_dump($b instanceof stdClass); // $b это NULL
var_dump($c instanceof stdClass); // $c это значение типа resource
var_dump(FALSE instanceof stdClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(false)
bool(false)
bool(false)
PHP Fatal error:  instanceof expects an object instance, constant given
]]>
     </screen>
    </example>
   </para>
   <para>
    Есть несколько подводных камней, которых следует остерегаться.  До версии PHP 5.1.0,
    <literal>instanceof</literal> вызывал <function>__autoload</function> если имя класса не
    существовало. Вдобавок, если класс не был загружен, происходила фатальная ошибка. Это
    можно было обойти с помощью динамической ссылки на класс или использования строковой
    переменной с именем класса:
    <example>
     <title>Избежание поиска класса и фатальных ошибок с <literal>instanceof</literal> в PHP 5.0</title>
     <programlisting role="php">
<![CDATA[
<?php
$d = 'NotMyClass';
var_dump($a instanceof $d); // нет фатальной ошибки
?>
     ]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(false)
]]>
     </screen>
    </example>
   </para>
   <simpara>
    Оператор <literal>instanceof</literal> был добавлен в PHP 5. До этого времени
    использовалась функция <function>is_a</function>, но позже <function>is_a</function>
    была помечена устаревшей в пользу <literal>instanceof</literal>. Учтите, что с версии PHP
    5.3.0, <function>is_a</function> больше не является устаревшей.
   </simpara>
   <para>
    Ознакомьтесь также с описанием функций <function>get_class</function> и
    <function>is_a</function>.
   </para>
  </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
