<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 84b8fca68fc762fefe85acde180a38b2e77a28b9 Maintainer: shein Status: ready -->
<!-- $Revision$ -->
<!-- Reviewed: yes -->
 <chapter xml:id="language.operators" xmlns="http://docbook.org/ns/docbook">
  <title>Операторы</title>
  <simpara>
   Оператором называется нечто, принимающее одно или более значений (или выражений,
   если говорить на жаргоне программирования), и вычисляющее новое
   значение (таким образом, вся конструкция может рассматриваться как выражение).
  </simpara>
  <para>
   Операторы можно сгруппировать по количеству принимаемых ими
   значений. Унарные операторы принимают только одно значение,
   например, <literal>!</literal>
   (<link linkend="language.operators.logical">оператор логического отрицания</link>)
   или <literal>++</literal> (<link linkend="language.operators.increment">инкремент</link>).
   Бинарные операторы принимают два значения; это, например, знакомые
   всем <link linkend="language.operators.arithmetic">арифметические операторы</link>
   <literal>+</literal> (плюс) и <literal>-</literal> (минус),
   большинство поддерживаемых в PHP операторов входят именно в эту
   категорию. Ну и, наконец, есть всего один
   <link linkend="language.operators.comparison.ternary">тернарный оператор</link>,
   <literal>? :</literal>, принимающий три значения, обычно его так и называют --
   "тернарный оператор" (хотя, возможно, более точным названием
   было бы "условный оператор").
  </para>
  <para>
   Полный список PHP-операторов вы можете найти в разделе
   "<link linkend="language.operators.precedence">Порядок выполнения операторов</link>".
   В нем также описан порядок выполнения операторов и их ассоциативность,
   которые точно определяют, как вычисляются выражения с несколькими
   разными операторами.
  </para>

  <sect1 xml:id="language.operators.precedence">
   <title>Приоритет оператора</title>
   <para>
    Приоритет оператора определяет, насколько "тесно" он связывает между
    собой два выражения. Например, выражение  <literal>1 +
    5 * 3</literal> вычисляется как <literal>16</literal>, а не
    <literal>18</literal>, поскольку оператор умножения ("*") имеет
    более высокий приоритет, чем оператор сложения ("+").
    Круглые скобки могут использоваться для принудительного указания
    порядка выполнения операторов. Например, выражение <literal>(1 + 5) * 3</literal>
    вычисляется как <literal>18</literal>.
   </para>
   <para>
    Если операторы имеют равный приоритет, то будут ли они выполняться
    справа налево или слева направо определяется их ассоциативностью -
    смотрите примеры ниже.
   </para>
   <para>
    В следующей таблице приведен список операторов, отсортированный по
    убыванию их приоритетов. Операторы, размещенные в одной строке имеют
    одинаковый приоритет и порядок их выполнения определяется исходя из
    их ассоциативности.
    <table>
     <title>Порядок выполнения операторов</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Ассоциативность</entry>
        <entry>Оператор</entry>
        <entry>Дополнительная информация</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>неассоциативна</entry>
        <entry>clone new</entry>
        <entry><link linkend="language.oop5.cloning">clone</link> и <link linkend="language.oop5.basic.new">new</link></entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>[</entry>
        <entry><function>array</function></entry>
       </row>
       <row>
        <entry>неассоциативна</entry>
        <entry>++ --</entry>
        <entry>
         <link linkend="language.operators.increment">инкремент/декремент</link>
        </entry>
       </row>
       <row>
        <entry>правая</entry>
        <entry>~ - (int) (float) (string) (array) (object) (bool) @</entry>
        <entry>
         <link linkend="language.types">типы</link>
        </entry>
       </row>
       <row>
        <entry>неассоциативна</entry>
        <entry>instanceof</entry>
        <entry>
         <link linkend="language.types">типы</link>
        </entry>
       </row>
       <row>
        <entry>правая</entry>
        <entry>!</entry>
        <entry>
         <link linkend="language.operators.logical">логические операторы</link>
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>* / %</entry>
        <entry>
         <link linkend="language.operators.arithmetic">арифметические операторы</link>
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>+ - .</entry>
        <entry>
         <link linkend="language.operators.arithmetic">арифметические операторы</link>&listendand;
         <link linkend="language.operators.string">строковые операторы</link></entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
        <entry>
         <link linkend="language.operators.bitwise">побитовые операторы</link>
        </entry>
       </row>
       <row>
        <entry>неассоциативна</entry>
        <entry>&lt; &lt;= &gt; &gt;= &lt;&gt;</entry>
        <entry>
         <link linkend="language.operators.comparison">операторы сравнения</link>
        </entry>
       </row>
       <row>
        <entry>неассоциативна</entry>
        <entry>== != === !==</entry>
        <entry>
         <link linkend="language.operators.comparison">операторы сравнения</link>
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>&amp;</entry>
        <entry>
         <link linkend="language.operators.bitwise">побитовые операторы</link>&listendand;
         <link linkend="language.references">ссылки</link></entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>^</entry>
        <entry>
         <link linkend="language.operators.bitwise">побитовые операторы</link>
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>|</entry>
        <entry>
         <link linkend="language.operators.bitwise">побитовые операторы</link>
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>&amp;&amp;</entry>
        <entry>
         <link linkend="language.operators.logical">логические операторы</link>
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>||</entry>
        <entry>
         <link linkend="language.operators.logical">логические операторы</link>
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>? :</entry>
        <entry>
         <link linkend="language.operators.comparison.ternary">тернарный оператор</link>
        </entry>
       </row>
       <row>
        <entry>правая</entry>
        <entry>
         = += -= *= /= .= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=
        </entry>
        <entry>
         <link linkend="language.operators.assignment">операторы присваивания</link>
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>and</entry>
        <entry>
         <link linkend="language.operators.logical">логические операторы</link>
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>xor</entry>
        <entry>
         <link linkend="language.operators.logical">логические операторы</link>
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>or</entry>
        <entry>
         <link linkend="language.operators.logical">логические операторы</link>
        </entry>
       </row>
       <row>
        <entry>левая</entry>
        <entry>,</entry>
        <entry>множество применений</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    У операторов с равным приоритетом левая ассоциативность
    подразумевает, что выражение вычисляется слева направо,
    правая ассоциативность, соответственно, подразумевает противоположный порядок.
    <example>
     <title>Ассоциативность</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5

// при совместном использовании ++ и + результат будет неопределенным
$a = 1;
echo ++$a + $a++; // может вывести 4 или 5
?>
]]>
     </programlisting>
    </example>
    Использование скобок, даже там где в них нет строгой необходимости,
    обычно заметно улучшает читабельность кода.
   </para>
   <note>
    <para>
     Несмотря на то, что оператор <literal>=</literal> имеет
     низший приоритет, чем большинство остальных операторов, PHP все равно позволяет
     использовать следующую конструкцию: <literal>if (!$a = foo())</literal>,
     которая присваивает переменной <varname>$a</varname> результат
     выполнения функции <literal>foo()</literal>.
    </para>
   </note>
  </sect1>

  <sect1 xml:id="language.operators.arithmetic">
   <title>Арифметические операторы</title>
   <simpara>
    Помните школьные основы арифметики? Описанные ниже операторы работают так же.
   </simpara>
   <table>
    <title>Арифметические операции</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>-$a</entry>
       <entry>Отрицание</entry>
       <entry>Смена знака <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a + $b</entry>
       <entry>Сложение</entry>
       <entry>Сумма <varname>$a</varname> и <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>Вычитание</entry>
       <entry>Разность <varname>$a</varname> и <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>Умножение</entry>
       <entry>Произведение <varname>$a</varname> и <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>Деление</entry>
       <entry>Частное от деления <varname>$a</varname> на <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>Деление по модулю</entry>
       <entry>Целочисленный остаток от деления <varname>$a</varname> на <varname>$b</varname>.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    Операция деления ("/") возвращает число с плавающей точкой, кроме случая,
    когда оба значения являются целыми числами (или строками, которые преобразуются
    в целые числа), которые делятся нацело - в этом случае возвращается целое значение.
   </simpara>
   <simpara>
    При делении по модулю операнды преобразуются в целые числа (удалением дробной части)
    до начала операции.
   </simpara>
   <para>
    Результат операции остатка от деления <literal>%</literal> будет иметь тот же знак,
    что и делимое — то есть, результат <literal>$a % $b</literal>
    будет иметь тот же знак, что и <varname>$a</varname>. Например:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

echo (5 % 3)."\n";           // выводит 2
echo (5 % -3)."\n";          // выводит 2
echo (-5 % 3)."\n";          // выводит -2
echo (-5 % -3)."\n";         // выводит -2

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Также вы можете ознакомиться с разделом документации 
    <link linkend="ref.math">Математические функции</link>.
   </simpara>

  </sect1>

  <sect1 xml:id="language.operators.assignment">
   <title>Оператор присваивания</title>
   <simpara>
    Базовый оператор присваивания обозначается как "=". На первый взгляд
    может показаться, что это оператор "равно". На самом деле это не так.
    В действительности, оператор присваивания означает, что левый операнд
    получает значение правого выражения, (т.е. устанавливается значением).
   </simpara>
   <para>
    Результатом выполнения оператора присваивания является само присвоенное значение.
    Таким образом, результат выполнения "<literal>$a = 3</literal>" будет равен
    3. Это позволяет делать трюки наподобие:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = ($b = 4) + 5; // $a теперь равно 9, а $b было присвоено 4.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Для массивов (<type>array</type>), присвоение значения именованному ключу происходит
    с помощью оператора "=&gt;". <link linkend="language.operators.precedence">Приоритет</link>
    этого оператора такой же, как и у остальных операторов присваивания.
   </para>
   <para>
    В дополнение к базовому оператору присваивания имеются "комбинированные операторы" для
    всех  <link linkend="language.operators">бинарных арифметических</link>операций, 
    операций объединения массивов и строковых операций, которые позволяют
    использовать некоторое значение в выражении, а затем установить его как
    результат данного выражения. Например:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = 3;
$a += 5; // устанавливает $a в 8, как если бы мы написали: $a = $a + 5;
$b = "Hello ";
$b .= "There!"; // устанавливает $b в "Hello There!",  как и $b = $b . "There!";

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Обратите внимание, что присвоение копирует оригинальную переменную в новую
    (присвоение по значению), таким образом все последующие изменения
    одной из переменных никак не отразятся на другой. Это также следует учитывать,
    если вам надо скопировать что-то типа большого массива в длинном цикле.
   </para>
   <para>
    Исключением из обычного для PHP способа присваивания по значению явлаются объекты 
    (<type>object</type>), которые, начиная с версии PHP 5, присваиваются по ссылке.
    Принудительно скопировать объекты по значению можно с помощью 
    специального ключевого слова <link linkend="language.oop5.cloning">clone</link>.
   </para>

   <sect2 xml:id="language.operators.assignment.reference">
    <title>Присваивание по ссылке</title>
    <para>
     Присваивание по ссылке также поддерживается, для него используется синтаксис
     <computeroutput>$var = &amp;$othervar;</computeroutput>.
     'Присваивание по ссылке' означает, что обе переменные указывают на
     одни и те же данные и никакого копирования не происходит.
    </para>
    <para>
     <example>
      <title>Присваивание по ссылке</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 3;
$b = &$a; // $b - это ссылка на $a

print "$a\n"; // печатает 3
print "$b\n"; // печатает 3

$a = 4; // меняем $a

print "$a\n"; // печатает 4
print "$b\n"; // также печатает 4, так как $b является ссылкой на $a,
              // а значение переменной $a успело измениться
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Начиная с версии PHP 5, оператор <link linkend="language.oop5.basic.new">new</link>
     автоматически возвращает ссылку, поэтому присваивание результата операции
     <link linkend="language.oop5.basic.new">new</link> по ссылке начиная с версии PHP 5.3 
     генерирует ошибку уровня <constant>E_DEPRECATED</constant>, а в более ранних версиях
     - ошибку уровня <constant>E_STRICT</constant>.
    </para>
    <para>
     Например, следующий код выдаст предупреждение:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

/* Следующая строка сгенерирует следующее сообщение об ошибке:
 * Deprecated: Assigning the return value of new by reference is deprecated in...
 * (Устаревший код: Присвоение результата работы new по ссылке устарело в...)
 */
$o = &new C;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Для получения более полной информации о ссылках и их возможностях обратитесь к разделу
     <link linkend="language.references">Подробно о ссылках</link>.
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.bitwise">
   <title>Побитовые операторы</title>
   <simpara>
    Побитовые операторы позволяют считывать и устанавливать конкретные биты
    целых чисел.
   </simpara>
   <table>
    <title>Побитовые операторы</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><userinput>$a &amp; $b</userinput></entry>
       <entry>И</entry>
       <entry>Устанавливаются только те биты, которые установлены и в <varname>$a</varname>, и в <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><userinput>$a | $b</userinput></entry>
       <entry>Или</entry>
       <entry>Устанавливаются те биты, которые установлены в <varname>$a</varname> или в <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry><userinput>$a ^ $b</userinput></entry>
       <entry>Исключающее или</entry>
       <entry>
        Устанавливаются только те биты, которые установлены либо только в <varname>$a</varname>,
        либо только в <varname>$b</varname>, но не в обоих одновременно.
       </entry>
      </row>
      <row>
       <entry><userinput>~ $a</userinput></entry>
       <entry>Отрицание</entry>
       <entry>
        Устанавливаются те биты, которые не установлены в <varname>$a</varname>, и наоборот.
       </entry>
      </row>
      <row>
       <entry><userinput>$a &lt;&lt; $b</userinput></entry>
       <entry>Сдвиг влево</entry>
       <entry>
        Все биты переменной <varname>$a</varname> сдвигаются на <varname>$b</varname>
        позиций влево (каждая позиция подразумевает "умножение на 2")
       </entry>
      </row>
      <row>
       <entry><userinput>$a &gt;&gt; $b</userinput></entry>
       <entry>Сдвиг вправо</entry>
       <entry>
        Все биты переменной <varname>$a</varname> сдвигаются на <varname>$b</varname> позиций вправо
        (каждая позиция подразумевает "деление на 2")
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Побитовый сдвиг в PHP - это арифметическая операция.
    Биты, сдвинутые за границы числа, отбрасываются.
    Сдвиг влево дополняет число нулями справа, сдвигая
    в то же время знаковый бит числа влево, что означает
    что знак операнда не сохраняется.
    Сдвиг вправо сохраняет копию сдвинутого знакового бита слева, что означает
    что знак операнда сохраняется.
   </para>
   <para>
    Используйте скобки для обеспечения необходимого
    <link linkend="language.operators.precedence"> приоритета операторов</link>.
    Например, <literal>$a &amp; $b == true</literal> сначала проверяет
    на равенство, а потом выполняет побитовое и; тогда как
    <literal>($a &amp; $b) == true</literal> сначала выполняет побитовое и,
    а потом выполняет проверку на равенство.
   </para>
   <para>
    Не забывайте о преобразовании типов данных. Если оба, и левый и правый
    операнды являются строками, побитовый оператор будет работать
    с ASCII значениями символов этих строк.
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
Опция настроек PHP error_reporting использует побитовые значения,
обеспечивая реальную демонстрацию гашения значений битов.
Чтобы показать все ошибки кроме замечаний,
инструкции в файле php.ini предлагают использовать:
<userinput>E_ALL &amp; ~E_NOTICE</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Начинаем со значения E_ALL:
<computeroutput>00000000000000000111011111111111</computeroutput>
Затем берем значение E_NOTICE...
<computeroutput>00000000000000000000000000001000</computeroutput>
... и инвертируем его с помощью <literal>~</literal>:
<computeroutput>11111111111111111111111111110111</computeroutput>
Наконец, используем побитовое И (&amp;), чтобы установить только те биты, 
которые установлены в единицу в обоих значениях:
<computeroutput>00000000000000000111011111110111</computeroutput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Другой способ достичь этого - использовать ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR, <literal>^</literal>),
чтобы получить только те биты, которые установлены в единицу
либо только в одном, либо только в другом значении:
<userinput>E_ALL ^ E_NOTICE</userinput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
Опция error_reporting также может быть использована для демонстрации
установки битов. Показать только ошибки и обрабатываемые ошибки можно
следующим образом:
<userinput>E_ERROR | E_RECOVERABLE_ERROR</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Здесь мы комбинируем E_ERROR
<computeroutput>00000000000000000000000000000001</computeroutput>
и
<computeroutput>00000000000000000001000000000000</computeroutput>
с помощью оператора ИЛИ (OR, <literal>|</literal>),
чтобы получить биты, установленные хотя бы в одном операнде:
<computeroutput>00000000000000000001000000000001</computeroutput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <example>
     <title>Побитовыми операции И, ИЛИ и ИСКЛЮЧАЮЩЕЕ ИЛИ (AND, OR и XOR) над целыми числами</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Не обращайте внимания на этот верхний раздел кода,
 * это просто форматирование для более ясного вывода.
 */

$format = '(%1$2d = %1$04b) = (%2$2d = %2$04b)'
        . ' %3$s (%4$2d = %4$04b)' . "\n";

echo <<<EOH
 ---------     ---------  -- ---------
 результат     значение   оп   тест
 ---------     ---------  -- ---------
EOH;


/*
 * Вот сами примеры.
 */

$values = array(0, 1, 2, 4, 8);
$test = 1 + 4;

echo "\n Побитовое И (AND) \n";
foreach ($values as $value) {
    $result = $value & $test;
    printf($format, $result, $value, '&', $test);
}

echo "\n Побитовое (включающее) ИЛИ (OR) \n";
foreach ($values as $value) {
    $result = $value | $test;
    printf($format, $result, $value, '|', $test);
}

echo "\n Побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR) \n";
foreach ($values as $value) {
    $result = $value ^ $test;
    printf($format, $result, $value, '^', $test);
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
 ---------     ---------  -- ---------
 результат     значение   оп   тест
 ---------     ---------  -- ---------
 Побитовое И (AND)
( 0 = 0000) = ( 0 = 0000) & ( 5 = 0101)
( 1 = 0001) = ( 1 = 0001) & ( 5 = 0101)
( 0 = 0000) = ( 2 = 0010) & ( 5 = 0101)
( 4 = 0100) = ( 4 = 0100) & ( 5 = 0101)
( 0 = 0000) = ( 8 = 1000) & ( 5 = 0101)

 Побитовое (включающее) ИЛИ (OR)
( 5 = 0101) = ( 0 = 0000) | ( 5 = 0101)
( 5 = 0101) = ( 1 = 0001) | ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) | ( 5 = 0101)
( 5 = 0101) = ( 4 = 0100) | ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) | ( 5 = 0101)

 Побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR)
( 5 = 0101) = ( 0 = 0000) ^ ( 5 = 0101)
( 4 = 0100) = ( 1 = 0001) ^ ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) ^ ( 5 = 0101)
( 1 = 0001) = ( 4 = 0100) ^ ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) ^ ( 5 = 0101)
]]>
     </screen>
    </example>
   </para>
   <para>
    <example>
     <title>Побитовая операция ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR) над строками</title>
     <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // Выводит '5'

echo "12" ^ "9"; // Выводит символ Backspace (ascii 8)
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; // Выводит ascii значения #0 #4 #0 #0 #0
                        // 'a' ^ 'e' = #4

echo 2 ^ "3"; // Выводит 1
              // 2 ^ ((int)"3") == 1

echo "2" ^ 3; // Выводит 1
              // ((int)"2") ^ 3 == 1
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Побитовый сдвиг над целыми числами</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Несколько примеров.
 */

echo "\n--- СДВИГ ВПРАВО НАД ПОЛОЖИТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---\n";

$val = 4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'слева была вставлена копия знакового бита');

$val = 4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places);

$val = 4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'биты были выдвинуты за правый край');

$val = 4;
$places = 4;
$res = $val >> $places;
p($res, $val, '>>', $places, 'то же, что и выше; нельзя сдвинуть дальше 0');


echo "\n--- СДВИГ ВПРАВО НАД ОТРИЦАТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---\n";

$val = -4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'слева была вставлена копия знакового бита');

$val = -4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places, 'биты были выдвинуты за правый край');

$val = -4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'то же, что и выше; нельзя сдвинуть дальше -1');


echo "\n--- СДВИГ ВЛЕВО НАД ПОЛОЖИТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---\n";

$val = 4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'правый край был дополнен нулями');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 4;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = 4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places, 'знаковые биты были выдвинуты');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'биты были выдвинуты за левый край');


echo "\n--- СДВИГ ВЛЕВО НАД ОТРИЦАТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---\n";

$val = -4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'правый край был дополнен нулями');

$val = -4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = -4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'биты были выдвинуты за левый край, включая знаковый бит');


/*
 * Не обращайте внимания на этот нижний раздел кода,
 * это просто форматирование для более ясного вывода.
 */

function p($res, $val, $op, $places, $note = '') {
    $format = '%0' . (PHP_INT_SIZE * 8) . "b\n";

    printf("Выражение: %d = %d %s %d\n", $res, $val, $op, $places);

    echo " Десятичный вид:\n";
    printf("  val=%d\n", $val);
    printf("  res=%d\n", $res);

    echo " Двоичный вид:\n";
    printf('  val=' . $format, $val);
    printf('  res=' . $format, $res);

    if ($note) {
        echo " ЗАМЕЧАНИЕ: $note\n";
    }

    echo "\n";
}
?>
]]>
     </programlisting>
     &example.outputs.32bit;
     <screen>
<![CDATA[

--- СДВИГ ВПРАВО НАД ПОЛОЖИТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---
Выражение: 2 = 4 >> 1
 Десятичный вид:
  val=4
  res=2
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000010
 ЗАМЕЧАНИЕ: слева была вставлена копия знакового бита 

Выражение: 1 = 4 >> 2
 Десятичный вид:
  val=4
  res=1
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000001

Выражение: 0 = 4 >> 3
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были выдвинуты за правый край

Выражение: 0 = 4 >> 4
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 ЗАМЕЧАНИЕ: то же, что и выше; нельзя сдвинуть дальше 0


--- СДВИГ ВПРАВО НА ОТРИЦАТЕЛЬНЫХ ЦЕЛЫХ ЧИСЛАХ ---
Выражение: -2 = -4 >> 1
 Десятичный вид:
  val=-4
  res=-2
 Двоичный вид:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111110
 ЗАМЕЧАНИЕ: слева была вставлена копия знакового бита

Выражение: -1 = -4 >> 2
 Десятичный вид:
  val=-4
  res=-1
 Двоичный вид:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 ЗАМЕЧАНИЕ: биты были выдвинуты за правый край

Выражение: -1 = -4 >> 3
 Десятичный вид:
  val=-4
  res=-1
 Двоичный вид:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 ЗАМЕЧАНИЕ: то же, что и выше; нельзя сдвинуть дальше -1


--- СДВИГ ВЛЕВО НАД ПОЛОЖИТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---
Выражение: 8 = 4 << 1
 Десятичный вид:
  val=4
  res=8
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000001000
 ЗАМЕЧАНИЕ: правый край был дополнен нулями

Выражение: 1073741824 = 4 << 28
 Десятичный вид:
  val=4
  res=1073741824
 Двоичный вид:
  val=00000000000000000000000000000100
  res=01000000000000000000000000000000

Выражение: -2147483648 = 4 << 29
 Десятичный вид:
  val=4
  res=-2147483648
 Двоичный вид:
  val=00000000000000000000000000000100
  res=10000000000000000000000000000000
 ЗАМЕЧАНИЕ: знаковые биты были выдвинуты

Выражение: 0 = 4 << 30
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были выдвинуты за левый край


--- СДВИГ ВЛЕВО НАД ОТРИЦАТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---
Выражение: -8 = -4 << 1
 Десятичный вид:
  val=-4
  res=-8
 Двоичный вид:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111000
 ЗАМЕЧАНИЕ: правый край был дополнен нулями

Выражение: -2147483648 = -4 << 29
 Десятичный вид:
  val=-4
  res=-2147483648
 Двоичный вид:
  val=11111111111111111111111111111100
  res=10000000000000000000000000000000

Выражение: 0 = -4 << 30
 Десятичный вид:
  val=-4
  res=0
 Двоичный вид:
  val=11111111111111111111111111111100
  res=00000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были выдвинуты за левый край, включая знаковый бит
]]>
     </screen>
     &example.outputs.64bit;
     <screen>
<![CDATA[

--- СДВИГ ВПРАВО НАД ПОЛОЖИТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---
Выражение: 2 = 4 >> 1
 Десятичный вид:
  val=4
  res=2
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000010
 ЗАМЕЧАНИЕ: слева была вставлена копия знакового бита

Выражение: 1 = 4 >> 2
 Десятичный вид:
  val=4
  res=1
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000001

Выражение: 0 = 4 >> 3
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были выдвинуты за правый край

Выражение: 0 = 4 >> 4
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 ЗАМЕЧАНИЕ: то же, что и выше; нельзя сдвинуть дальше 0


--- СДВИГ ВПРАВО НАД ОТРИЦАТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---
Выражение: -2 = -4 >> 1
 Десятичный вид:
  val=-4
  res=-2
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111110
 ЗАМЕЧАНИЕ: слева была вставлена копия знакового бита

Выражение: -1 = -4 >> 2
 Десятичный вид:
  val=-4
  res=-1
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 ЗАМЕЧАНИЕ: биты были выдвинуты за правый край

Выражение: -1 = -4 >> 3
 Десятичный вид:
  val=-4
  res=-1
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 ЗАМЕЧАНИЕ: то же, что и выше; нельзя сдвинуть дальше -1


--- СДВИГ ВЛЕВО НАД ПОЛОЖИТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---
Выражение: 8 = 4 << 1
 Десятичный вид:
  val=4
  res=8
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000001000
 ЗАМЕЧАНИЕ: правый край был дополнен нулями

Выражение: 4611686018427387904 = 4 << 60
 Десятичный вид:
  val=4
  res=4611686018427387904
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0100000000000000000000000000000000000000000000000000000000000000

Выражение: -9223372036854775808 = 4 << 61
 Десятичный вид:
  val=4
  res=-9223372036854775808
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=1000000000000000000000000000000000000000000000000000000000000000
 ЗАМЕЧАНИЕ: знаковые биты были выдвинуты

Выражение: 0 = 4 << 62
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были выдвинуты за левый край


--- СДВИГ ВЛЕВО НАД ОТРИЦАТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---
Выражение: -8 = -4 << 1
 Десятичный вид:
  val=-4
  res=-8
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111000
 ЗАМЕЧАНИЕ: правый край был дополнен нулями

Выражение: -9223372036854775808 = -4 << 61
 Десятичный вид:
  val=-4
  res=-9223372036854775808
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1000000000000000000000000000000000000000000000000000000000000000

Выражение: 0 = -4 << 62
 Десятичный вид:
  val=-4
  res=0
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=0000000000000000000000000000000000000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были выдвинуты за левый край, включая знаковый бит
]]>
     </screen>
    </example>
   </para>
   <warning>
    <para>
     Не используйте сдвиг вправо более чем на 32 бита на 32-битных
     системах. Не используйте сдвиг влево для получения чисел, требующих для записи
     более 32 бит.
     Используйте функции из расширения gmp для побитовых операций над числами, 
     большими чем PHP_INT_MAX.
    </para>
   </warning>
   <para>
    Смотрите также
    <function>pack</function>,
    <function>unpack</function>,
    <function>gmp_and</function>,
    <function>gmp_or</function>,
    <function>gmp_xor</function>,
    <function>gmp_testbit</function>,
    <function>gmp_clrbit</function>
   </para>
  </sect1>

  <sect1 xml:id="language.operators.comparison">
   <title>Операторы сравнения</title>
   <simpara>
    Операторы сравнения, как это видно из их названия, позволяют
    сравнивать между собой два значения. Возможно вам будет
    интересно также ознакомиться с разделом  <link linkend="types.comparisons">Сравнение типов</link>,
    в котором приведено большое количество соответствующих примеров.
   </simpara>
   <table>
    <title>Операторы сравнения</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>Равно</entry>
       <entry>&true; если <varname>$a</varname> равно <varname>$b</varname>
        после преобразования типов.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Тождественно равно</entry>
       <entry>
        &true; если <varname>$a</varname> равно <varname>$b</varname> и имеет тот же тип.
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Не равно</entry>
       <entry>&true; если <varname>$a</varname> не равно <varname>$b</varname>
        после преобразования типов.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Не равно</entry>
       <entry>&true; если <varname>$a</varname> не равно <varname>$b</varname>
        после преобразования типов.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Тождественно не равно</entry>
       <entry>
        &true; если <varname>$a</varname> не равно <varname>$b</varname> или они разных типов.
       </entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>Меньше</entry>
       <entry>&true; если <varname>$a</varname> строго меньше <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>Больше</entry>
       <entry>&true; если <varname>$a</varname> строго больше <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>Меньше или равно</entry>
       <entry>&true; если <varname>$a</varname> меньше или равно <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>Больше или равно</entry>
       <entry>&true; если <varname>$a</varname> больше или равно <varname>$b</varname>.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    В случае, если вы сравниваете число со строкой или две строки, содержащие числа,
    каждая строка будет <link linkend="language.types.string.conversion">преобразована в число</link>,
    и сравниваться они будут как числа. Эти правила также распространяются на оператор
    <link linkend="control-structures.switch">switch</link>.
    Преобразование типов не происходит при использовании === или !==
    так как в этом случае кроме самих значений сравниваются еще и типы.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a"); // 0 == 0 -> true
var_dump("1" == "01"); // 1 == 1 -> true
var_dump("10" == "1e1"); // 10 == 10 -> true
var_dump(100 == "1e2"); // 100 == 100 -> true

switch ("a") {
case 0:
    echo "0";
    break;
case "a": // Эта ветка никогда не будет достигнута, так как "a" уже сопоставленно с 0
    echo "a";
    break;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <para>
    Для различных типов сравнение происходит в соответствии со следующей
    таблицей (по порядку).
   </para>
   <table xml:id="language.operators.comparison.types">
    <title>Сравнение различных типов</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Тип операнда 1</entry>
       <entry>Тип операнда 2</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>null</type> или <type>string</type></entry>
       <entry><type>string</type></entry>
       <entry>&null; преобразуется в "", числовое или лексическое сравнение</entry>
      </row>
      <row>
       <entry><type>bool</type> или <type>null</type></entry>
       <entry>что угодно</entry>
       <entry>Преобразуется в <type>bool</type>, &false; &lt; &true;</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry><type>object</type></entry>
       <entry>Встроенные классы могут определять свои собственные правила сравнения,
        объекты разных классов не сравниваются, объекты одного класса - сравниваются свойства
        тем же способом, что и в массивах (PHP 4), в PHP 5 есть свое собственное <link
        linkend="language.oop5.object-comparison">объяснение</link>
       </entry>
      </row>
      <row>
       <entry><type>string</type>, <type>resource</type> или <type>number</type></entry>
       <entry><type>string</type>, <type>resource</type> или <type>number</type></entry>
       <entry>Строки и ресурсы переводятся в числа, обычная математика</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry><type>array</type></entry>
       <entry>Массивы с меньшим числом элементов считаются меньше,
        если ключ из первого операнда не найден во втором операнде
        - массивы не могут сравниваться, иначе идет сравнение соответствующих
        значений (смотри пример ниже)</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry>что угодно</entry>
       <entry><type>array</type> всегда больше</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry>что угодно</entry>
       <entry><type>object</type> всегда больше</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    <example>
     <title>Алгоритм сравнения обычных массивов</title>
     <programlisting role="php">
<![CDATA[
<?php
// Так сравниваются массивы при сравнении стандартными операторами
function standard_array_compare($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }
    foreach ($op1 as $key => $val) {
        if (!array_key_exists($key, $op2)) {
            return null; // не могут быть сравнимы
        } elseif ($val < $op2[$key]) {
            return -1;
        } elseif ($val > $op2[$key]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    Смотрите также <function>strcasecmp</function>,
    <function>strcmp</function>,
    <link linkend="language.operators.array">операторы массивов</link>,
    и раздел руководства
    <link linkend="language.types">Типы</link>.
   </para>

   <warning>
    <title>Сравнение чисел с плавающей точкой</title>

    <para>
     Из-за особого внутреннего представления <type>float</type>, не нужно
     проверять на равенство два <type>float</type>-числа.
    </para>

    <para>
     Для более подробной информации смотрите документацию по типу <type>float</type>.
    </para>
   </warning>

   <sect2 xml:id="language.operators.comparison.ternary">
    <title>Тернарный оператор</title>
    <para>
   Еще одним условным оператором является тернарный оператор "?:".
     <example>
      <title>Присваивание значения по умолчанию</title>
      <programlisting role="php">
<![CDATA[
<?php
// Пример использования тернарного оператора
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// Приведенный выше код аналогичен следующему блоку с использованием if/else
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}

?>
]]>
      </programlisting>
     </example>
     Выражение <literal>(expr1) ? (expr2) : (expr3)</literal>
     интерпретируется как <replaceable>expr2</replaceable>, если
     <replaceable>expr1</replaceable> имеет значение &true;, или как
     <replaceable>expr3</replaceable> если
     <replaceable>expr1</replaceable> имеет значение &false;.
    </para>
    <para>
     Начиная с версии PHP 5.3 также стало возможным не писать среднюю часть
     тернарного оператора. Выражение <literal>expr1 ?: expr3</literal>
     возвращает <replaceable>expr1</replaceable> если <replaceable>expr1</replaceable>
     имеет значение &true;, и <replaceable>expr3</replaceable> в другом случае.
    </para>
    <note>
     <simpara>
      Пожалуйста учтите, что тернарный оператор является выражением
      и трактуется не как переменная, а как результат выражения. Это важно знать,
      если вы хотите вернуть переменную по ссылке.
      Выражение <literal>return $var == 42 ? $a : $b;</literal> не будет
      работать в функции, возвращающей значение по ссылке, а в более поздних
      версиях PHP также будет выдано предупреждение.
     </simpara>
    </note>
    <note>
     <para>
      Рекомендуется избегать "нагромождения" тернарных выражений.
      Поведение PHP неочевидно при использовании нескольких тернарных операторов
      в одном выражении:
      <example>
       <title>Неочевидное поведение тернарного оператора</title>
       <programlisting role="php">
<![CDATA[
<?php
// на первый взгляд, следующий код должен вывести 'true'
echo (true?'true':false?'t':'f');

// однако, он выводит 't'
// это происходит потому, что тернарные выражения вычисляются слева направо

// это намного более очевидная версия вышеприведенного кода
echo ((true ? 'true' : false) ? 't' : 'f');

// здесь вы можете видеть, что первое выражение вычисляется в 'true', которое
// в свою очередь вычисляется в (bool)true, таким образом возвращая истинную ветвь
// второго тернарного выражения.
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2>

  </sect1>

  <sect1 xml:id="language.operators.errorcontrol">
   <title>Оператор управления ошибками</title>
   <simpara>
    PHP поддерживает один оператор управления ошибками: знак (@).
    В случае, если он предшествует какому-либо выражению в PHP-коде, любые
    сообщения об ошибках, генерируемые этим выражением, будут проигнорированы.
   </simpara>
   <simpara>
    Если вы установили собственную функцию обработки ошибок с помощью
    <function>set_error_handler</function>, то она все равно будет вызвана,
    однако, если внутри этой функции будет вызвана функция
    <function>error_reporting</function>, то она вернет 0, если функция,
    вызвавшая данную ошибку, была подавлена с помощью @.
   </simpara>
   <simpara>
    В случае, если установлена опция <link linkend="ini.track-errors"><option>track_errors</option></link>,
    все генерируемые сообщения об ошибках будут сохраняться в переменной
    <varname>$php_errormsg</varname>.
    Эта переменная будет перезаписываться при каждой новой ошибке,
    поэтому в случае необходимости проверяйте ее сразу же.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Преднамеренная ошибка при работе с файлами
$my_file = @file ('non_existent_file') or
    die ("Ошибка при открытии файла: сообщение об ошибке было таким: '$php_errormsg'");

// работает для любых выражений, а не только для функций
$value = @$cache[$key];
// В случае если ключа $key нет, сообщение об ошибке (notice) не будет отображено

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     Оператор @ работает только с
     <link linkend="language.expressions">выражениями</link>.
     Есть простое правило: если что-то возвращает
     значение, значит вы можете использовать перед ним оператор
     @. Например, вы можете использовать @ перед
     именем переменной, произвольной функцией или вызовом <function>include</function>,
     константой и так далее. В то же время вы не можете использовать этот оператор
     перед определением функции или класса, условными конструкциями, такими как  <literal>if</literal>,
     &foreach; и т.д.
    </simpara>
   </note>
   <simpara>
    Также ознакомьтесь с описанием функции <function>error_reporting</function> 
    и разделом руководства
    <link linkend="ref.errorfunc">Обработка ошибок и функции логирования</link>.
   </simpara>
   <warning>
    <para>
     На сегодняшний день оператор "@" подавляет
     вывод сообщений даже о критических ошибках, прерывающих работу
     скрипта. Помимо всего прочего, это означает, что если вы использовали
     "@" для подавления ошибок, возникающих при работе какой-либо
     функции, в случае если она недоступна или написана неправильно, дальнейшая
     работа скрипта будет остановлена без каких-либо уведомлений.
    </para>
   </warning>
  </sect1>

  <sect1 xml:id="language.operators.execution">
   <title>Операторы исполнения</title>
   <para>
    PHP поддерживает один оператор исполнения: обратные кавычки (``). Обратите
    внимание, что это не одинарные кавычки! PHP попытается выполнить строку,
    заключенную в обратные кавычки, как консольную команду, и вернет
    полученный вывод (т.е. он не просто выводится на экран, а, например, может
    быть присвоен переменной). Использование обратных кавычек аналогично
    использованию функции <function>shell_exec</function>.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     Обратные кавычки недоступны, в случае, если включен &safemode; или 
     отключена функция <function>shell_exec</function>.
    </para>
   </note>
   <note>
    <para>
     В отличие от некоторых других языков, обратные кавычки не
     будут работать внутри строк в двойных кавычках.
    </para>
   </note>
   <para>
    Ознакомьтесь также со следующими разделами документации:
    <link linkend="ref.exec">Функции для выполнения программ</link>,
    <function>popen</function>  <function>proc_open</function>, и
    <link linkend="features.commandline">Использование PHP в командной строке</link>.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.increment">
   <title>Операторы инкремента и декремента</title>
   <para>
    PHP поддерживает префиксные и постфиксные операторы инкремента и декремента
    в стиле C.
   </para>
   <note>
    <simpara>
     Операторы инкремента/декремента не влияют на булевы значения.
     Декремент &null; также не даст никакого эффекта, однако инкремент
     даст значение <literal>1</literal>.
    </simpara>
   </note>
   <table>
    <title>Операторы инкремента и декремента</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Действие</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>Префиксный инкремент</entry>
       <entry>Увеличивает <varname>$a</varname> на единицу, затем возвращает значение <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>Постфиксный инкремент</entry>
       <entry>Возвращает значение <varname>$a</varname>, затем увеличивает <varname>$a</varname> на единицу.</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>Префиксный декремент</entry>
       <entry>Уменьшает <varname>$a</varname> на единицу, затем возвращает значение <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>Постфиксный декремент</entry>
       <entry>Возвращает значение <varname>$a</varname>, затем уменьшает <varname>$a</varname> на единицу.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Приведем пример простого скрипта:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>Постфиксный инкремент</h3>";
$a = 5;
echo "Должно быть 5: " . $a++ . "<br />\n";
echo "Должно быть 6: " . $a . "<br />\n";

echo "<h3>Префиксный инкремент</h3>";
$a = 5;
echo "Должно быть 6: " . ++$a . "<br />\n";
echo "Должно быть 6: " . $a . "<br />\n";

echo "<h3>Постфиксный декремент</h3>";
$a = 5;
echo "Должно быть 5: " . $a-- . "<br />\n";
echo "Должно быть 4: " . $a . "<br />\n";

echo "<h3>Префиксный декремент</h3>";
$a = 5;
echo "Должно быть 4: " . --$a . "<br />\n";
echo "Должно быть 4: " . $a . "<br />\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    PHP следует соглашениям Perl (в отличие от С) касательно выполнения
    арифметических операций с символьными переменными. Например, в PHP и Perl
    <literal>$a = 'Z'; $a++;</literal> присвоит <literal>$a</literal>
    значение <literal>'AA'</literal>, в то время как в C
    <literal>a = 'Z'; a++;</literal> присвоит <literal>a</literal>
    значение <literal>'['</literal> (ASCII значение
    <literal>'Z'</literal> равно 90, а ASCII значение
    <literal>'['</literal> равно 91). Следует учесть, что к
    символьным переменным можно применять операцию инкремента,
    в то время как операцию декремента применять нельзя, кроме того,
    поддерживаются только ASCII символы (a-z и A-Z).
    Попытка инкремента/декремента других символьных переменных не
    будет иметь никакого эффекта, исходная строка останется
    неизменной.
    <example>
     <title>Арифметические операции с символьными переменными</title>
     <programlisting role="php">
<![CDATA[
<?php
$i = 'W';
for ($n=0; $n<6; $n++) {
    echo ++$i . "\n";
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
X
Y
Z
AA
AB
AC
]]>
     </screen>
    </example>
   </para>
   <para>
    Инкрементирование или декрементирование булевых переменных не приводит ни к какому результату.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.logical">
   <title>Логические операторы</title>

   <table>
    <title>Логические операторы</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>И</entry>
       <entry>&true; если и <varname>$a</varname>, и <varname>$b</varname> &true;.</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>Или</entry>
       <entry>&true; если или <varname>$a</varname>, или <varname>$b</varname> &true;.</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>Исключающее или</entry>
       <entry>&true; если <varname>$a</varname>, или <varname>$b</varname> &true;, но не оба.</entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>Отрицание</entry>
       <entry>&true; если <varname>$a</varname> не &true;.</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>И</entry>
       <entry>&true; если и <varname>$a</varname>, и <varname>$b</varname> &true;.</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>Или</entry>
       <entry>&true; если или <varname>$a</varname>, или <varname>$b</varname> &true;.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    Смысл двух разных вариантов для операторов "and" и "or" в том, что
    они работают с различными приоритетами (смотрите таблицу
    <link linkend="language.operators.precedence">Приоритет выполнения операторов</link>).
   </simpara>
   <example>
    <title>Объяснение логических операторов</title>
    <programlisting role="php">
<![CDATA[
<?php

// --------------------
// foo() никогда не буде вызвана, так как эти операторы являются шунтирующими (short-circuit)

$a = (false && foo());
$b = (true  || foo());
$c = (false and foo());
$d = (true  or  foo());

// --------------------
// "||" имеет больший приоритет, чем "or"

// Результат выражения (false || true) присваивается переменной $e
// Действует как: ($e = (false || true))
$e = false || true;

// Константа false присваивается $f, а затем значение true игнорируется
// Действует как: (($f = false) or true)
$f = false or true;

var_dump($e, $f);

// --------------------
// "&&" имеет больший приоритет, чем "and"

// Результат выражения (true && false) присваивается переменной $g
// Действует как: ($g = (true && false))
$g = true && false;

// Константа true присваивается $h, а затем значение false игнорируется
// Действует как: (($h = true) and false)
$h = true and false;

var_dump($g, $h);
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
bool(true)
bool(false)
bool(false)
bool(true)
]]>
    </screen>
   </example>
  </sect1>

  <sect1 xml:id="language.operators.string">
   <title>Строковые операторы</title>
   <simpara>
    В PHP есть два оператора для работы со строками (<type>string</type>).
    Первый - оператор конкатенации ('.'), который возвращает строку, представляющую
    собой соединение левого и правого аргумента. Второй - оператор присваивания с конкатенацией
    ('<literal>.=</literal>'), который присоединяет правый аргумент к левому.
    Для получения более полной информации ознакомьтесь с разделом
    <link linkend="language.operators.assignment">Операторы присваивания</link>.
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = "Hello ";
$b = $a . "World!"; // $b теперь содержит строку "Hello World!"

$a = "Hello ";
$a .= "World!";     // $a теперь содержит строку "Hello World!"
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Также ознакомьтесь с разделами документации
    <link linkend="language.types.string">Строки</link> и 
    <link linkend="ref.strings">Функции для работы со строками</link>.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.array">
   <title>Операторы, работающие с массивами</title>
   <table>
    <title>Операторы, работающие с массивами</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Название</entry>
       <entry>Результат</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>Объединение</entry>
       <entry>Объединение массива <varname>$a</varname> и массива <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a == $b</entry>
       <entry>Равно</entry>
       <entry>&true; в случае, если <varname>$a</varname> и <varname>$b</varname> содержат одни и те же пары ключ/значение.</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Тождественно равно</entry>
       <entry>&true; в случае, если <varname>$a</varname> и <varname>$b</varname> содержат
        одни и те же паты ключ/значение в том же самом порядке и того же типа.</entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Не равно</entry>
       <entry>&true;, если массив <varname>$a</varname> не равен массиву <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Не равно</entry>
       <entry>&true;, если массив <varname>$a</varname> не равен массиву <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Тождественно не равно</entry>
       <entry>&true;, если массив <varname>$a</varname> не равен тождественно массиву <varname>$b</varname>.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Оператор <literal>+</literal> возвращает левый массив, к которому
    был присоединен правый массив. Для ключей, которые существуют в
    обоих массивах, будут использованы значения из левого массива, а
    соответствующие им элементы из правого массива будут проигнорированы.
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "apple", "b" => "banana");
$b = array("a" => "pear", "b" => "strawberry", "c" => "cherry");

$c = $a + $b; // Объединение $a и $b
echo "Union of \$a and \$b: \n";
var_dump($c);

$c = $b + $a; // Объединение $b и $a
echo "Union of \$b and \$a: \n";
var_dump($c);
?>
]]>
     </programlisting>
    </informalexample>
    После своего выполнения скрипт напечатает следующее:
    <screen role="php">
<![CDATA[
Union of $a and $b:
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}
Union of $b and $a:
array(3) {
  ["a"]=>
  string(4) "pear"
  ["b"]=>
  string(10) "strawberry"
  ["c"]=>
  string(6) "cherry"
}
]]>
    </screen>
   </para>
   <para>
   При сравнении элементы массива считаются идентичными, если совпадает
   и ключ, и соответствующее ему значение.
   </para>
   <para>
    <example>
     <title>Сравнение массивов</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("apple", "banana");
$b = array(1 => "banana", "0" => "apple");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Также ознакомьтесь с разделами
    <link linkend="language.types.array">Массивы</link> и   
    <link linkend="ref.array">Функции для работы с массивами</link>.
   </para>
  </sect1>
  <sect1 xml:id="language.operators.type">
   <title>Оператор проверки типа</title>
   <para>
    Оператор <literal>instanceof</literal> используется для определения того,
    является ли текущий объект экземпляром указанного
    <link linkend="language.oop5.basic.class">класса</link>.
    <example>
     <title>Использование <literal>instanceof</literal> с классами</title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

class NotMyClass
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof NotMyClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    Оператор <literal>instanceof</literal> также может быть использован
    для определения, наследует ли определенный объект какому-либо классу:
    <example>
     <title>Использование <literal>instanceof</literal> с наследуемыми классами</title>
     <programlisting role="php">
<![CDATA[
<?php
class ParentClass
{
}

class MyClass extends ParentClass
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof ParentClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Для проверки <emphasis>непринадлежности</emphasis> объекта некоторому классу,
    используйте
    <link linkend="language.operators.logical">логический оператор <literal>not</literal></link>.
    <example>
     <title>Использование <literal>instanceof</literal> для проверки того, что объект <emphasis>не</emphasis>
      является экземпляром класса</title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

$a = new MyClass;
var_dump(!($a instanceof stdClass));
?>
]]>
     </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Ну и наконец, <literal>instanceof</literal> может быть также использован
    для проверки реализации объектом некоторого
    <link linkend="language.oop5.interfaces">интерфейса</link>:
    <example>
     <title>Использование <literal>instanceof</literal> для класса</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof MyInterface);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Хотя <literal>instanceof</literal> обычно используется с прямо указанным именем класса,
    он также может быть использован с другим объектом или строковой переменной:
    <example>
     <title>Использование <literal>instanceof</literal> с другими переменными</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;
$b = new MyClass;
$c = 'MyClass';
$d = 'NotMyClass';

var_dump($a instanceof $b); // $b это объект класса MyClass
var_dump($a instanceof $c); // $c это строка 'MyClass'
var_dump($a instanceof $d); // $d это строка 'NotMyClass'
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    Есть несколько подводных камней, которых следует остерегаться.  До версии PHP 5.1.0,
    <literal>instanceof</literal> вызывал <function>__autoload</function>
    если имя класса не существовало. Вдобавок, если класс не был загружен,
    происходила фатальная ошибка. Это можно было обойти с помощью динамической ссылки на класс
    или использования строковой переменной с именем класса:
    <example>
     <title>Избежание поиска класса и фатальных ошибок с <literal>instanceof</literal> в PHP 5.0</title>
     <programlisting role="php">
<![CDATA[
<?php
$d = 'NotMyClass';
var_dump($a instanceof $d); // нет фатальной ошибки
?>
     ]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(false)
]]>
     </screen>
    </example>
   </para>
   <simpara>
    Оператор <literal>instanceof</literal> был добавлен в PHP 5.
    До этого времени использовалась функция <function>is_a</function>,
    но позже <function>is_a</function> была помечена устаревшей в пользу
    <literal>instanceof</literal>. Учтите, что с версии PHP 5.3.0,
    <function>is_a</function> больше не является устаревшей.
   </simpara>
   <para>
    Ознакомьтесь также с описанием функций <function>get_class</function> и
    <function>is_a</function>.
   </para>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
