<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: e4b889a3e8b9d87ab605aac9bbe85d2c16c69a1b Maintainer: shein Status: ready -->
<!-- $Revision$ -->
<!-- Reviewed: yes -->
<chapter xml:id="language.operators" xmlns="http://docbook.org/ns/docbook">
 <title>Операторы</title>
 <simpara>
  Оператором называется нечто, принимающее одно или более значений (или выражений,
  если говорить на жаргоне программирования), и вычисляющее новое
  значение (таким образом, вся конструкция может рассматриваться как выражение).
 </simpara>
 <para>
  Операторы можно сгруппировать по количеству принимаемых ими значений. Унарные
  операторы принимают только одно значение, например, <literal>!</literal>
  (<link linkend="language.operators.logical">оператор логического отрицания</link>)
  или <literal>++</literal> (<link linkend="language.operators.increment">инкремент</link>).
  Бинарные операторы принимают два значения; это, например, знакомые
  всем <link linkend="language.operators.arithmetic">арифметические операторы</link>
  <literal>+</literal> (плюс) и <literal>-</literal> (минус), большинство поддерживаемых в
  PHP операторов входят именно в эту категорию. Ну и, наконец, есть всего один
  <link linkend="language.operators.comparison.ternary">тернарный оператор</link>,
  <literal>? :</literal>, принимающий три значения, обычно его так и называют -- "тернарный
  оператор" (хотя, возможно, более точным названием было бы "условный оператор").
 </para>
 <para>
  Полный список PHP-операторов вы можете найти в разделе
  "<link linkend="language.operators.precedence">Порядок выполнения операторов</link>".
  В этом разделе также описан порядок выполнения операторов и их ассоциативность, которые
  точно определяют, как вычисляются выражения с несколькими разными операторами.
 </para>

 <sect1 xml:id="language.operators.precedence">
  <title>Приоритет оператора</title>
  <para>
   Приоритет оператора определяет, насколько "тесно" он связывает между собой два
   выражения. Например, выражение  <literal>1 + 5 * 3</literal> вычисляется как
   <literal>16</literal>, а не <literal>18</literal>, поскольку оператор умножения ("*") имеет
   более высокий приоритет, чем оператор сложения ("+"). Круглые скобки могут
   использоваться для принудительного указания порядка выполнения операторов. Например,
   выражение <literal>(1 + 5) * 3</literal> вычисляется как <literal>18</literal>.
  </para>
  <para>
   Если операторы имеют равный приоритет, то будут ли они выполняться справа налево или
   слева направо определяется их ассоциативностью. К примеру, "-" является
   лево-ассоциативным оператором. Следовательно <literal>1 - 2 - 3</literal> сгруппируется
   как <literal>(1 - 2) - 3</literal> и пересчитается в <literal>-4</literal>. С другой стороны
   "=" - право-ассоциативный оператор, так что <literal>$a = $b = $c</literal> сгруппируется
   как <literal>$a = ($b = $c)</literal>.
  </para>
  <para>
   Неассоциативные операторы с одинаковым приоритетом не могут использоваться совместно.
   К примеру <literal>1 &lt; 2 &gt; 1</literal> не будет работать в PHP. Выражение
   <literal>1 &lt;= 1 == 1</literal>, с другой стороны, будет, поскольку <literal>==</literal>
   имеет более низкий приоритет чем <literal>&lt;=</literal>.
  </para>
  <para>
   Ассоциативность имеет смысл только для двоичных (и тернарных) операторов.
   Унарные операторы являются префиксными или постфиксными, поэтому это понятие не применимо.
   Например, <literal>!!$a</literal> можно сгруппировать только как <literal>!(!$a)</literal>.
  </para>
  <para>
   Использование скобок, кроме случаев когда они строго необходимы, может улучшить
   читаемость кода, группируя явно, а не полагаясь на приоритеты и ассоциативность.
  </para>
  <para>
   В следующей таблице приведён список операторов, отсортированный по
   убыванию их приоритетов. Операторы, размещённые в одной строке имеют
   одинаковый приоритет и порядок их выполнения определяется исходя из
   их ассоциативности.
   <table>
    <title>Порядок выполнения операторов</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Ассоциативность</entry>
       <entry>Оператор</entry>
       <entry>Дополнительная информация</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>(н/а)</entry>
       <entry>
        <literal>clone</literal>
        <literal>new</literal>
       </entry>
       <entry><link linkend="language.oop5.cloning">clone</link> и <link linkend="language.oop5.basic.new">new</link></entry>
      </row>
      <row>
       <entry>правая</entry>
       <entry><literal>**</literal></entry>
       <entry><link linkend="language.operators.arithmetic">арифметические операторы</link></entry>
      </row>
      <row>
       <entry>(н/а)</entry>
       <entry>
        <literal>+</literal>
        <literal>-</literal>
        <literal>++</literal>
        <literal>--</literal>
        <literal>~</literal>
        <literal>(int)</literal>
        <literal>(float)</literal>
        <literal>(string)</literal>
        <literal>(array)</literal>
        <literal>(object)</literal>
        <literal>(bool)</literal>
        <literal>@</literal>
       </entry>
       <entry>
        <link linkend="language.operators.arithmetic">арифметические операторы</link> (унарные <literal>+</literal> и <literal>-</literal>),
        <link linkend="language.operators.increment">инкремент/декремент</link>,
        <link linkend="language.operators.bitwise">побитовые операторы</link>,
        <link linkend="language.types.typecasting">приведение типов</link>&listendand;
        <link linkend="language.operators.errorcontrol">оператор управления ошибками</link>
       </entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry>instanceof</entry>
       <entry>
        <link linkend="language.operators.type">типы</link>
       </entry>
      </row>
      <row>
       <entry>(н/а)</entry>
       <entry>!</entry>
       <entry>
        <link linkend="language.operators.logical">логические операторы</link>
       </entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry>
        <literal>*</literal>
        <literal>/</literal>
        <literal>%</literal>
       </entry>
       <entry>
        <link linkend="language.operators.arithmetic">арифметические операторы</link>
       </entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry>
        <literal>+</literal>
        <literal>-</literal>
        <literal>.</literal>
       </entry>
       <entry>
        <link linkend="language.operators.arithmetic">арифметические операторы</link> (бинарные <literal>+</literal> и <literal>-</literal>),
        <link linkend="language.operators.array">операторы, работающие с массивами</link>&listendand;
        <link linkend="language.operators.string">строковые операторы</link> (<literal>.</literal> до PHP 8.0.0)
       </entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry>
        <literal>&lt;&lt;</literal>
        <literal>&gt;&gt;</literal>
       </entry>
       <entry>
        <link linkend="language.operators.bitwise">побитовые операторы</link>
       </entry>
      </row>
      <row>
        <entry>левая</entry>
        <entry><literal>.</literal></entry>
        <entry>
         <link linkend="language.operators.string">строковые операторы</link> (начиная с PHP 8.0.0)
        </entry>
       </row>
      <row>
       <entry>неассоциативна</entry>
       <entry>
        <literal>&lt;</literal>
        <literal>&lt;=</literal>
        <literal>&gt;</literal>
        <literal>&gt;=</literal>
       </entry>
       <entry>
        <link linkend="language.operators.comparison">операторы сравнения</link>
       </entry>
      </row>
      <row>
       <entry>неассоциативна</entry>
       <entry>
        <literal>==</literal>
        <literal>!=</literal>
        <literal>===</literal>
        <literal>!==</literal>
        <literal>&lt;&gt;</literal>
        <literal>&lt;=&gt;</literal>
       </entry>
       <entry>
        <link linkend="language.operators.comparison">операторы сравнения</link>
       </entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry><literal>&amp;</literal></entry>
       <entry>
        <link linkend="language.operators.bitwise">побитовые операторы</link>&listendand;
        <link linkend="language.references">ссылки</link></entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry><literal>^</literal></entry>
       <entry>
        <link linkend="language.operators.bitwise">побитовые операторы</link>
       </entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry><literal>|</literal></entry>
       <entry>
        <link linkend="language.operators.bitwise">побитовые операторы</link>
       </entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry><literal>&amp;&amp;</literal></entry>
       <entry>
        <link linkend="language.operators.logical">логические операторы</link>
       </entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry><literal>||</literal></entry>
       <entry>
        <link linkend="language.operators.logical">логические операторы</link>
       </entry>
      </row>
      <row>
       <entry>правая</entry>
       <entry><literal>??</literal></entry>
       <entry>
        <link linkend="language.operators.comparison.coalesce">операторы сравнения с null</link>
       </entry>
      </row>
      <row>
       <entry>неассоциативна</entry>
       <entry><literal>? :</literal></entry>
       <entry>
        <link linkend="language.operators.comparison.ternary">тернарный оператор</link>
        (лево-ассоциативный до PHP 8.0.0)
       </entry>
      </row>
      <row>
       <entry>правая</entry>
       <entry>
        <literal>=</literal>
        <literal>+=</literal>
        <literal>-=</literal>
        <literal>*=</literal>
        <literal>**=</literal>
        <literal>/=</literal>
        <literal>.=</literal>
        <literal>%=</literal>
        <literal>&amp;=</literal>
        <literal>|=</literal>
        <literal>^=</literal>
        <literal>&lt;&lt;=</literal>
        <literal>&gt;&gt;=</literal>
        <literal>??=</literal>
       </entry>
       <entry>
        <link linkend="language.operators.assignment">операторы присваивания</link>
       </entry>
      </row>
      <row>
       <entry>(н/а)</entry>
       <entry><literal>yield from</literal></entry>
       <entry>
        <link linkend="control-structures.yield.from">yield from</link>
       </entry>
      </row>
      <row>
       <entry>(н/а)</entry>
       <entry><literal>yield</literal></entry>
       <entry>
        <link linkend="control-structures.yield">yield</link>
       </entry>
      </row>
      <row>
       <entry>(н/а)</entry>
       <entry><literal>print</literal></entry>
       <entry><function>print</function></entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry><literal>and</literal></entry>
       <entry>
        <link linkend="language.operators.logical">логические операторы</link>
       </entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry><literal>xor</literal></entry>
       <entry>
        <link linkend="language.operators.logical">логические операторы</link>
       </entry>
      </row>
      <row>
       <entry>левая</entry>
       <entry><literal>or</literal></entry>
       <entry>
        <link linkend="language.operators.logical">логические операторы</link>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
  <para>
   <example>
    <title>Ассоциативность</title>
    <programlisting role="php">
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
// ассоциативность тернарных операторов отличается от C/C++
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2 (до PHP 8.0.0)

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Приоритет и ассоциативность оператора определяет только то, как группируется
   выражение, а не порядок его вычисления. Обычно PHP не указывает, в каком порядке
   вычисляются выражения и кода, который предполагает специфичный порядок вычисления
   следует избегать, потому, что поведение может меняться в разных версиях PHP или
   в зависимости от окружающего кода.

   <example>
    <title>Неопределённый порядок вычисления</title>
    <programlisting role="php">
<![CDATA[
<?php
$a = 1;
echo $a + $a++; // может вывести как 2 так и 3

$i = 1;
$array[$i] = $i++; // может установить индекс как 1, так 2
?>
]]>
    </programlisting>
   </example>
   <example>
    <title><literal>+</literal>, <literal>-</literal> и <literal>.</literal> имеют одинаковый приоритет (до PHP 8.0.0)</title>
    <programlisting role="php">
<![CDATA[
<?php
$x = 4;
// следующий код может выдать неожиданный результат:
echo "x минус 1 равно " . $x-1 . ", ну я надеюсь\n";
// поскольку он вычисляется таким образом (до PHP 8.0.0):
echo (("x минус один равно " . $x) - 1) . ", ну я надеюсь\n";
// требуемый приоритет следует задать скобками:
echo "x минус 1 равно " . ($x-1) . ", ну я надеюсь\n";
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
-1, ну я надеюсь
-1, ну я надеюсь
x минус один равно 3, ну я надеюсь
]]>
    </screen>
   </example>
  </para>
  <note>
   <para>
    Несмотря на то, что <literal>=</literal> имеет более низкий приоритет, чем большинство
    других операторов, PHP всё же позволяет делать так: <literal>if (!$a = foo())</literal>,
    в этом примере результат выполнения <literal>foo()</literal> будет присвоен
    <varname>$a</varname>.
   </para>
  </note>
  <sect2 role="changelog">
   &reftitle.changelog;
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>&Version;</entry>
       <entry>&Description;</entry>
      </row>
     </thead>
     <tbody>
      <row>
        <entry>8.0.0</entry>
        <entry>
         Объединение строк (<literal>.</literal>) теперь имеет более низкий приоритет, чем
         арифметическое сложение/вычитание (<literal>+</literal> и <literal>-</literal>) и
         побитовый сдвиг влево/вправо (<literal>&lt;&lt;</literal> и <literal>&gt;&gt;</literal>);
         ранее он имел тот же приоритет, что и <literal>+</literal> и <literal>-</literal>,
         и более высокий приоритет, чем <literal>&lt;&lt;</literal> и <literal>&gt;&gt;</literal>.
        </entry>
       </row>
      <row>
       <entry>8.0.0</entry>
       <entry>
        Тернарный оператор (<literal>? :</literal>) теперь неассоциативен;
        ранее он был лево-ассоциативным.
       </entry>
      </row>
      <row>
        <entry>7.4.0</entry>
        <entry>
         Опираясь на приоритет конкатенации строк (<literal>.</literal>) относительно
         арифметического сложения/вычитания (<literal>+</literal> или <literal>-</literal>) или побитового
         сдвига влево/вправо (<literal>&lt;&lt;</literal> или <literal>&gt;&gt;</literal>),
         т.е. их совместное использование в выражении без скобок не рекомендуется.
        </entry>
       </row>
      <row>
       <entry>7.4.0</entry>
       <entry>
        Не рекомендуется полагаться на лево-ассоциативность тернарного оператора (<literal>? :</literal>),
        т.е. вложение нескольких тернарных операторов без скобок.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </sect2>
 </sect1>

 <sect1 xml:id="language.operators.arithmetic">
  <title>Арифметические операторы</title>
  <simpara>
   Помните школьные основы арифметики? Описанные ниже операторы работают так же.
  </simpara>
  <table>
   <title>Арифметические операции</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Пример</entry>
      <entry>Название</entry>
      <entry>Результат</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>+$a</entry>
      <entry>Идентичность</entry>
      <entry>
       Конвертация <varname>$a</varname> в <type>int</type> или
       <type>float</type>, что более подходит.
      </entry>
     </row>
     <row>
      <entry>-$a</entry>
      <entry>Отрицание</entry>
      <entry>Смена знака <varname>$a</varname>.</entry>
     </row>
     <row>
      <entry>$a + $b</entry>
      <entry>Сложение</entry>
      <entry>Сумма <varname>$a</varname> и <varname>$b</varname>.</entry>
     </row>
     <row>
      <entry>$a - $b</entry>
      <entry>Вычитание</entry>
      <entry>Разность <varname>$a</varname> и <varname>$b</varname>.</entry>
     </row>
     <row>
      <entry>$a * $b</entry>
      <entry>Умножение</entry>
      <entry>Произведение <varname>$a</varname> и <varname>$b</varname>.</entry>
     </row>
     <row>
      <entry>$a / $b</entry>
      <entry>Деление</entry>
      <entry>Частное от деления <varname>$a</varname> на <varname>$b</varname>.</entry>
     </row>
     <row>
      <entry>$a % $b</entry>
      <entry>Деление по модулю</entry>
      <entry>Целочисленный остаток от деления <varname>$a</varname> на <varname>$b</varname>.</entry>
     </row>
     <row>
      <entry>$a ** $b</entry>
      <entry>Возведение в степень</entry>
      <entry>Возведение <varname>$a</varname> в степень <varname>$b</varname>.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <simpara>
   Операция деления ("/") возвращает число с плавающей точкой, кроме случая,
   когда оба значения являются целыми числами (или строками, которые преобразуются
   в целые числа), которые делятся нацело - в этом случае возвращается целое значение.
   Для целочисленного деления используйте <function>intdiv</function>.
  </simpara>
  <simpara>
   При делении по модулю операнды преобразуются в целые числа (<type>int</type>) (путём удаления дробной части)
   до начала операции. Для деления по модулю чисел с плавающей точкой используйте
   <function>fmod</function>.
  </simpara>
  <para>
   Результат операции остатка от деления <literal>%</literal> будет иметь тот же знак,
   что и делимое — то есть, результат <literal>$a % $b</literal>
   будет иметь тот же знак, что и <varname>$a</varname>. Например:
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php

echo (5 % 3)."\n";           // выводит 2
echo (5 % -3)."\n";          // выводит 2
echo (-5 % 3)."\n";          // выводит -2
echo (-5 % -3)."\n";         // выводит -2

?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <sect2 role="seealso">
   &reftitle.seealso;
   <para>
    <simplelist>
     <member><link linkend="ref.math">Математические функции</link></member>
    </simplelist>
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="language.operators.assignment">
  <title>Оператор присваивания</title>
  <simpara>
   Базовый оператор присваивания обозначается как "=". На первый взгляд
   может показаться, что это оператор "равно". На самом деле это не так.
   В действительности оператор присваивания означает, что левый операнд
   получает значение правого выражения, (то есть устанавливается значением).
  </simpara>
  <para>
   Результатом выполнения оператора присваивания является само присвоенное значение.
   Таким образом, результат выполнения "<literal>$a = 3</literal>" будет равен
   3. Это позволяет делать трюки наподобие:
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php

$a = ($b = 4) + 5; // $a теперь равно 9, а $b было присвоено 4.

?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   В дополнение к базовому оператору присваивания имеются "комбинированные операторы"
   для всех  <link linkend="language.operators">бинарных арифметических</link> операций,
   операций объединения массивов и строковых операций, которые позволяют
   использовать некоторое значение в выражении, а затем установить его как
   результат данного выражения. Например:
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php

$a = 3;
$a += 5; // устанавливает $a в 8, как если бы мы написали: $a = $a + 5;
$b = "Привет";
$b .= "-привет!"; // устанавливает $b в "Привет-привет!",  как и $b = $b . "-привет!";

?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   Обратите внимание, что присвоение копирует оригинальную переменную в новую
   (присвоение по значению), таким образом все последующие изменения
   одной из переменных никак не отразятся на другой. Это также следует учитывать,
   если вам надо скопировать что-то типа большого массива в длинном цикле.
  </para>
  <para>
   Исключением из обычного для PHP способа присваивания по значению являются объекты
   (<type>object</type>), которые присваиваются по ссылке.
   Принудительно скопировать объекты по значению можно с помощью
   специального ключевого слова <link linkend="language.oop5.cloning">clone</link>.
  </para>

  <sect2 xml:id="language.operators.assignment.reference">
   <title>Присваивание по ссылке</title>
   <para>
    Присваивание по ссылке также поддерживается, для него используется синтаксис
    <computeroutput>$var = &amp;$othervar;</computeroutput>.
    Присваивание по ссылке означает, что обе переменные указывают на
    одни и те же данные и никакого копирования не происходит.
   </para>
   <para>
    <example>
     <title>Присваивание по ссылке</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3;
$b = &$a; // $b - это ссылка на $a

print "$a\n"; // печатает 3
print "$b\n"; // печатает 3

$a = 4; // меняем $a

print "$a\n"; // печатает 4
print "$b\n"; // также печатает 4, так как $b является ссылкой на $a,
              // а значение переменной $a успело измениться
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Оператор <link linkend="language.oop5.basic.new">new</link>
    автоматически возвращает ссылку, так как присвоение результата операции
    <link linkend="language.oop5.basic.new">new</link> по ссылке является ошибкой.
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class C {}

$o = &new C;
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Parse error: syntax error, unexpected 'new' (T_NEW) in …
]]>
     </screen>
    </informalexample>
   </para>
   <para>
    Для получения более полной информации о ссылках и их возможностях обратитесь к
    разделу <link linkend="language.references">Подробно о ссылках</link>.
   </para>
  </sect2>

  <sect2 xml:id="language.operators.assignment.arithmetic">
   <title>Операторы арифметического присваивания</title>
   <informaltable>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Эквивалент</entry>
       <entry>Операция</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a += $b</entry>
       <entry>$a = $a + $b</entry>
       <entry>Сложение</entry>
      </row>
      <row>
       <entry>$a -= $b</entry>
       <entry>$a = $a - $b</entry>
       <entry>Вычитание</entry>
      </row>
      <row>
       <entry>$a *= $b</entry>
       <entry>$a = $a * $b</entry>
       <entry>Умножение</entry>
      </row>
      <row>
       <entry>$a /= $b</entry>
       <entry>$a = $a / $b</entry>
       <entry>Деление</entry>
      </row>
      <row>
       <entry>$a %= $b</entry>
       <entry>$a = $a % $b</entry>
       <entry>Модуль</entry>
      </row>
      <row>
       <entry>$a **= $b</entry>
       <entry>$a = $a ** $b</entry>
       <entry>Возведение в степень</entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </sect2>

  <sect2 xml:id="language.operators.assignment.bitwise">
   <title>Операторы побитового присваивания</title>
   <informaltable>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Эквивалент</entry>
       <entry>Операция</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a &amp;= $b</entry>
       <entry>$a = $a &amp; $b</entry>
       <entry>Побитовое И</entry>
      </row>
      <row>
       <entry>$a |= $b</entry>
       <entry>$a = $a | $b</entry>
       <entry>Побитовое ИЛИ</entry>
      </row>
      <row>
       <entry>$a ^= $b</entry>
       <entry>$a = $a ^ $b</entry>
       <entry>Побитовое исключающее ИЛИ (Xor)</entry>
      </row>
      <row>
       <entry>$a &lt;&lt;= $b</entry>
       <entry>$a = $a &lt;&lt; $b</entry>
       <entry>Побитовый сдвиг влево</entry>
      </row>
      <row>
       <entry>$a &gt;&gt;= $b</entry>
       <entry>$a = $a &gt;&gt; $b</entry>
       <entry>Побитовый сдвиг вправо</entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </sect2>

  <sect2 xml:id="language.operators.assignment.other">
   <title>Другие операторы присваивания</title>
   <informaltable>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Пример</entry>
       <entry>Эквивалент</entry>
       <entry>Операция</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a .= $b</entry>
       <entry>$a = $a . $b</entry>
       <entry>Конкатенация строк</entry>
      </row>
      <row>
       <entry>$a ??= $b</entry>
       <entry>$a = $a ?? $b</entry>
       <entry>Объединение с Null</entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </sect2>

  <sect2 role="seealso" xml:id="language.operators.assignment.see-also">
   &reftitle.seealso;
   <para>
    <simplelist>
     <member><link linkend="language.operators.arithmetic">арифметические операторы</link></member>
     <member><link linkend="language.operators.bitwise">побитовые операторы</link></member>
     <member><link linkend="language.operators.comparison.coalesce">операторы объединения с null</link></member>
    </simplelist>
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="language.operators.bitwise">
  <title>Побитовые операторы</title>
  <simpara>
   Побитовые операторы позволяют считывать и устанавливать конкретные биты
   целых чисел.
  </simpara>
  <table>
   <title>Побитовые операторы</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Пример</entry>
      <entry>Название</entry>
      <entry>Результат</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><userinput>$a &amp; $b</userinput></entry>
      <entry>И</entry>
      <entry>Устанавливаются только те биты, которые установлены и в <varname>$a</varname>, и в <varname>$b</varname>.</entry>
     </row>
     <row>
      <entry><userinput>$a | $b</userinput></entry>
      <entry>Или</entry>
      <entry>Устанавливаются те биты, которые установлены в <varname>$a</varname> или в <varname>$b</varname>.</entry>
     </row>
     <row>
      <entry><userinput>$a ^ $b</userinput></entry>
      <entry>Исключающее или</entry>
      <entry>
       Устанавливаются только те биты, которые установлены либо только в <varname>$a</varname>,
       либо только в <varname>$b</varname>, но не в обоих одновременно.
      </entry>
     </row>
     <row>
      <entry><userinput>~ $a</userinput></entry>
      <entry>Отрицание</entry>
      <entry>
       Устанавливаются те биты, которые не установлены в <varname>$a</varname>, и наоборот.
      </entry>
     </row>
     <row>
      <entry><userinput>$a &lt;&lt; $b</userinput></entry>
      <entry>Сдвиг влево</entry>
      <entry>
       Все биты переменной <varname>$a</varname> сдвигаются на <varname>$b</varname>
       позиций влево (каждая позиция подразумевает "умножение на 2")
      </entry>
     </row>
     <row>
      <entry><userinput>$a &gt;&gt; $b</userinput></entry>
      <entry>Сдвиг вправо</entry>
      <entry>
       Все биты переменной <varname>$a</varname> сдвигаются на <varname>$b</varname> позиций вправо
       (каждая позиция подразумевает "деление на 2")
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   Побитовый сдвиг в PHP - это арифметическая операция.
   Биты, сдвинутые за границы числа, отбрасываются.
   Сдвиг влево дополняет число нулями справа, сдвигая в то же время знаковый бит числа
   влево, что означает что знак операнда не сохраняется.
   Сдвиг вправо сохраняет копию сдвинутого знакового бита слева, что означает
   что знак операнда сохраняется.
  </para>
  <para>
   Используйте скобки для обеспечения необходимого
   <link linkend="language.operators.precedence"> приоритета операторов</link>.
   Например, <literal>$a &amp; $b == true</literal> сначала проверяет
   на равенство, а потом выполняет побитовое и; тогда как
   <literal>($a &amp; $b) == true</literal> сначала выполняет побитовое и,
   а потом выполняет проверку на равенство.
  </para>
  <para>
   Если оба операнда для <literal>&amp;</literal>, <literal>|</literal> и
   <literal>^</literal> строки, то операция будет производиться с кодами ASCII всех
   символов строки и в результате вернёт строку. Во всех остальных случаях, оба операнда
   будут <link linkend="language.types.integer.casting">преобразованы к целому</link> и
   результатом будет целое число.
  </para>
  <para>
   Если операнд для <literal>~</literal> строка, то операция будет производиться с кодами
   ASCII всех символов строки и в результате вернёт строку, в ином случае как операнд,
   так и результат, будут считаться целыми.
  </para>
  <para>
   Оба операнда и результат выполнения <literal>&lt;&lt;</literal> и
   <literal>&gt;&gt;</literal> всегда считаются за целое.
  </para>
  <para>
   <informalexample>
    <para>
     <literallayout>
      Опция настроек PHP error_reporting использует побитовые значения, обеспечивая
      реальную демонстрацию удаления значений битов. Чтобы показать все ошибки, кроме
      замечаний, инструкции в файле php.ini предлагают использовать:
      <userinput>E_ALL &amp; ~E_NOTICE</userinput>
     </literallayout>
    </para>
    <para>
     <literallayout>
      Начинаем со значения E_ALL:
      <computeroutput>00000000000000000111011111111111</computeroutput>
      Затем берём значение E_NOTICE...
      <computeroutput>00000000000000000000000000001000</computeroutput>
      ... и инвертируем его с помощью <literal>~</literal>:
      <computeroutput>11111111111111111111111111110111</computeroutput>
      Наконец, используем побитовое И (&amp;), чтобы установить только те биты,
      которые установлены в единицу в обоих значениях:
      <computeroutput>00000000000000000111011111110111</computeroutput>
     </literallayout>
    </para>
    <para>
     <literallayout>
      Другой способ достичь этого - использовать ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR, <literal>^</literal>),
      чтобы получить только те биты, которые установлены в единицу
      либо только в одном, либо только в другом значении:
      <userinput>E_ALL ^ E_NOTICE</userinput>
     </literallayout>
    </para>
   </informalexample>
  </para>
  <para>
   <informalexample>
    <para>
     <literallayout>
      Опция error_reporting также может быть использована для демонстрации
      установки битов. Показать только ошибки и обрабатываемые ошибки можно
      следующим образом:
      <userinput>E_ERROR | E_RECOVERABLE_ERROR</userinput>
     </literallayout>
    </para>
    <para>
     <literallayout>
      Здесь мы комбинируем E_ERROR
      <computeroutput>00000000000000000000000000000001</computeroutput>
      и
      <computeroutput>00000000000000000001000000000000</computeroutput>
      с помощью оператора ИЛИ (<literal>|</literal>),
      чтобы получить биты, установленные хотя бы в одном операнде:
      <computeroutput>00000000000000000001000000000001</computeroutput>
     </literallayout>
    </para>
   </informalexample>
  </para>
  <para>
   <example>
    <title>Побитовыми операции И, ИЛИ и ИСКЛЮЧАЮЩЕЕ ИЛИ (AND, OR и XOR) над целыми числами</title>
    <programlisting role="php">
<![CDATA[
<?php
/*
 * Не обращайте внимания на этот верхний раздел кода,
 * это просто форматирование для более ясного вывода.
 */

$format = '(%1$2d = %1$04b) = (%2$2d = %2$04b)'
        . ' %3$s (%4$2d = %4$04b)' . "\n";

echo <<<EOH
 ----------   ----------- -- ----------
 результат      значение      оп тест
 ----------   ----------- -- ----------
EOH;


/*
 * Вот сами примеры.
 */

$values = array(0, 1, 2, 4, 8);
$test = 1 + 4;

echo "\n Побитовое И (AND) \n";
foreach ($values as $value) {
    $result = $value & $test;
    printf($format, $result, $value, '&', $test);
}

echo "\n Побитовое (включающее) ИЛИ (OR) \n";
foreach ($values as $value) {
    $result = $value | $test;
    printf($format, $result, $value, '|', $test);
}

echo "\n Побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR) \n";
foreach ($values as $value) {
    $result = $value ^ $test;
    printf($format, $result, $value, '^', $test);
}
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
 ----------   ----------- -- ----------
 результат      значение      оп тест
 ----------   ----------- -- ----------
 Побитовое И (AND)
( 0 = 0000) = ( 0 = 0000) & ( 5 = 0101)
( 1 = 0001) = ( 1 = 0001) & ( 5 = 0101)
( 0 = 0000) = ( 2 = 0010) & ( 5 = 0101)
( 4 = 0100) = ( 4 = 0100) & ( 5 = 0101)
( 0 = 0000) = ( 8 = 1000) & ( 5 = 0101)

 Побитовое (включающее) ИЛИ (OR)
( 5 = 0101) = ( 0 = 0000) | ( 5 = 0101)
( 5 = 0101) = ( 1 = 0001) | ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) | ( 5 = 0101)
( 5 = 0101) = ( 4 = 0100) | ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) | ( 5 = 0101)

 Побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR)
( 5 = 0101) = ( 0 = 0000) ^ ( 5 = 0101)
( 4 = 0100) = ( 1 = 0001) ^ ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) ^ ( 5 = 0101)
( 1 = 0001) = ( 4 = 0100) ^ ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) ^ ( 5 = 0101)
]]>
    </screen>
   </example>
  </para>
  <para>
   <example>
    <title>Побитовая операция ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR) над строками</title>
    <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // Выводит '5'

echo "12" ^ "9"; // Выводит символ Backspace (ascii 8)
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; // Выводит ascii-значения #0 #4 #0 #0 #0
                        // 'a' ^ 'e' = #4

echo 2 ^ "3"; // Выводит 1
              // 2 ^ ((int)"3") == 1

echo "2" ^ 3; // Выводит 1
              // ((int)"2") ^ 3 == 1
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Побитовый сдвиг над целыми числами</title>
    <programlisting role="php">
<![CDATA[
<?php
/*
 * Несколько примеров.
 */

echo "\n--- СДВИГ ВПРАВО НАД ПОЛОЖИТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---\n";

$val = 4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'слева была вставлена копия знакового бита');

$val = 4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places);

$val = 4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'биты были выдвинуты за правый край');

$val = 4;
$places = 4;
$res = $val >> $places;
p($res, $val, '>>', $places, 'то же, что и выше; нельзя сдвинуть дальше 0');


echo "\n--- СДВИГ ВПРАВО НАД ОТРИЦАТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---\n";

$val = -4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'слева была вставлена копия знакового бита');

$val = -4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places, 'биты были выдвинуты за правый край');

$val = -4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'то же, что и выше; нельзя сдвинуть дальше -1');


echo "\n--- СДВИГ ВЛЕВО НАД ПОЛОЖИТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---\n";

$val = 4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'правый край был дополнен нулями');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 4;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = 4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places, 'знаковые биты были выдвинуты');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'биты были выдвинуты за левый край');


echo "\n--- СДВИГ ВЛЕВО НАД ОТРИЦАТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---\n";

$val = -4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'правый край был дополнен нулями');

$val = -4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = -4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'биты были выдвинуты за левый край, включая знаковый бит');


/*
 * Не обращайте внимания на этот нижний раздел кода,
 * это просто форматирование для более ясного вывода.
 */

function p($res, $val, $op, $places, $note = '') {
    $format = '%0' . (PHP_INT_SIZE * 8) . "b\n";

    printf("Выражение: %d = %d %s %d\n", $res, $val, $op, $places);

    echo " Десятичный вид:\n";
    printf("  val=%d\n", $val);
    printf("  res=%d\n", $res);

    echo " Двоичный вид:\n";
    printf('  val=' . $format, $val);
    printf('  res=' . $format, $res);

    if ($note) {
        echo " ЗАМЕЧАНИЕ: $note\n";
    }

    echo "\n";
}
?>
]]>
    </programlisting>
    &example.outputs.32bit;
    <screen>
<![CDATA[

--- СДВИГ ВПРАВО НАД ПОЛОЖИТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---
Выражение: 2 = 4 >> 1
 Десятичный вид:
  val=4
  res=2
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000010
 ЗАМЕЧАНИЕ: слева была вставлена копия знакового бита

Выражение: 1 = 4 >> 2
 Десятичный вид:
  val=4
  res=1
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000001

Выражение: 0 = 4 >> 3
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были выдвинуты за правый край

Выражение: 0 = 4 >> 4
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 ЗАМЕЧАНИЕ: то же, что и выше; нельзя сдвинуть дальше 0


--- СДВИГ ВПРАВО НА ОТРИЦАТЕЛЬНЫХ ЦЕЛЫХ ЧИСЛАХ ---
Выражение: -2 = -4 >> 1
 Десятичный вид:
  val=-4
  res=-2
 Двоичный вид:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111110
 ЗАМЕЧАНИЕ: слева была вставлена копия знакового бита

Выражение: -1 = -4 >> 2
 Десятичный вид:
  val=-4
  res=-1
 Двоичный вид:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 ЗАМЕЧАНИЕ: биты были выдвинуты за правый край

Выражение: -1 = -4 >> 3
 Десятичный вид:
  val=-4
  res=-1
 Двоичный вид:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 ЗАМЕЧАНИЕ: то же, что и выше; нельзя сдвинуть дальше -1


--- СДВИГ ВЛЕВО НАД ПОЛОЖИТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---
Выражение: 8 = 4 << 1
 Десятичный вид:
  val=4
  res=8
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000001000
 ЗАМЕЧАНИЕ: правый край был дополнен нулями

Выражение: 1073741824 = 4 << 28
 Десятичный вид:
  val=4
  res=1073741824
 Двоичный вид:
  val=00000000000000000000000000000100
  res=01000000000000000000000000000000

Выражение: -2147483648 = 4 << 29
 Десятичный вид:
  val=4
  res=-2147483648
 Двоичный вид:
  val=00000000000000000000000000000100
  res=10000000000000000000000000000000
 ЗАМЕЧАНИЕ: знаковые биты были выдвинуты

Выражение: 0 = 4 << 30
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были выдвинуты за левый край


--- СДВИГ ВЛЕВО НАД ОТРИЦАТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---
Выражение: -8 = -4 << 1
 Десятичный вид:
  val=-4
  res=-8
 Двоичный вид:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111000
 ЗАМЕЧАНИЕ: правый край был дополнен нулями

Выражение: -2147483648 = -4 << 29
 Десятичный вид:
  val=-4
  res=-2147483648
 Двоичный вид:
  val=11111111111111111111111111111100
  res=10000000000000000000000000000000

Выражение: 0 = -4 << 30
 Десятичный вид:
  val=-4
  res=0
 Двоичный вид:
  val=11111111111111111111111111111100
  res=00000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были выдвинуты за левый край, включая знаковый бит
]]>
    </screen>
    &example.outputs.64bit;
    <screen>
<![CDATA[

--- СДВИГ ВПРАВО НАД ПОЛОЖИТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---
Выражение: 2 = 4 >> 1
 Десятичный вид:
  val=4
  res=2
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000010
 ЗАМЕЧАНИЕ: слева была вставлена копия знакового бита

Выражение: 1 = 4 >> 2
 Десятичный вид:
  val=4
  res=1
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000001

Выражение: 0 = 4 >> 3
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были выдвинуты за правый край

Выражение: 0 = 4 >> 4
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 ЗАМЕЧАНИЕ: то же, что и выше; нельзя сдвинуть дальше 0


--- СДВИГ ВПРАВО НАД ОТРИЦАТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---
Выражение: -2 = -4 >> 1
 Десятичный вид:
  val=-4
  res=-2
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111110
 ЗАМЕЧАНИЕ: слева была вставлена копия знакового бита

Выражение: -1 = -4 >> 2
 Десятичный вид:
  val=-4
  res=-1
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 ЗАМЕЧАНИЕ: биты были выдвинуты за правый край

Выражение: -1 = -4 >> 3
 Десятичный вид:
  val=-4
  res=-1
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 ЗАМЕЧАНИЕ: то же, что и выше; нельзя сдвинуть дальше -1


--- СДВИГ ВЛЕВО НАД ПОЛОЖИТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---
Выражение: 8 = 4 << 1
 Десятичный вид:
  val=4
  res=8
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000001000
 ЗАМЕЧАНИЕ: правый край был дополнен нулями

Выражение: 4611686018427387904 = 4 << 60
 Десятичный вид:
  val=4
  res=4611686018427387904
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0100000000000000000000000000000000000000000000000000000000000000

Выражение: -9223372036854775808 = 4 << 61
 Десятичный вид:
  val=4
  res=-9223372036854775808
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=1000000000000000000000000000000000000000000000000000000000000000
 ЗАМЕЧАНИЕ: знаковые биты были выдвинуты

Выражение: 0 = 4 << 62
 Десятичный вид:
  val=4
  res=0
 Двоичный вид:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были выдвинуты за левый край


--- СДВИГ ВЛЕВО НАД ОТРИЦАТЕЛЬНЫМИ ЦЕЛЫМИ ЧИСЛАМИ ---
Выражение: -8 = -4 << 1
 Десятичный вид:
  val=-4
  res=-8
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111000
 ЗАМЕЧАНИЕ: правый край был дополнен нулями

Выражение: -9223372036854775808 = -4 << 61
 Десятичный вид:
  val=-4
  res=-9223372036854775808
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1000000000000000000000000000000000000000000000000000000000000000

Выражение: 0 = -4 << 62
 Десятичный вид:
  val=-4
  res=0
 Двоичный вид:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=0000000000000000000000000000000000000000000000000000000000000000
 ЗАМЕЧАНИЕ: биты были выдвинуты за левый край, включая знаковый бит
]]>
    </screen>
   </example>
  </para>
  <warning>
   <para>
    Используйте функции из модуля <link linkend="book.gmp">gmp</link> для побитовых
    операций над числами, большими чем <literal>PHP_INT_MAX</literal>.
   </para>
  </warning>

  <sect2 role="seealso">
   &reftitle.seealso;
   <para>
    <simplelist>
     <!-- <link linkend="language.oop5.basic.class.class">::class</link> -->
     <member><function>pack</function></member>
     <member><function>unpack</function></member>
     <member><function>gmp_and</function></member>
     <member><function>gmp_or</function></member>
     <member><function>gmp_xor</function></member>
     <member><function>gmp_testbit</function></member>
     <member><function>gmp_clrbit</function></member>
    </simplelist>
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="language.operators.comparison">
  <title>Операторы сравнения</title>
  <simpara>
   Операторы сравнения, как это видно из их названия, позволяют сравнивать между собой
   два значения. Возможно вам будет интересно также ознакомиться с разделом
   <link linkend="types.comparisons">Сравнение типов</link>, в котором приведено большое
   количество соответствующих примеров.
  </simpara>
  <table>
   <title>Операторы сравнения</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Пример</entry>
      <entry>Название</entry>
      <entry>Результат</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>$a == $b</entry>
      <entry>Равно</entry>
      <entry>&true; если <varname>$a</varname> равно <varname>$b</varname>
       после преобразования типов.</entry>
     </row>
     <row>
      <entry>$a === $b</entry>
      <entry>Тождественно равно</entry>
      <entry>
       &true; если <varname>$a</varname> равно <varname>$b</varname> и имеет тот же тип.
      </entry>
     </row>
     <row>
      <entry>$a != $b</entry>
      <entry>Не равно</entry>
      <entry>&true; если <varname>$a</varname> не равно <varname>$b</varname>
       после преобразования типов.</entry>
     </row>
     <row>
      <entry>$a &lt;&gt; $b</entry>
      <entry>Не равно</entry>
      <entry>&true; если <varname>$a</varname> не равно <varname>$b</varname>
       после преобразования типов.</entry>
     </row>
     <row>
      <entry>$a !== $b</entry>
      <entry>Тождественно не равно</entry>
      <entry>
       &true; если <varname>$a</varname> не равно <varname>$b</varname>, или они разных типов.
      </entry>
     </row>
     <row>
      <entry>$a &lt; $b</entry>
      <entry>Меньше</entry>
      <entry>&true; если <varname>$a</varname> строго меньше <varname>$b</varname>.</entry>
     </row>
     <row>
      <entry>$a &gt; $b</entry>
      <entry>Больше</entry>
      <entry>&true; если <varname>$a</varname> строго больше <varname>$b</varname>.</entry>
     </row>
     <row>
      <entry>$a &lt;= $b</entry>
      <entry>Меньше или равно</entry>
      <entry>&true; если <varname>$a</varname> меньше или равно <varname>$b</varname>.</entry>
     </row>
     <row>
      <entry>$a &gt;= $b</entry>
      <entry>Больше или равно</entry>
      <entry>&true; если <varname>$a</varname> больше или равно <varname>$b</varname>.</entry>
     </row>
     <row>
      <entry>$a &lt;=&gt; $b</entry>
      <entry>Космический корабль (spaceship)</entry>
      <entry>
       Число типа <type>int</type> меньше, больше или равное нулю, когда
       <varname>$a</varname> соответственно меньше, больше или равно
       <varname>$b</varname>.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   В случае, если оба операнда являются
   <link linkend="language.types.numeric-strings">строками, содержащими числа</link>
   или один операнд является числом, а другой - <link linkend="language.types.numeric-strings">строкой, содержащей числа</link>,
   то сравнение выполняется численно.
   Эти правила также применяются к оператору <link linkend="control-structures.switch">switch</link>.
   Преобразование типа не происходит при сравнении
   <literal>===</literal> или <literal>!==</literal>, поскольку это включает сравнение
   типа, а также значения.
  </para>

  <warning>
   <para>
    До PHP 8.0.0, если строка (<type>string</type>) сравнивалась с числом
    или строкой, содержащей число, то строка (<type>string</type>) преобразовывалось
    в число перед выполнением сравнения. Это могло привести к неожиданным
    результатам, что можно увидеть на следующем примере:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a");
var_dump("1" == "01");
var_dump("10" == "1e1");
var_dump(100 == "1e2");

switch ("a") {
case 0:
    echo "0";
    break;
case "a":
    echo "a";
    break;
}
?>
]]>
     </programlisting>
      &example.outputs.7;
      <screen>
<![CDATA[
bool(true)
bool(true)
bool(true)
bool(true)
0
]]>
      </screen>
      &example.outputs.8;
      <screen>
<![CDATA[
bool(false)
bool(true)
bool(true)
bool(true)
a
]]>
      </screen>
    </informalexample>
   </para>
  </warning>

  <para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// Целые числа
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1

// Числа с плавающей точкой
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1

// Строки
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1

echo "a" <=> "aa"; // -1
echo "zz" <=> "aa"; // 1

// Массивы
echo [] <=> []; // 0
echo [1, 2, 3] <=> [1, 2, 3]; // 0
echo [1, 2, 3] <=> []; // 1
echo [1, 2, 3] <=> [1, 2, 1]; // 1
echo [1, 2, 3] <=> [1, 2, 4]; // -1

// Объекты
$a = (object) ["a" => "b"];
$b = (object) ["a" => "b"];
echo $a <=> $b; // 0

$a = (object) ["a" => "b"];
$b = (object) ["a" => "c"];
echo $a <=> $b; // -1

$a = (object) ["a" => "c"];
$b = (object) ["a" => "b"];
echo $a <=> $b; // 1

// сравниваются не только значения; ключи также должны совпадать
$a = (object) ["a" => "b"];
$b = (object) ["b" => "b"];
echo $a <=> $b; // 1

?>
]]>

    </programlisting>
   </informalexample>
  </para>
  <para>
   Для различных типов сравнение происходит в соответствии со следующей
   таблицей (по порядку).
  </para>
  <table xml:id="language.operators.comparison.types">
   <title>Сравнение различных типов</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Тип операнда 1</entry>
      <entry>Тип операнда 2</entry>
      <entry>Результат</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><type>null</type> или <type>string</type></entry>
      <entry><type>string</type></entry>
      <entry>&null; преобразуется в "", числовое или лексическое сравнение</entry>
     </row>
     <row>
      <entry><type>bool</type> или <type>null</type></entry>
      <entry>что угодно</entry>
      <entry>Преобразуется в тип <type>bool</type>, &false; &lt; &true;</entry>
     </row>
     <row>
      <entry><type>object</type></entry>
      <entry><type>object</type></entry>
      <entry>Встроенные классы могут определять свои собственные правила сравнения,
       объекты разных классов не сравниваются, про сравнение объектов одного класса смотрите <link
       linkend="language.oop5.object-comparison">Сравнение объекта</link>
      </entry>
     </row>
     <row>
      <entry><type>string</type>, <type>resource</type>, <type>int</type> или <type>float</type></entry>
      <entry><type>string</type>, <type>resource</type>, <type>int</type> или <type>float</type></entry>
      <entry>Строки и ресурсы переводятся в числа, обычная математика</entry>
     </row>
     <row>
      <entry><type>array</type></entry>
      <entry><type>array</type></entry>
      <entry>Массивы с меньшим числом элементов считаются меньше,
       если ключ из первого операнда не найден во втором операнде
       - массивы не могут сравниваться, иначе идёт сравнение соответствующих
       значений (смотрите пример ниже)</entry>
     </row>
     <row>
      <entry><type>array</type></entry>
      <entry>что угодно</entry>
      <entry>тип <type>array</type> всегда больше</entry>
     </row>
     <row>
      <entry><type>object</type></entry>
      <entry>что угодно</entry>
      <entry>тип <type>object</type> всегда больше</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <example>
    <title>Сравнение boolean/null</title>
    <programlisting role="php">
<![CDATA[
<?php
// Логические значения и null всегда сравниваются как логические
var_dump(1 == TRUE);  // TRUE - то же, что и (bool)1 == TRUE
var_dump(0 == FALSE); // TRUE - то же, что и (bool)0 == FALSE
var_dump(100 < TRUE); // FALSE - то же, что и (bool)100 < TRUE
var_dump(-10 < FALSE);// FALSE - то же, что и (bool)-10 < FALSE
var_dump(min(-100, -10, NULL, 10, 100)); // NULL - (bool)NULL < (bool)-100 это FALSE < TRUE
?>
]]>
    </programlisting>
   </example>
  </para>

  <para>
   <example>
    <title>Алгоритм сравнения обычных массивов</title>
    <programlisting role="php">
<![CDATA[
<?php
// Так сравниваются массивы при сравнении стандартными операторами
function standard_array_compare($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }
    foreach ($op1 as $key => $val) {
        if (!array_key_exists($key, $op2)) {
            return null; // не могут быть сравнимы
        } elseif ($val < $op2[$key]) {
            return -1;
        } elseif ($val > $op2[$key]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?>
]]>
    </programlisting>
   </example>
  </para>

  <warning>
   <title>Сравнение чисел с плавающей точкой</title>

   <para>
    Из-за особого внутреннего представления типа <type>float</type>, не нужно
    проверять на равенство два числа с плавающей точкой (<type>float</type>).
   </para>

   <para>
    Для более подробной информации смотрите документацию по типу <type>float</type>.
   </para>
  </warning>

  <sect2 role="seealso">
   &reftitle.seealso;
   <para>
    <simplelist>
     <member><function>strcasecmp</function></member>
     <member><function>strcmp</function></member>
     <member><link linkend="language.operators.array">Операторы, работающие с массивами</link></member>
     <member><link linkend="language.types">Типы</link></member>
    </simplelist>
   </para>
  </sect2>

  <sect2 xml:id="language.operators.comparison.ternary">
   <title>Тернарный оператор</title>
   <para>
    Ещё одним условным оператором является тернарный оператор "?:".
    <example>
     <title>Присваивание значения по умолчанию</title>
     <programlisting role="php">
<![CDATA[
<?php
// Пример использования тернарного оператора
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// Приведённый выше код аналогичен следующему блоку с использованием if/else
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}

?>
]]>
     </programlisting>
    </example>
    Выражение <literal>(expr1) ? (expr2) : (expr3)</literal>
    интерпретируется как <replaceable>expr2</replaceable>, если
    <replaceable>expr1</replaceable> имеет значение &true;, или как
    <replaceable>expr3</replaceable>, если
    <replaceable>expr1</replaceable> имеет значение &false;.
   </para>
   <para>
    Также стало возможным не писать среднюю часть
    тернарного оператора. Выражение <literal>expr1 ?: expr3</literal>
    возвращает <replaceable>expr1</replaceable> если <replaceable>expr1</replaceable>
    имеет значение &true; и <replaceable>expr3</replaceable> в противном случае.
   </para>
   <note>
    <simpara>
     Обратите внимание, что тернарный оператор является выражением
     и трактуется не как переменная, а как результат выражения. Это важно знать,
     если вы хотите вернуть переменную по ссылке.
     Выражение <literal>return $var == 42 ? $a : $b;</literal> не будет
     работать в функции, возвращающей значение по ссылке, а в более поздних
     версиях PHP также будет выдано предупреждение.
    </simpara>
   </note>
   <note>
    <para>
     Рекомендуется избегать "нагромождения" тернарных выражений.
     Поведение PHP неочевидно при использовании более чем одного тернарного оператора без скобок
     в одном выражении по сравнению с другими языками.
     Действительно, до PHP 8.0.0 троичные выражения оценивались лево-ассоциативными, а не право-ассоциативными, как в большинстве других языков программирования.
     Использование лево-ассоциативности устарело в PHP 7.4.0.
     Начиная с PHP 8.0.0, тернарный оператор неассоциативен.
     <example>
      <title>Неочевидное поведение тернарного оператора</title>
      <programlisting role="php">
<![CDATA[
<?php
// на первый взгляд, следующий код должен вывести 'true'
echo (true ? 'true' : false ? 't' : 'f');

// однако, он выводит 't' до PHP 8.0.0
// это потому, что тернарные выражения левоассоциативны

// это намного более очевидная версия вышеприведённого кода
echo ((true ? 'true' : false) ? 't' : 'f');

// здесь видно, что первое выражение вычисляется в 'true', которое
// в свою очередь вычисляется в (bool)true, таким образом возвращая истинную ветвь
// второго тернарного выражения.
?>
]]>
      </programlisting>
     </example>
    </para>
   </note>
  </sect2>

  <sect2 xml:id="language.operators.comparison.coalesce">
   <title>Оператор объединения с null</title>
   <para>
    Также добавился новый оператор "??" (null coalescing).
    <example>
     <title>Присваивание значения по умолчанию</title>
     <programlisting role="php">
<![CDATA[
<?php
// Пример использования оператора
$action = $_POST['action'] ?? 'default';

// Пример выше аналогичен следующему коду
if (isset($_POST['action'])) {
    $action = $_POST['action'];
} else {
    $action = 'default';
}

?>
]]>
     </programlisting>
    </example>
    Выражение <literal>(expr1) ?? (expr2)</literal> вычисляется так:
    <replaceable>expr2</replaceable>, если <replaceable>expr1</replaceable> равен
    &null; и <replaceable>expr1</replaceable> в противном случае.
   </para>
   <para>
    На практике, этот оператор не вызывает предупреждения или ошибки, если левый операнд не
    существует, как и <function>isset</function>. Это очень полезно для ключей массива.
   </para>
   <note>
    <simpara>
     Пожалуйста помните, что этот оператор является выражением, и он приравнивается к
     выражению, а не значению переменной. Это может быть важным, если вы хотите
     вернуть значение по ссылке. Выражение <literal>return $foo ?? $bar;</literal> в
     функции возвращающей ссылку будет не работать, а выводить предупреждение.
    </simpara>
   </note>
   <note>
    <para>
     Обратите внимание, что этот оператор позволяет использовать простую вложенность:
     <example>
      <title>Вложенный оператор null coalescing</title>
      <programlisting role="php">
<![CDATA[
<?php

$foo = null;
$bar = null;
$baz = 1;
$qux = 2;

echo $foo ?? $bar ?? $baz ?? $qux; // выведет 1

?>
]]>
      </programlisting>
     </example>
    </para>
   </note>
  </sect2>
 </sect1>

 <sect1 xml:id="language.operators.errorcontrol">
  <title>Оператор управления ошибками</title>
  <simpara>
   PHP поддерживает один оператор управления ошибками: знак <literal>@</literal>.
   В случае, если он предшествует какому-либо выражению в PHP-коде, любые
   сообщения об ошибках, генерируемые этим выражением, будут подавлены.
  </simpara>
  <para>
   Если пользовательская функция обработчика ошибок установлена с помощью
   <function>set_error_handler</function>, она всё равно будет вызываться,
   даже если диагностика была подавлена, поэтому пользовательский обработчик ошибок
   должен вызвать <function>error_reporting</function> и убедиться,
   что оператор <literal>@</literal> использовался следующим образом:

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function my_error_handler($err_no, $err_msg, $filename, $linenum) {
    if (!(error_reporting() & $err_no)) {
        return false; // Ошибка проигнорирована
    }
    // ...
}
?>
]]>
    </programlisting>
   </informalexample>
  </para>

  <warning>
   <para>
    До PHP 8.0.0 значение серьёзности, передаваемое пользовательскому
    обработчику ошибок, всегда было <literal>0</literal>, если диагностика подавлялась.
    Начиная с PHP 8.0.0, это больше не так.
   </para>
  </warning>

  <simpara>
   Любое сообщение об ошибке, сгенерированное выражением, доступно
   в элементе массива <literal>"message"</literal>, возвращаемого <function>error_get_last</function>.
   Результат этой функции будет меняться при каждой ошибке, поэтому его необходимо проверить заранее.
  </simpara>
  <para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// Преднамеренная ошибка при работе с файлами
$my_file = @file ('non_existent_file') or
    die ("Ошибка при открытии файла: сообщение об ошибке было таким: '" . error_get_last()['message'] . "'");

// работает для любых выражений, а не только для функций
$value = @$cache[$key];
// В случае если ключа $key нет, сообщение об ошибке (notice) не будет отображено

?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <note>
   <simpara>
    Оператор <literal>@</literal> работает только с
    <link linkend="language.expressions">выражениями</link>.
    Есть простое правило: если что-то возвращает
    значение, значит вы можете использовать перед ним оператор
    <literal>@</literal>. Например, вы можете использовать <literal>@</literal> перед
    именем переменной, произвольной функцией или вызовом <function>include</function> и так далее. В то же время вы не можете использовать этот оператор
    перед определением функции или класса, условными конструкциями, такими как  <literal>if</literal>,
    &foreach; и т.д.
   </simpara>
  </note>
  <warning>
   <para>
    До PHP 8.0.0 оператор <literal>@</literal> мог подавлять критические ошибки, которые прерывали выполнение скрипта.
    Например, добавление <literal>@</literal> к вызову несуществующей функции,
    в случае, если она недоступна или написана неправильно, дальнейшая
    работа скрипта приведёт к прерыванию выполнения скрипта без каких-либо уведомлений.
   </para>
  </warning>

  <sect2 role="seealso">
   &reftitle.seealso;
   <para>
    <simplelist>
     <member><function>error_reporting</function></member>
     <member><link linkend="ref.errorfunc">Обработка ошибок и функции логирования</link></member>
    </simplelist>
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="language.operators.execution">
  <title>Операторы исполнения</title>
  <para>
   PHP поддерживает один оператор исполнения: обратные кавычки (``). Обратите
   внимание, что это не одинарные кавычки! PHP попытается выполнить строку,
   заключённую в обратные кавычки, как консольную команду, и вернёт
   полученный вывод (то есть он не просто выводится на экран, а, например, может
   быть присвоен переменной). Использование обратных кавычек аналогично
   использованию функции <function>shell_exec</function>.
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <note>
   <para>
    Обратные кавычки недоступны, в случае, если
    отключена функция <function>shell_exec</function>.
   </para>
  </note>
  <note>
   <para>
    В отличие от некоторых других языков, обратные кавычки не
    будут работать внутри строк в двойных кавычках.
   </para>
  </note>

  <sect2 role="seealso">
   &reftitle.seealso;
   <para>
    <simplelist>
     <member><link linkend="ref.exec">Функции для выполнения программ</link></member>
     <member><function>popen</function></member>
     <member><function>proc_open</function></member>
     <member><link linkend="features.commandline">Использование PHP в командной строке</link></member>
    </simplelist>
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="language.operators.increment">
  <title>Операторы инкремента и декремента</title>
  <para>
   PHP поддерживает префиксные и постфиксные операторы инкремента и декремента
   в стиле C.
  </para>
  <note>
   <simpara>
    Операторы инкремента/декремента влияют только на числа и строки.
    Массивы, объекты, булевы значения и ресурсы не будут изменены.
    Декремент &null; также не даст никакого эффекта, однако инкремент
    даст значение <literal>1</literal>.
   </simpara>
  </note>
  <table>
   <title>Операторы инкремента и декремента</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Пример</entry>
      <entry>Название</entry>
      <entry>Действие</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>++$a</entry>
      <entry>Префиксный инкремент</entry>
      <entry>Увеличивает <varname>$a</varname> на единицу, затем возвращает значение <varname>$a</varname>.</entry>
     </row>
     <row>
      <entry>$a++</entry>
      <entry>Постфиксный инкремент</entry>
      <entry>Возвращает значение <varname>$a</varname>, затем увеличивает <varname>$a</varname> на единицу.</entry>
     </row>
     <row>
      <entry>--$a</entry>
      <entry>Префиксный декремент</entry>
      <entry>Уменьшает <varname>$a</varname> на единицу, затем возвращает значение <varname>$a</varname>.</entry>
     </row>
     <row>
      <entry>$a--</entry>
      <entry>Постфиксный декремент</entry>
      <entry>Возвращает значение <varname>$a</varname>, затем уменьшает <varname>$a</varname> на единицу.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   Приведём пример простого скрипта:
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo "<h3>Постфиксный инкремент</h3>";
$a = 5;
echo "Должно быть 5: " . $a++ . "<br />\n";
echo "Должно быть 6: " . $a . "<br />\n";

echo "<h3>Префиксный инкремент</h3>";
$a = 5;
echo "Должно быть 6: " . ++$a . "<br />\n";
echo "Должно быть 6: " . $a . "<br />\n";

echo "<h3>Постфиксный декремент</h3>";
$a = 5;
echo "Должно быть 5: " . $a-- . "<br />\n";
echo "Должно быть 4: " . $a . "<br />\n";

echo "<h3>Префиксный декремент</h3>";
$a = 5;
echo "Должно быть 4: " . --$a . "<br />\n";
echo "Должно быть 4: " . $a . "<br />\n";
?>
]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   PHP следует соглашениям Perl (в отличие от С) касательно выполнения
   арифметических операций с символьными переменными. Например, в PHP и Perl
   <literal>$a = 'Z'; $a++;</literal> присвоит <literal>$a</literal>
   значение <literal>'AA'</literal>, в то время как в C
   <literal>a = 'Z'; a++;</literal> присвоит <literal>a</literal>
   значение <literal>'['</literal> (ASCII-значение
   <literal>'Z'</literal> равно 90, а ASCII-значение
   <literal>'['</literal> равно 91). Следует учесть, что к
   символьным переменным можно применять операцию инкремента,
   в то время как операцию декремента применять нельзя, кроме того,
   поддерживаются только ASCII-символы (a-z и A-Z).
   Попытка инкремента/декремента других символьных переменных не
   будет иметь никакого эффекта, исходная строка останется
   неизменной.
   <example>
    <title>Арифметические операции с символьными переменными</title>
    <programlisting role="php">
<![CDATA[
<?php
echo '== Буквы ==' . PHP_EOL;
$s = 'W';
for ($n=0; $n<6; $n++) {
    echo ++$s . PHP_EOL;
}
// С цифрами несколько по другому
echo '== Цифры ==' . PHP_EOL;
$d = 'A8';
for ($n=0; $n<6; $n++) {
    echo ++$d . PHP_EOL;
}
$d = 'A08';
for ($n=0; $n<6; $n++) {
    echo ++$d . PHP_EOL;
}
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
== Буквы ==
X
Y
Z
AA
AB
AC
== Цифры ==
A9
B0
B1
B2
B3
B4
A09
A10
A11
A12
A13
A14
]]>
    </screen>
   </example>
  </para>
  <para>
   Инкрементирование или декрементирование булевых переменных не приводит ни к какому результату.
  </para>
 </sect1>

 <sect1 xml:id="language.operators.logical">
  <title>Логические операторы</title>

  <table>
   <title>Логические операторы</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Пример</entry>
      <entry>Название</entry>
      <entry>Результат</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>$a and $b</entry>
      <entry>И</entry>
      <entry>&true;, если и <varname>$a</varname>, и <varname>$b</varname> &true;.</entry>
     </row>
     <row>
      <entry>$a or $b</entry>
      <entry>Или</entry>
      <entry>&true;, если или <varname>$a</varname>, или <varname>$b</varname> &true;.</entry>
     </row>
     <row>
      <entry>$a xor $b</entry>
      <entry>Исключающее или</entry>
      <entry>&true;, если <varname>$a</varname>, или <varname>$b</varname> &true;, но не оба.</entry>
     </row>
     <row>
      <entry>! $a</entry>
      <entry>Отрицание</entry>
      <entry>&true;, если <varname>$a</varname> не &true;.</entry>
     </row>
     <row>
      <entry>$a &amp;&amp; $b</entry>
      <entry>И</entry>
      <entry>&true;, если и <varname>$a</varname>, и <varname>$b</varname> &true;.</entry>
     </row>
     <row>
      <entry>$a || $b</entry>
      <entry>Или</entry>
      <entry>&true;, если или <varname>$a</varname>, или <varname>$b</varname> &true;.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <simpara>
   Смысл двух разных вариантов для операторов "and" и "or" в том, что
   они работают с различными приоритетами (смотрите таблицу
   <link linkend="language.operators.precedence">Приоритет выполнения операторов</link>).
  </simpara>
  <example>
   <title>Объяснение логических операторов</title>
   <programlisting role="php">
<![CDATA[
<?php

// --------------------
// foo() никогда не будет вызвана, т.к. эти операторы являются шунтирующими (short-circuit)

$a = (false && foo());
$b = (true  || foo());
$c = (false and foo());
$d = (true  or  foo());

// --------------------
// "||" имеет больший приоритет, чем "or"

// Результат выражения (false || true) присваивается переменной $e
// Действует как: ($e = (false || true))
$e = false || true;

// Константа false присваивается $f, а затем значение true игнорируется
// Действует как: (($f = false) or true)
$f = false or true;

var_dump($e, $f);

// --------------------
// "&&" имеет больший приоритет, чем "and"

// Результат выражения (true && false) присваивается переменной $g
// Действует как: ($g = (true && false))
$g = true && false;

// Константа true присваивается $h, а затем значение false игнорируется
// Действует как: (($h = true) and false)
$h = true and false;

var_dump($g, $h);
?>
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
bool(true)
bool(false)
bool(false)
bool(true)
]]>
   </screen>
  </example>
 </sect1>

 <sect1 xml:id="language.operators.string">
  <title>Строковые операторы</title>
  <simpara>
   В PHP есть два оператора для работы со строками (<type>string</type>).
   Первый - оператор конкатенации ('.'), который возвращает строку, представляющую
   собой соединение левого и правого аргумента. Второй - оператор присваивания с
   конкатенацией ('<literal>.=</literal>'), который присоединяет правый аргумент к левому.
   Для получения более полной информации ознакомьтесь с разделом
   <link linkend="language.operators.assignment">Операторы присваивания</link>.
  </simpara>

  <para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = "Привет, ";
$b = $a . "Мир!"; // $b теперь содержит строку "Привет, Мир!"

$a = "Привет, ";
$a .= "Мир!";     // $a теперь содержит строку "Привет, Мир!"
?>
]]>
    </programlisting>
   </informalexample>
  </para>

  <sect2 role="seealso">
   &reftitle.seealso;
   <para>
    <simplelist>
     <member><link linkend="language.types.string">Строки</link></member>
     <member><link linkend="ref.strings">Функции для работы со строками</link></member>
    </simplelist>
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="language.operators.array">
  <title>Операторы, работающие с массивами</title>
  <table>
   <title>Операторы, работающие с массивами</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>Пример</entry>
      <entry>Название</entry>
      <entry>Результат</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>$a + $b</entry>
      <entry>Объединение</entry>
      <entry>Объединение массива <varname>$a</varname> и массива <varname>$b</varname>.</entry>
     </row>
     <row>
      <entry>$a == $b</entry>
      <entry>Равно</entry>
      <entry>&true; в случае, если <varname>$a</varname> и <varname>$b</varname> содержат одни и те же пары ключ/значение.</entry>
     </row>
     <row>
      <entry>$a === $b</entry>
      <entry>Тождественно равно</entry>
      <entry>&true; в случае, если <varname>$a</varname> и <varname>$b</varname>
       содержат одни и те же пары ключ/значение в том же самом порядке и того же типа.
      </entry>
     </row>
     <row>
      <entry>$a != $b</entry>
      <entry>Не равно</entry>
      <entry>&true;, если массив <varname>$a</varname> не равен массиву <varname>$b</varname>.</entry>
     </row>
     <row>
      <entry>$a &lt;&gt; $b</entry>
      <entry>Не равно</entry>
      <entry>&true;, если массив <varname>$a</varname> не равен массиву <varname>$b</varname>.</entry>
     </row>
     <row>
      <entry>$a !== $b</entry>
      <entry>Тождественно не равно</entry>
      <entry>&true;, если массив <varname>$a</varname> не равен тождественно массиву <varname>$b</varname>.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   Оператор <literal>+</literal> возвращает левый массив, к которому
   был присоединён правый массив. Для ключей, которые существуют в
   обоих массивах, будут использованы значения из левого массива, а
   соответствующие им элементы из правого массива будут проигнорированы.
  </para>
  <para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "apple", "b" => "banana");
$b = array("a" => "pear", "b" => "strawberry", "c" => "cherry");

$c = $a + $b; // Объединение $a и $b
echo "Объединение \$a и \$b: \n";
var_dump($c);

$c = $b + $a; // Объединение $b и $a
echo "Объединение \$b и \$a: \n";
var_dump($c);

$a += $b; // Объединение $a += $b, это $a и $b
echo "Объединение \$a += \$b: \n";
var_dump($a);
?>
]]>
    </programlisting>
   </informalexample>
   После своего выполнения скрипт напечатает следующее:
   <screen role="php">
<![CDATA[
Объединение $a и $b:
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}
Объединение $b и $a:
array(3) {
  ["a"]=>
  string(4) "pear"
  ["b"]=>
  string(10) "strawberry"
  ["c"]=>
  string(6) "cherry"
}

Объединение $a += $b:
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}
]]>
   </screen>
  </para>
  <para>
   При сравнении элементы массива считаются идентичными, если совпадает
   и ключ, и соответствующее ему значение.
  </para>
  <para>
   <example>
    <title>Сравнение массивов</title>
    <programlisting role="php">
<![CDATA[
<?php
$a = array("apple", "banana");
$b = array(1 => "banana", "0" => "apple");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
    </programlisting>
   </example>
  </para>

  <sect2 role="seealso">
   &reftitle.seealso;
   <para>
    <simplelist>
     <member><link linkend="language.types.array">Массивы</link></member>
     <member><link linkend="ref.array">Функции для работы с массивами</link></member>
    </simplelist>
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="language.operators.type">
  <title>Оператор проверки типа</title>
  <para>
   Оператор <literal>instanceof</literal> используется для определения того,
   является ли текущий объект экземпляром указанного
   <link linkend="language.oop5.basic.class">класса</link>.
   <example>
    <title>Использование <literal>instanceof</literal> с классами</title>
    <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

class NotMyClass
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof NotMyClass);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(false)
]]>
    </screen>
   </example>
  </para>
  <para>
   Оператор <literal>instanceof</literal> также может быть использован
   для определения, наследует ли определённый объект какой-либо класс:
   <example>
    <title>Использование <literal>instanceof</literal> с наследуемыми классами</title>
    <programlisting role="php">
<![CDATA[
<?php
class ParentClass
{
}

class MyClass extends ParentClass
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof ParentClass);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
]]>
    </screen>
   </example>
  </para>
  <para>
   Для проверки <emphasis>непринадлежности</emphasis> объекта некоторому классу,
   используйте <link linkend="language.operators.logical">логический оператор
   <literal>not</literal></link>.
   <example>
    <title>Использование <literal>instanceof</literal> для проверки того, что объект
     <emphasis>не</emphasis> является экземпляром класса</title>
    <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

$a = new MyClass;
var_dump(!($a instanceof stdClass));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
]]>
    </screen>
   </example>
  </para>
  <para>
   Наконец, <literal>instanceof</literal> может быть также использован для проверки
   реализации объектом некоторого <link
   linkend="language.oop5.interfaces">интерфейса</link>:
   <example>
    <title>Использование <literal>instanceof</literal> с интерфейсами</title>
    <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof MyInterface);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
]]>
    </screen>
   </example>
  </para>
  <para>
   Хотя <literal>instanceof</literal> обычно используется с прямо указанным именем класса,
   он также может быть использован с другим объектом или строковой переменной:
   <example>
    <title>Использование <literal>instanceof</literal> с другими переменными</title>
    <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;
$b = new MyClass;
$c = 'MyClass';
$d = 'NotMyClass';

var_dump($a instanceof $b); // $b - объект класса MyClass
var_dump($a instanceof $c); // $c - строка 'MyClass'
var_dump($a instanceof $d); // $d - строка 'NotMyClass'
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
bool(false)
]]>
    </screen>
   </example>
  </para>
  <para>
   Оператор instanceof не генерирует никаких ошибок, если проверяемая переменная не
   является объектом. В этом случае он просто возвращает &false;. Константы, тем не менее,
   не допускались до PHP 7.3.0.
   <example>
    <title>Пример использования оператора <literal>instanceof</literal> для проверки других переменных</title>
    <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = NULL;
$c = imagecreate(5, 5);
var_dump($a instanceof stdClass); // $a - целое типа integer
var_dump($b instanceof stdClass); // $b - NULL
var_dump($c instanceof stdClass); // $c - значение типа resource
var_dump(FALSE instanceof stdClass);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(false)
bool(false)
bool(false)
PHP Fatal error:  instanceof expects an object instance, constant given
]]>
    </screen>
   </example>
  </para>
  <para>
   Начиная с PHP 7.3.0, константы разрешены в левой части оператора <literal>instanceof</literal>.
   <example>
    <title>Использование <literal>instanceof</literal> для проверки констант</title>
    <programlisting role="php">
<![CDATA[
<?php
var_dump(FALSE instanceof stdClass);
?>
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
bool(false)
]]>
    </screen>
   </example>
  </para>

  <simpara>
   Оператор <literal>instanceof</literal> аналогичен функции <function>is_a</function>.
  </simpara>

  <sect2 role="seealso">
   &reftitle.seealso;
   <para>
    <simplelist>
     <member><function>get_class</function></member>
     <member><function>is_a</function></member>
    </simplelist>
   </para>
  </sect2>
 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
