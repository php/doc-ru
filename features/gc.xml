<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: a5c69fdd7097fe331da0f5d26edb4b48b9c48ae0 Maintainer: shein Status: ready -->
<!-- Reviewed: yes -->
<!-- $Revision$ -->
 <chapter xml:id="features.gc" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Сборка мусора</title>

  <para>
   В этом разделе описываются достоинства нового механизма сборки мусора 
   (также называемого Garbage Collection или GC), являющегося частью PHP 5.3.
  </para>

  <sect1 xml:id="features.gc.refcounting-basics">
   <title>Основы подсчета ссылок</title>
   <para>
    Переменная PHP хранится в контейнере, называемом "zval". Контейнер zval,
    помимо типа и значения переменной, также содержит два дополнительных элемента. 
    Первый называется "is_ref" и представляет булевое значение, указывающее,
    является переменная частью "набора ссылок" или нет. Благодаря этому элементу PHP
    знает как отличать обычные переменные от ссылок. Так как PHP содержит
    пользовательские ссылки, которые можно создать оператором &amp;, контейнер zval
    также содержит внутренний механизм подсчета ссылок для оптимизации использования памяти.
    Эта вторая часть дополнительной информации, называемая "refcount" (счетчик ссылок), содержит
    количество имен переменных (также называемых символами), которые указывают на данный контейнер zval.
    Все имена переменных хранятся в таблице имен, отдельной для каждой
    области видимости переменных. Такая область видимости существует для главного скрипта,
    а также для каждой функции и метода.
   </para>
   <para>
    Контейнер zval создается при создании новой переменной, которой
    присваивается константа, например:
    <example>
     <title>Создание нового контейнера zval</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = "new string";
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    В данном примере создается новый символ <literal>a</literal> в текущей области видимости
    и новый контейнер переменной с типом <type>string</type> и значением <literal>new string</literal>.
    Бит "is_ref" по умолчанию задается равным &false;, т.к. не создано ни одной пользовательской
    ссылки. Значение же "refcount" задается равным <literal>1</literal>, т.к. только одно имя переменной 
    указывает на данный контейнер. Отметим, что если "refcount" равен <literal>1</literal>, то "is_ref"
    будет всегда равен &false;. Если у вас установлен <link xlink:href='&url.xdebug;'>Xdebug</link>, то
    вы можете вывести эту информацию, вызвав функцию <function>xdebug_debug_zval</function>.
   </para>
   <para>
    <example>
     <title>Вывод информации о zval</title>
     <programlisting role="php">
<![CDATA[
<?php
xdebug_debug_zval('a');
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
a: (refcount=1, is_ref=0)='new string'
]]>
     </screen>
    </example>
   </para>
   <para>
    Присвоение этой переменной другой увеличивает счетчик ссылок.
   </para>
   <para>
    <example>
     <title>Увеличение счетчика ссылок zval</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = "new string";
$b = $a;
xdebug_debug_zval( 'a' );
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
a: (refcount=2, is_ref=0)='new string'
]]>
     </screen>
    </example>
   </para>
   <para>
    Счетчик ссылок здесь равен <literal>2</literal>, т.к.
    <varname>a</varname> и <varname>b</varname> ссылаются на один
    и тот же контейнер переменной. PHP достаточно умен, чтобы
    не копировать контейнер, пока в этом нет необходимости. Как только
    "refcount" станет равным нулю, контейнер уничтожается.
    "refcount" уменьшается на единицу при уходе переменной
    из области видимости (например, в конце функции) или при
    вызове <function>unset</function> с данной переменной.
   </para>
   <para>
    <example>
     <title>Уменьшение счетчика ссылок zval</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = "new string";
$c = $b = $a;
xdebug_debug_zval( 'a' );
unset( $b, $c );
xdebug_debug_zval( 'a' );
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
a: (refcount=3, is_ref=0)='new string'
a: (refcount=1, is_ref=0)='new string'
]]>
     </screen>
    </example>
   </para>
   <para>
    Если мы сейчас вызовем <literal>unset($a);</literal>,
    то контейнер, включая тип и значение, будет удален из памяти.
   </para>

   <sect2 xml:id="features.gc.compound-types">
    <title>Составные типы данных</title>

    <para>
     Все несколько усложняется с составными типами данных, такими как массивы (<type>array</type>) и
     объекты (<type>object</type>). В отличии от скалярных (<type>scalar</type>) значений, массивы и объекты
     хранят свои свойства в собственных таблицах имен.
     Это значит, что следующий пример создаст сразу три zval контейнера:
    </para>
    <para>
     <example>
      <title>Создание <type>array</type> zval</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = array( 'meaning' => 'life', 'number' => 42 );
xdebug_debug_zval( 'a' );
?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
a: (refcount=1, is_ref=0)=array (
   'meaning' => (refcount=1, is_ref=0)='life',
   'number' => (refcount=1, is_ref=0)=42
)
]]>
      </screen>
      <para>Графически:</para>
      <mediaobject>
       <alt>Контейнеры для простого массива</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/simple-array.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
    <para>
     Результат - три контейнера: <varname>a</varname>, <varname>meaning</varname> и <varname>number</varname>.
     Похожие правила применяются и для увеличения и уменьшения "refcounts".
     Ниже мы добавляем еще один элемент массива и устанавливаем ему значение уже существующего элемента:
    </para>
    <para>
     <example>
      <title>Добавление уже существующего элемента в массив</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = array( 'meaning' => 'life', 'number' => 42 );
$a['life'] = $a['meaning'];
xdebug_debug_zval( 'a' );
?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
a: (refcount=1, is_ref=0)=array (
   'meaning' => (refcount=2, is_ref=0)='life',
   'number' => (refcount=1, is_ref=0)=42,
   'life' => (refcount=2, is_ref=0)='life'
)
]]>
      </screen>
      <para>Графически:</para>
      <mediaobject>
       <alt>Контейнеры для простого массива со ссылками</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/simple-array2.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
    <para>
     Вышеприведенный вывод Xdebug показывает, что и старый и новый элементы массива
     сейчас указывают на контейнер, чей "refcount" равен <literal>2</literal>.
     Хотя показано два контейнера со значением <literal>'life'</literal>, на самом 
     деле это один контейнер. Функция <function>xdebug_debug_zval</function> не выводит информации об этом,
     но вы можете проверить это также отобразив указатели памяти.
    </para>
    <para>
     Удаление элемента из массива происходит точно так же, как и удаление имени переменной
     из области видимости: уменьшается "refcount" контейнера, на который ссылается элемент массива.
     Опять же, при достижении "refcount" нуля, контейнер удаляется из памяти.
     Пример:
    </para>
    <para>
     <example>
      <title>Удаление элемента из массива</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = array( 'meaning' => 'life', 'number' => 42 );
$a['life'] = $a['meaning'];
unset( $a['meaning'], $a['number'] );
xdebug_debug_zval( 'a' );
?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
a: (refcount=1, is_ref=0)=array (
   'life' => (refcount=1, is_ref=0)='life'
)
]]>
      </screen>
     </example>
    </para>
    <para>
     Ситуация станет интереснее, если добавить массив новым элементом в самого себя.
     В следующем примере мы также используем оператор присваивания по ссылке, чтобы
     PHP не создал копию массива.
    </para>
    <para>
     <example>
      <title>Добавление массива новым элементом в самого себя</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = array( 'one' );
$a[] =& $a;
xdebug_debug_zval( 'a' );
?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
a: (refcount=2, is_ref=1)=array (
   0 => (refcount=1, is_ref=0)='one',
   1 => (refcount=2, is_ref=1)=...
)
]]>
      </screen>
      <para>Графически:</para>
      <mediaobject>
       <alt>Контейнеры массива с циклическими ссылками</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/loop-array.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
    <para>
     Можно увидеть, что переменная с массивом (<varname>a</varname>), так же как и второй элемент
     (<varname>1</varname>) сейчас указывают на контейнер с "refcount" равным <literal>2</literal>.
     Символы "..." в выводе означают рекурсию и, в нашем случае,
     указывают на оригинальный массив.
    </para>
    <para>
     Как и ранее, удаление переменной уменьшает счетчик ссылок контейнера на единицу.
     Если мы применим unset к переменной <varname>$a</varname> после вышеприведенного примера,
     то счетчик ссылок контейнера, на который указывают <varname>$a</varname> и элемент "1",
     изменится с "2" на "1":
    </para>
    <para>
     <example>
      <title>Удаление <varname>$a</varname></title>
      <screen>
<![CDATA[
(refcount=1, is_ref=1)=array (
   0 => (refcount=1, is_ref=0)='one',
   1 => (refcount=1, is_ref=1)=...
)
]]>
      </screen>
      <para>Графически:</para>
      <mediaobject>
       <alt>Контейнеры после удаления массива с циклическими ссылками, демонстрирующие утечку памяти</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/leak-array.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
   </sect2>

   <sect2 xml:id="features.gc.cleanup-problems">
    <title>Суть проблемы</title>
    <para>
     Хотя во всех областях видимости больше нет имени переменной, ссылающейся на
     данную структуру, она не может быть очищена, т.к. элемент массива "1" по-прежнему
     ссылается на этот массив. Т.к. теперь нет никакой возможности пользователю
     удалить эти данные, то мы получили утечку памяти.
     К счастью, PHP удалит эти данные при завершении запроса, но до этого момента 
     данные будут занимать ценное место в памяти. Такая ситуация часто бывает, когда
     реализуются алгоритмы парсинга или другие, где есть дочерние элементы, 
     ссылающиеся на родительские. Еще чаще такая ситуация случается с объектами, 
     потому что они всегда неявно используются по ссылке.
    </para>
    <para>
     Эта не проблема, если такое случается раз или два, но если
     существуют тысячи или даже миллионы таких утечек памяти, то они уже становятся
     проблемой. Особенно в долгоработающих скриптах, таких как демоны, где запрос 
     не заканчивается никогда, или в больших наборах модульных тестов.
     Последний случай вызвал проблемы при запуске модульных тестов для
     компонента Template из библиотеки ez Components. В некоторых
     случаях может потребоваться свыше 2 Гб памяти, которая не всегда
     есть на тестовом сервере.
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="features.gc.collecting-cycles">
   <title>Сбор циклических ссылок</title>
   <para>
    Обычно механизмы подсчета ссылок в памяти, например, используемый в PHP ранее,
    не решают проблему утечки памяти из-за циклических ссылок.
    Начиная с версии 5.3.0, в PHP реализован синхронный механизм из исследования
    "<link xlink:href='&url.gc-paper;'>Concurrent Cycle Collection in Reference Counted Systems</link>",
    в котором рассматривается этот вопрос.
   </para>
   <para>
    Полное описание работы алгоритма выходит за рамки данного раздела, поэтому 
    приведены только основы. Прежде всего мы должны задать несколько основных правил.
    Если счетчик ссылок увеличивается, то контейнер все еще используется и не является мусором.
    Если счетчик уменьшается до нуля, то zval может быть удален.
    Исходя из этих правил утечки памяти с циклическими ссылками могут получиться только
    при уменьшении счетчика ссылок до ненулевого значения.
    Затем, в выделенных контейнерах можно найти мусор проверив возможность уменьшения
    всех счетчиков ссылок на единицу и определив те контейнеры, у которых счетчик станет равным нулю.
   </para>
   <para>
     <mediaobject>
      <alt>Алгоритм сборки мусора</alt>
      <imageobject>
       <imagedata fileref="en/features/figures/gc-algorithm.png" format="PNG"/>
      </imageobject>
     </mediaobject>
   </para>
   <para>
    Для избежания постоянной проверки на мусор с циклическими ссылками при каждом уменьшении счетчика ссылок,
    алгоритм добавляет все возможные корни (zval контейнеры) в "корневой буфер" (помечая
    их как "фиолетовые"). Это также гарантирует попадание любого корня в буфер только один раз.
    Механизм сборки мусора стартует только тогда, когда наполняется буфер (см. шаг A
    на рисунке выше).
   </para>
   <para>
    На шаге B алгоритм производит поиск в глубину по всем возможным корням для
    однократного уменьшения счетчика ссылок на единицу у всех контейнеров
    (помечая их как "серые"). На шаге C алгоритм снова производит поиск в глубину
    для проверки счетчиков ссылок. Если он находит счетчик с нулевым значением, то
    контейнер помечается как "белый" (на рисунке отображено синим). Если же счетчик больше нуля, то
    происходит поиск в глубину от этого контейнера с обратным увеличением счетчиков на единицу
    и повторной пометкой как "черный" на их контейнерах. На последнем шаге D алгоритм проходит по
    корневому буферу и удаляет из него корни контейнеров, заодно проверяя какие контейнеры 
    помечены как "белые". Эти контейнеры будут освобождены из памяти.
   </para>
   <para>
    Теперь, когда вы имеете представление о работе алгоритма, рассмотрим его
    интеграцию в PHP. По умолчанию сборщик мусора всегда включен.
    Для изменения этой опции используется параметр <option>zend.enable_gc</option>
    в &php.ini;.
   </para>
   <para>
    Если сборщик мусора включен, алгоритм поиска циклических ссылок выполняется каждый раз,
    когда корневой буфер наполняется 10,000 корнями (вы можете поменять это значение,
    изменив константу <literal>GC_ROOT_BUFFER_MAX_ENTRIES</literal> в файле
    <literal>Zend/zend_gc.c</literal> в исходном коде PHP и пересобрав PHP).
    Если сборщик мусора выключен, алгоритм никогда не будет запущен. Тем не менее,
    буфер всегда заполняется корнями.
   </para>
   <para>
    Если буфер заполнился при выключенном механизме сборки мусора, то
    другие корни не будут в него записаны. Таким образом, если они окажутся
    мусором с циклическими ссылками, то никогда не будут очищены и создадут утечку памяти.
   </para>
   <para>
    Причиной постоянной записи корней в буфер даже при выключенном
    механизме сборки мусора является то, что это намного быстрее,
    чем постоянно проверять включен ли механизм сборки мусора или нет.
    Однако, сама сборка мусора и алгоритм ее анализа могут занимать значительное
    время.
   </para>
   <para>
    Помимо изменения параметра <option>zend.enable_gc</option>, механизм сборки мусора
    также можно запустить и остановить вызвав функции <function>gc_enable</function> и
    <function>gc_disable</function> соответственно. Вызов этих функций
    имеет тот же эффект, что и включение/выключение механизма с
    помощью настроек конфигурации.
    Кроме того, можно запустить сборку мусора, даже если корневой буфер еще не заполнен.
    Для этого вы можете вызвать функцию <function>gc_collect_cycles</function>, которая
    также возвращает количество циклических ссылок собранных алгоритмом.
   </para>
   <para>
    Причиной включения и выключения механизма сборки, а также его ручного запуска,
    может стать то, что некоторые части вашего приложения могут быть требовательными
    ко времени. В этих случаях вы, возможно, не захотите постороннего вмешательства
    сборщика мусора. Разумеется, выключая сборщик мусора в определенных
    местах вашего приложения вы рискуете получить утечку памяти, т.к.
    потенциально некоторые корни могут не поместиться в ограниченный
    корневой буфер. Более целесообразно будет вызвать <function>gc_collect_cycles</function>
    непосредственно перед вызовом <function>gc_disable</function> для освобождения памяти и уже
    записанных корней в буфере. Это очистит буфер и позволит использовать больше места
    для хранения корней, пока механизм будет выключен.
   </para>
  </sect1>

  <sect1 xml:id="features.gc.performance-considerations">
   <title>Вопросы производительности</title>
   <para>
    В предыдущем разделе нами уже говорилось, что простой сбор корней меньше
    влияет на производительность.
    Хотя запись корней в буфер по сравнению с полным отсутствием
    таковой в PHP 5.2 работает медленней, другие изменения в работе
    PHP 5.3 сделали эту потерю производительности незаметной.
   </para>
   <para>
    Есть две основные области влияющие на производительность:
    уменьшение размера используемой памяти и замедление работы при
    сборке мусора. Рассмотрим их.
   </para>

   <sect2 xml:id="features.gc.performance-considerations.reduced-mem">
    <title>Уменьшение размера используемой памяти</title>
    <para>
     Прежде всего, основной причиной реализации механизма сборки
     мусора является уменьшение размера используемой памяти с помощью
     чистки циклических ссылок, которая происходит при достижении
     соответствующих условий. В реализации PHP это происходит как
     только заполнится корневной буфер или при вызове функции
     <function>gc_collect_cycles</function>.
     На графике ниже приведено использование памяти скрипта,
     запущенного в PHP 5.2 и PHP 5.3, без учета памяти,
     используемой самим PHP при запуске.
    </para>
    <para>
     <example>
      <title>Пример использования памяти</title>
      <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    public $var = '3.1415962654';
}

$baseMemory = memory_get_usage();

for ( $i = 0; $i <= 100000; $i++ )
{
    $a = new Foo;
    $a->self = $a;
    if ( $i % 500 === 0 )
    {
        echo sprintf( '%8d: ', $i ), memory_get_usage() - $baseMemory, "\n";
    }
}
?>
]]>
      </programlisting>
      <mediaobject>
       <alt>Сравнение использования памяти в PHP 5.2 и PHP 5.3</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/gc-benchmark.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
    <para>
     В этом очень академическом примере мы создаем объект, свойство a которого
     задается ссылкой на сам объект. Когда в скрипте в следующей итерации цикла переопределяется
     переменная <varname>$a</varname>, то происходит типичная утечка памяти.
     В данном случае пропадают два контейнера zval (контейнер объекта и контейнер свойства объекта), 
     но определяется только один корень - удаленная переменная.
     Как только пройдут 10 000 итераций (максимально в корневом буфере
     будет 10 000 корней), то запустится механизм сборки мусора и
     память, занимаемая этими корнями, будет освобождена.
     Этот процесс хорошо виден на графике использования памяти для PHP 5.3:
     после каждых 10 000 итераций график проседает.
     Сам по себе механизм в данном примере совершает не так много работы, потому что
     структура утечек слишком проста. Из графика видно, что максимальное использование памяти
     в PHP 5.3 составило около 9 Мб, тогда как в PHP 5.2 оно продолжает возрастать.
    </para>
   </sect2>

   <sect2 xml:id="features.gc.performance-considerations.slowdowns">
    <title>Замедление работы</title>
    <para>
     Второй областью, где сборка мусора влияет на производительность,
     является потеря времени, когда сборщик мусора освобождает память.
     Чтобы понять степень этого влияния, мы немного изменим предыдущий скрипт,
     добавив большее число итераций и промежуточных переменных.
     Измененный скрипт:
    </para>
    <para>
     <example>
      <title>Влияние на производительность</title>
      <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    public $var = '3.1415962654';
}

for ( $i = 0; $i <= 1000000; $i++ )
{
    $a = new Foo;
    $a->self = $a;
}

echo memory_get_peak_usage(), "\n";
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Мы запустим скрипт два раза: с включенной опцией <option>zend.enable_gc</option>
     и без нее.
    </para>
    <para>
     <example>
      <title>Запуск скрипта</title>
      <programlisting role="shell">
<![CDATA[
time php -dzend.enable_gc=0 -dmemory_limit=-1 -n example2.php
# and
time php -dzend.enable_gc=1 -dmemory_limit=-1 -n example2.php
]]>
      </programlisting>
     </example>
    </para>
    <para>
     На тестовой машине первая команда примерно выполняется 10.7 секунд, а 
     вторая примерно 11.4 секунды. Это примерно на 7% медленнее. Однако,
     максимальное использование памяти скриптом уменьшилось на 98% с 931 Мб до 10 Мб.
     Этот тест не очень научный, но он действительно демонстрирует преимущество 
     по использованию памяти, обеспечиваемое сборщиком мусора. Также хорошо то, что
     замедление для этого скрипта всегда примерно 7%, тогда как экономия памяти
     увеличивается все больше и больше при нахождении нового мусора.
    </para>
   </sect2>

   <sect2 xml:id="features.gc.performance-considerations.internal-stats">
    <title>Внутренняя статистика сборщика мусора</title>
    <para>
     Можно получить немного больше информации о том, как механизм сборки
     мусора выполняется в PHP. Но для этого вам необходимо пересобрать PHP
     для включения теста производительности и кода для дополнительного сбора данных. Необходимо
     установить переменную окружения <literal>CFLAGS</literal> в значение
     <literal>-DGC_BENCH=1</literal> до выполнения команды <literal>./configure</literal>
     с вашими параметрами. Следующие команды должны сработать:
    </para>
    <para>
     <example>
      <title>Сборка PHP для включения теста производительности GC</title>
      <programlisting role="shell">
<![CDATA[
export CFLAGS=-DGC_BENCH=1
./config.nice
make clean
make
]]>
      </programlisting>
     </example>
    </para>
    <para>
     При запуске вышеприведенного примера с обновленным PHP, можно
     увидеть следующую информацию по завершении работы скрипта:
    </para>
    <para>
     <example>
      <title>Статистика GC</title>
      <programlisting role="shell">
<![CDATA[
GC Statistics
-------------
Runs:               110
Collected:          2072204
Root buffer length: 0
Root buffer peak:   10000

      Possible            Remove from  Marked
        Root    Buffered     buffer     grey
      --------  --------  -----------  ------
ZVAL   7175487   1491291    1241690   3611871
ZOBJ  28506264   1527980     677581   1025731
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Наиболее полезная статистика отображена в первом блоке. Можно увидеть,
     что механизм сборки мусора был запущен 110 раз, и суммарно было освобождено
     свыше 2 миллионов записей в памяти. Если сборка мусора была запущена хотя бы раз, то
     максимальное число корней в буфере всегда будет равно 10 000.
    </para>
   </sect2>

   <sect2 xml:id="features.gc.performance-considerations.conclusion">
    <title>Заключение</title>
    <para>
     В целом, сборщик мусора в PHP вызовет ощутимые замедления только во
     время непосредственной работы механизма сборки циклических ссылок, тогда как
     в обычных (небольших) скриптах не должно быть никакого падения производительности.
    </para>
    <para>
     Однако в тех случаях, когда механизм сборки должен срабатывать
     и в обычных скриптах, снижение используемой памяти позволяет
     одновременно работать на сервере большему их количеству.
    </para>
    <para>
     Преимущества наиболее очевидны для долгоработающих скриптов, таких как
     большие наборы тестов или демоны. Новый механизм также должен снизить утечки памяти 
     для приложений <link xlink:href="&url.php.gtk;">PHP-GTK</link>, которые выполняются
     обычно дольше, чем веб-скрипты.
    </para>
   </sect2>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
