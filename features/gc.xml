<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 9957fc259b7b920269ead2a0180969db5bf13433 Maintainer: irker Status: ready -->
<!-- Reviewed: no -->
 <chapter xml:id="features.gc" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Сборка мусора</title>

  <para>
   Раздел описывает достоинства нового механизма сборки мусора
   (Garbage Collection, или GC), который появился в PHP 5.3.
  </para>

  <sect1 xml:id="features.gc.refcounting-basics">
   <title>Основы подсчёта ссылок</title>
   <para>
    Переменная PHP хранится в контейнере, который называется zval. Контейнер zval,
    кроме типа и значения переменной, также содержит два дополнительных бита информации.
    Первый называется is_ref и представляет логическое значение, которое указывает,
    включил ли PHP переменную в «набор ссылок» или нет. За счёт элемента is_ref PHP
    знает, как отличать обычные переменные от ссылок. Поскольку PHP разрешает
    пользовательские ссылки, которые можно создать оператором &amp;, контейнер zval
    также содержит внутренний механизм подсчёта ссылок для оптимизации работы памяти.
    Вторая часть дополнительной информации называется refcount (счётчик ссылок) и содержит
    количество имён переменных (или другое название — символов), которые указывают на этот контейнер zval.
    Каждый символ хранится в таблице символов. У каждой
    области видимости переменных своя таблица символов. Такая область видимости существует для главного скрипта,
    каждой функции и метода.
   </para>
   <para>
    Контейнер zval создаётся при объявлении новой переменной, которой
    присваивается константное значение, например:
    <example>
     <title>Создание нового контейнера zval</title>
     <programlisting role="php">
<![CDATA[
<?php

$a = "new string";

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    В примере создаётся новый символ <literal>a</literal> в текущей области видимости
    и новый контейнер переменной с типом <type>string</type> и значением <literal>new string</literal>.
    Бит is_ref по умолчанию задаётся равным &false;, т. к. не создали ни одной пользовательской
    ссылки. Значение же refcount задаётся равным <literal>1</literal>, поскольку только одно имя переменной
    указывает на этот контейнер. Обратите внимание, что ссылки (т. е. когда бит is_ref равен &true;) с битом refcount равным <literal>1</literal>
    обрабатываются так, как если бы они не были ссылками (то есть как если бы бит is_ref был равен &false;).
    Модуль <link xlink:href="&url.xdebug;">Xdebug</link>
    умеет выводить эту информацию через функцию <function>xdebug_debug_zval</function>.
   </para>
   <para>
    <example>
     <title>Вывод информации о zval</title>
     <programlisting role="php">
<![CDATA[
<?php

$a = "new string";
xdebug_debug_zval('a');

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
a: (refcount=1, is_ref=0)='new string'
]]>
     </screen>
    </example>
   </para>
   <para>
    Присваивание одной переменной другой переменной увеличивает счётчик ссылок.
   </para>
   <para>
    <example>
     <title>Увеличение счётчика ссылок контейнера zval</title>
     <programlisting role="php">
<![CDATA[
<?php

$a = "new string";
$b = $a;
xdebug_debug_zval( 'a' );

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
a: (refcount=2, is_ref=0)='new string'
]]>
     </screen>
    </example>
   </para>
   <para>
    Счётчик ссылок здесь равен <literal>2</literal>, поскольку символы
    <varname>a</varname> и <varname>b</varname> ссылаются на один
    и тот же контейнер переменной. PHP достаточно умён, чтобы
    не копировать контейнер, пока этого не требуется. Как только
    счётчик ссылок refcount станет равным нулю, контейнер уничтожается.
    Счётчик ссылок refcount уменьшается на единицу при выходе переменной
    из области видимости (например, в конце функции)
    или при удалении этой переменной (например, при вызове языковой конструкции <function>unset</function>).
   </para>
   <para>
    <example>
     <title>Уменьшение счётчика ссылок контейнера zval</title>
     <programlisting role="php">
<![CDATA[
<?php

$a = "new string";
$c = $b = $a;
xdebug_debug_zval('a');

$b = 42;
xdebug_debug_zval('a');

unset( $c );
xdebug_debug_zval('a');

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
a: (refcount=3, is_ref=0)='new string'
a: (refcount=2, is_ref=0)='new string'
a: (refcount=1, is_ref=0)='new string'
]]>
     </screen>
    </example>
   </para>
   <para>
    Если сейчас вызвать <literal>unset($a);</literal>,
    контейнер, включая тип и значение, удалится из памяти.
   </para>

   <sect2 xml:id="features.gc.compound-types">
    <title>Составные типы данных</title>

    <para>
     Всё несколько усложняется с составными типами данных наподобие массивов (<type>array</type>)
     и объектов (<type>object</type>). В отличие от скалярных (<type>scalar</type>) значений, массивы и объекты
     хранят свойства в своих таблицах имён.
     То есть следующий пример создаст сразу три zval-контейнера:
    </para>
    <para>
     <example>
      <title>Создание контейнера zval для массива (<type>array</type>)</title>
      <programlisting role="php">
<![CDATA[
<?php

$a = array('meaning' => 'life', 'number' => 42);
xdebug_debug_zval('a');

?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
a: (refcount=1, is_ref=0)=array (
   'meaning' => (refcount=1, is_ref=0)='life',
   'number' => (refcount=1, is_ref=0)=42
)
]]>
      </screen>
      <para>Графически:</para>
      <mediaobject>
       <alt>Контейнеры для простого массива</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/simple-array.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
    <para>
     Результат — три контейнера: <varname>a</varname>, <varname>meaning</varname> и <varname>number</varname>.
     Похожие правила применяются и для увеличения и уменьшения счётчика ссылок refcounts.
     Ниже в массив добавляется ещё один элемент со значением уже существующего элемента:
    </para>
    <para>
     <example>
      <title>Добавление уже существующего элемента в массив</title>
      <programlisting role="php">
<![CDATA[
<?php

$a = array('meaning' => 'life', 'number' => 42);
$a['life'] = $a['meaning'];
xdebug_debug_zval( 'a' );

?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
a: (refcount=1, is_ref=0)=array (
   'meaning' => (refcount=2, is_ref=0)='life',
   'number' => (refcount=1, is_ref=0)=42,
   'life' => (refcount=2, is_ref=0)='life'
)
]]>
      </screen>
      <para>Графически:</para>
      <mediaobject>
       <alt>Контейнеры для простого массива со ссылками</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/simple-array2.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
    <para>
     Из вывода модуля Xdebug видно, что и старый, и новый элементы массива
     сейчас указывают на контейнер, чей refcount равен <literal>2</literal>.
     Хотя вывод показывает два контейнера со значением <literal>'life'</literal>,
     но это один контейнер. Функция <function>xdebug_debug_zval</function> не выводит информациию об этом,
     но это проверяют за счёт отображения также указателей памяти.
    </para>
    <para>
     Элемент удаляется из массива аналогично удалению символа
     из области видимости: счётчик ссылок refcount того контейнера, на который ссылается элемент массива, уменьшается.
     Контейнер удаляется из памяти, когда значение в бите refcount достигает нуля.
     Пример:
    </para>
    <para>
     <example>
      <title>Удаление элемента из массива</title>
      <programlisting role="php">
<![CDATA[
<?php

$a = array('meaning' => 'life', 'number' => 42);
$a['life'] = $a['meaning'];
unset($a['meaning'], $a['number']);
xdebug_debug_zval( 'a' );

?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
a: (refcount=1, is_ref=0)=array (
   'life' => (refcount=1, is_ref=0)='life'
)
]]>
      </screen>
     </example>
    </para>
    <para>
     Ситуация станет интереснее, если добавить массив самого в себя.
     В следующем примере вводится оператор присваивания по ссылке, чтобы
     PHP не создал копию массива.
    </para>
    <para>
     <example>
      <title>Добавление массива в самого себя</title>
      <programlisting role="php">
<![CDATA[
<?php

$a = array('one');
$a[] =& $a;
xdebug_debug_zval('a');

?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
a: (refcount=2, is_ref=1)=array (
   0 => (refcount=1, is_ref=0)='one',
   1 => (refcount=2, is_ref=1)=...
)
]]>
      </screen>
      <para>Графически:</para>
      <mediaobject>
       <alt>Контейнеры массива с циклическими ссылками</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/loop-array.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
    <para>
     Видно, что переменная массива <varname>a</varname>, и второй элемент
     с индексом <varname>1</varname> теперь указывают на контейнер переменной, у которого refcount равен <literal>2</literal>.
     Символы «...» в выводе показывают рекурсию, что в этом случае
     означает, что символы «...» указывают обратно на исходный массив.
    </para>
    <para>
     Как и раньше, удаление переменной уменьшает счётчик ссылок контейнера на единицу.
     Если применить конструкцию unset к переменной <varname>$a</varname> после этого примера,
     счётчик ссылок контейнера, на который указывают переменная <varname>$a</varname> и элемент 1,
     изменится с 2 на 1:
    </para>
    <para>
     <example>
      <title>Удаление переменной массива <varname>$a</varname></title>
      <screen>
<![CDATA[
(refcount=1, is_ref=1)=array (
   0 => (refcount=1, is_ref=0)='one',
   1 => (refcount=1, is_ref=1)=...
)
]]>
      </screen>
      <para>Графически:</para>
      <mediaobject>
       <alt>Контейнеры после удаления массива с циклическими ссылками, которые демонстрируют утечку памяти</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/leak-array.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
   </sect2>

   <sect2 xml:id="features.gc.cleanup-problems">
    <title>Проблемы очистки</title>
    <para>
     Хотя ни в одной области видимости больше нет символа, который указывает
     на структуру массива, структуру нельзя очистить, поскольку элемент массива с ключом 1 по-прежнему
     указывает на этот же массив. Поскольку на структуру не указывает внешний символ,
     пользователь не может очистить эту структуру; поэтому пользователь получает утечку памяти.
     К счастью, PHP очистит эту структуру данных в конце запроса, но до того момента
     данные будут занимать ценное место в памяти. Такая ситуация часто возникает
     при реализации алгоритмов синтаксического анализа или других вещей, в которых дочерние элементы
     указывают на родительские. С ещё большей вероятностью такая же ситуация возникает с объектами,
     поскольку с объектами язык неявно работает «по ссылке».
    </para>
    <para>
     Не проблема, если такое случается раз или два,
     но при тысяче или даже миллионе таких случаев утечки памяти уже станут проблемой.
     Особенно в долгоработающих скриптах, например, демонах, в которых запрос
     не заканчивается, или в крупных наборах модульных тестов.
     Последний случай вызвал проблемы при запуске модульных тестов
     для компонента Template библиотеки ez Components. В ряде случаев
     требовалось больше 2 ГБ памяти, доступа к которой
     на тестовом сервере не было.
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="features.gc.collecting-cycles">
   <title>Сбор циклических ссылок</title>
   <para>
    Обычно механизмы подсчёта ссылок в памяти, например, которые работали в PHP ранее,
    не решают проблему утечки памяти из-за циклических ссылок.
    Начиная с версии 5.3.0 в PHP реализован синхронный механизм из исследования
    «<link xlink:href="&url.gc-paper;">Concurrent Cycle Collection in Reference Counted Systems</link>»,
    в котором рассматривается этот вопрос.
   </para>
   <para>
    Полное описание работы алгоритма выходит за рамки этого раздела, поэтому
    приведены только основы. Вначале нужно задать основные правила.
    Если счётчик ссылок увеличивается, то контейнер всё ещё нужен и не будет считаться мусором.
    Если счётчик уменьшается до нуля, то zval может быть удалён.
    С такими правилами утечки памяти с циклическими ссылками могут получиться только
    при уменьшении счётчика ссылок до ненулевого значения.
    Затем, в выделенных контейнерах можно найти мусор, проверив, можно ли уменьшить
    все счётчики ссылок на единицу, и определив те контейнеры, у которых счётчик станет равным нулю.
   </para>
   <para>
     <mediaobject>
      <alt>Алгоритм сборки мусора</alt>
      <imageobject>
       <imagedata fileref="en/features/figures/gc-algorithm.png" format="PNG"/>
      </imageobject>
     </mediaobject>
   </para>
   <para>
    Для избежания постоянной проверки на мусор с циклическими ссылками при каждом уменьшении счётчика ссылок,
    алгоритм добавляет все возможные корни (zval контейнеры) в «корневой буфер» (помечая
    их как «фиолетовые»). Это также гарантирует попадание любого корня в буфер только один раз.
    Механизм сборки мусора стартует только тогда, когда наполняется буфер (смотрите шаг A
    на рисунке выше).
   </para>
   <para>
    На шаге B алгоритм ищет в глубину по всем возможным корням для
    однократного уменьшения счётчика ссылок на единицу у всех контейнеров
    (помечая их как «серые»). На шаге C алгоритм снова ищет в глубину
    для проверки счётчиков ссылок. Если он находит счётчик с нулевым значением, то
    контейнер помечается как «белый» (на рисунке отображено синим). Если счётчик больше нуля, то
    поиск идёт в глубину от этого контейнера с обратным увеличением счётчиков на единицу
    и повторной пометкой как «чёрный» на их контейнерах. На последнем шаге D алгоритм проходит по
    корневому буферу и удаляет из него корни контейнеров, заодно проверяя какие контейнеры
    помечены как «белые». Эти контейнеры будут освобождены из памяти.
   </para>
   <para>
    Теперь, когда есть представление о работе алгоритма, рассмотрим его
    интеграцию в PHP. По умолчанию сборщик мусора всегда включён.
    Для изменения этой опции используется параметр
    <link linkend="ini.zend.enable-gc">zend.enable_gc</link> в &php.ini;.
   </para>
   <para>
    Если сборщик мусора включён, алгоритм поиска циклических ссылок выполняется каждый раз,
    когда корневой буфер наполняется 10 000 корнями (можно поменять это значение,
    изменив константу <constant>GC_THRESHOLD_DEFAULT</constant> в файле
    <literal>Zend/zend_gc.c</literal> в исходном коде PHP и пересобрав PHP).
    Если сборщик мусора выключен, алгоритм никогда не будет запущен. Тем не менее,
    буфер всегда заполняется корнями.
   </para>
   <para>
    Если буфер заполнился при выключенном механизме сборки мусора, то
    другие корни не будут в него записаны. Таким образом, если они окажутся
    мусором с циклическими ссылками, то никогда не будут очищены и создадут утечку памяти.
   </para>
   <para>
    Причиной постоянной записи корней в буфер даже при выключенном
    механизме сборки мусора является то, что это намного быстрее,
    чем постоянно проверять включён ли механизм сборки мусора или нет.
    Однако, сама сборка мусора и алгоритм её анализа могут занимать значительное
    время.
   </para>
   <para>
    Кроме изменения параметра <link linkend="ini.zend.enable-gc">zend.enable_gc</link>,
    механизм сборки мусора можно запустить и остановить, последовательно вызвав функции
    <function>gc_enable</function> и <function>gc_disable</function>.
    Вызов этих функций имеет тот же эффект, что и включение/выключение механизма
    в настройках конфигурации.
    Кроме того, можно запустить сборку мусора, даже если корневой буфер ещё не заполнен.
    Для этого вы можете вызвать функцию <function>gc_collect_cycles</function>, которая
    также возвращает количество циклических ссылок собранных алгоритмом.
   </para>
   <para>
    Причиной включения и выключения механизма сборки, а также его ручного запуска,
    может стать то, что некоторые части вашего приложения могут быть требовательными
    ко времени. В этих случаях, возможно, не захочется постороннего вмешательства
    сборщика мусора. Разумеется, выключая сборщик мусора в определённых
    местах приложения, есть риск получить утечку памяти, т. к.
    потенциально некоторые корни могут не поместиться в ограниченный
    корневой буфер. Более целесообразно будет вызвать функцию <function>gc_collect_cycles</function>
    прямо перед вызовом функции <function>gc_disable</function> для освобождения памяти и уже
    записанных корней в буфере. Это очистит буфер и даст больше места
    для хранения корней, пока механизм будет выключен.
   </para>
  </sect1>

  <sect1 xml:id="features.gc.performance-considerations">
   <title>Вопросы производительности</title>
   <para>
    В предыдущем разделе нами уже говорилось, что простой сбор корней меньше
    влияет на производительность.
    Хотя запись корней в буфер по сравнению с полным отсутствием
    таковой в PHP 5.2 работает медленней, другие изменения в работе
    PHP 5.3 сделали эту потерю производительности незаметной.
   </para>
   <para>
    Есть две основные области влияющие на производительность:
    уменьшение размера используемой памяти и замедление работы при
    сборке мусора. Рассмотрим их.
   </para>

   <sect2 xml:id="features.gc.performance-considerations.reduced-mem">
    <title>Уменьшение размера используемой памяти</title>
    <para>
     Прежде всего, основной причиной реализации механизма сборки
     мусора является уменьшение размера используемой памяти с помощью
     чистки циклических ссылок, которая происходит при достижении
     соответствующих условий. В реализации PHP это происходит как
     только заполнится корневой буфер или при вызове функции
     <function>gc_collect_cycles</function>.
     На графике ниже приведено использование памяти скрипта,
     запущенного в PHP 5.2 и PHP 5.3, без учёта памяти,
     используемой самим PHP при запуске.
    </para>
    <para>
     <example>
      <title>Пример использования памяти</title>
      <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    public $var = '3.14159265359';
    public $self;
}

$baseMemory = memory_get_usage();

for ( $i = 0; $i <= 100000; $i++ )
{
    $a = new Foo;
    $a->self = $a;
    if ( $i % 500 === 0 )
    {
        echo sprintf( '%8d: ', $i ), memory_get_usage() - $baseMemory, "\n";
    }
}
?>
]]>
      </programlisting>
      <mediaobject>
       <alt>Сравнение использования памяти в PHP 5.2 и PHP 5.3</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/gc-benchmark.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
    <para>
     В этом очень академическом примере мы создаём объект, свойство a которого
     задаётся ссылкой на сам объект. Когда в скрипте в следующей итерации цикла переопределяется
     переменная <varname>$a</varname>, то происходит типичная утечка памяти.
     В данном случае пропадают два контейнера zval (контейнер объекта и контейнер свойства объекта),
     но определяется только один корень — удалённая переменная.
     Как только пройдут 10 000 итераций (максимально в корневом буфере
     будет 10 000 корней), то запустится механизм сборки мусора и
     память, занимаемая этими корнями, будет освобождена.
     Этот процесс хорошо виден на графике использования памяти для PHP 5.3:
     после каждых 10 000 итераций график проседает.
     Сам по себе механизм в данном примере совершает не так много работы, потому что
     структура утечек слишком проста. Из графика видно, что максимальное использование памяти
     в PHP 5.3 составило около 9 Мб, тогда как в PHP 5.2 оно продолжает возрастать.
    </para>
   </sect2>

   <sect2 xml:id="features.gc.performance-considerations.slowdowns">
    <title>Замедление работы</title>
    <para>
     Второй областью, где сборка мусора влияет на производительность,
     является потеря времени, когда сборщик мусора освобождает память.
     Чтобы понять степень этого влияния, мы немного изменим предыдущий скрипт,
     добавив большее число итераций и промежуточных переменных.
     Изменённый скрипт:
    </para>
    <para>
     <example>
      <title>Влияние на производительность</title>
      <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    public $var = '3.14159265359';
    public $self;
}

for ( $i = 0; $i <= 1000000; $i++ )
{
    $a = new Foo;
    $a->self = $a;
}

echo memory_get_peak_usage(), "\n";
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Запустим скрипт два раза: с включённой опцией
     <link linkend="ini.zend.enable-gc">zend.enable_gc</link> и без неё.
    </para>
    <para>
     <example>
      <title>Запуск скрипта</title>
      <programlisting role="shell">
<![CDATA[
time php -dzend.enable_gc=0 -dmemory_limit=-1 -n example2.php
# и
time php -dzend.enable_gc=1 -dmemory_limit=-1 -n example2.php
]]>
      </programlisting>
     </example>
    </para>
    <para>
     На тестовой машине первая команда примерно выполняется 10.7 секунд, а
     вторая примерно 11.4 секунды. Это примерно на 7 % медленнее. Однако,
     максимальное использование памяти скриптом уменьшилось на 98 % с 931 МБ до 10 МБ.
     Этот тест не очень научный, но он действительно демонстрирует преимущество
     по использованию памяти, обеспечиваемое сборщиком мусора. Также хорошо то, что
     замедление для этого скрипта всегда примерно 7 %, тогда как экономия памяти
     увеличивается все больше и больше при нахождении нового мусора.
    </para>
   </sect2>

   <sect2 xml:id="features.gc.performance-considerations.internal-stats">
    <title>Внутренняя статистика сборщика мусора</title>
    <para>
     Можно получить немного больше информации о том, как механизм сборки
     мусора выполняется в PHP. Но для этого необходимо пересобрать PHP
     для включения теста производительности и кода для дополнительного сбора данных. Необходимо
     установить переменную окружения <literal>CFLAGS</literal> в значение
     <literal>-DGC_BENCH=1</literal> до выполнения команды <literal>./configure</literal>
     с вашими параметрами. Следующие команды должны сработать:
    </para>
    <para>
     <example>
      <title>Сборка PHP для включения теста производительности GC</title>
      <programlisting role="shell">
<![CDATA[
export CFLAGS=-DGC_BENCH=1
./config.nice
make clean
make
]]>
      </programlisting>
     </example>
    </para>
    <para>
     При запуске вышеприведённого примера с обновлённым PHP, можно
     увидеть следующую информацию по завершении работы скрипта:
    </para>
    <para>
     <example>
      <title>Статистика GC</title>
      <programlisting role="shell">
<![CDATA[
GC Statistics
-------------
Runs:               110
Collected:          2072204
Root buffer length: 0
Root buffer peak:   10000

      Possible            Remove from  Marked
        Root    Buffered     buffer     grey
      --------  --------  -----------  ------
ZVAL   7175487   1491291    1241690   3611871
ZOBJ  28506264   1527980     677581   1025731
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Наиболее полезная статистика отображена в первом блоке. Можно увидеть,
     что механизм сборки мусора был запущен 110 раз, и суммарно было освобождено
     свыше 2 миллионов записей в памяти. Если сборка мусора была запущена хотя бы раз, то
     максимальное число корней в буфере всегда будет равно 10 000.
    </para>
   </sect2>

   <sect2 xml:id="features.gc.performance-considerations.conclusion">
    <title>Заключение</title>
    <para>
     В целом, сборщик мусора в PHP вызовет ощутимые замедления только во
     время непосредственной работы механизма сборки циклических ссылок, тогда как
     в обычных (небольших) скриптах не должно быть никакого падения производительности.
    </para>
    <para>
     Однако в тех случаях, когда механизм сборки должен срабатывать
     и в обычных скриптах, снижение используемой памяти позволяет
     одновременно работать на сервере большему их количеству.
    </para>
    <para>
     Преимущества наиболее очевидны для долгоработающих скриптов, таких как
     большие наборы тестов или демоны. Новый механизм также должен снизить утечки памяти
     для приложений <link xlink:href="&url.php.gtk;">PHP-GTK</link>, которые выполняются
     обычно дольше, чем веб-скрипты.
    </para>
   </sect2>
  </sect1>
 </chapter>
<!-- Keep this comment at the end of the file
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
