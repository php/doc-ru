<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 8e732e84a1425cf0ab3a5b0da8fe113c7a6da85e Maintainer: rjhdby Status: ready -->
<!-- Reviewed: yes Maintainer: lex -->
<!-- $Revision$ -->
<chapter xml:id="features.commandline" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Использование PHP в командной строке</title>
 <titleabbrev>Использование PHP в командной строке</titleabbrev>

 <!--Introduction: {{{-->
 <section xml:id="features.commandline.introduction">
  <title>Введение</title>

  <para>
   Основная цель этого &cli.sapi; -
   разработка консольных приложений на PHP.
   Имеется довольно много различий между
   &cli.sapi; и другими видами <acronym>SAPI</acronym>, которые
   будут рассмотрены в этой главе.
   Стоит отметить, что &cli.sapi; и <acronym>CGI</acronym> -
   различные <acronym>SAPI</acronym>-интерфейсы, хотя в их поведении много общего.
  </para>

  <para>
   &cli.sapi; включается по умолчанию с помощью опции
   <option role="configure">--enable-cli</option>, но может быть выключен
   опцией <option role="configure">--disable-cli</option> при запуске
   <command>./configure</command>.
  </para>

  <para>
   Имя, расположение и существование бинарных модулей
   &cli;/<acronym>CGI</acronym> зависит от того, как именно
   установлен PHP в вашей системе. По умолчанию при выполнении
   <command>make</command> создаётся как <acronym>CGI</acronym>-,
   так и &cli;-модуль, размещённые в директориях
   <filename>sapi/cgi/php-cgi</filename>
   и <filename>sapi/cli/php</filename> соответственно,
   внутри директории с исходниками PHP.
   Следует заметить, что оба файла имеют одинаковое название:
   <filename>php</filename>.
   Что произойдёт при выполнении <command>make install</command>,
   зависит от того, какие опции вы указали на стадии
   конфигурирования. Если выбран модуль <acronym>SAPI</acronym>
   во время выполнения, например, apxs, или используется опция
   опция <option role="configure">--disable-cgi</option>,
   модуль &cli; будет скопирован в <filename>{PREFIX}/bin/php</filename> при
   выполнении <command>make install</command>, в противном случае
   будет скопирован <acronym>CGI</acronym>-модуль. Например, если
   задана опция <option role="configure">--with-apxs</option>,
   то при выполнении <command>make install</command>
   &cli;-версия будет скопирована в <filename>{PREFIX}/bin/php</filename>.
   Если вы хотите переопределить установку <acronym>CGI</acronym>-модуль,
   используйте <command>make install-cli</command> после выполнения
   <command>make install</command>. В качестве альтернативы
   вы могли бы указать опцию <option role="configure">--disable-cgi</option>
   в строке конфигурации.
  </para>

  <note>
   <para>
    Поскольку обе опции, <option role="configure">--enable-cli</option>
    и <option role="configure">--enable-cgi</option>, включены
    по умолчанию, просто наличие
    <option role="configure">--enable-cli</option> в команде
    конфигурации необязательно означает, что &cli; будет скопирован
    в <filename>{PREFIX}/bin/php</filename> при выполнении
    <command>make install</command>.
   </para>
  </note>

  <para>
   Бинарный файл &cli; входит в дистрибутив
   для Windows в основной папке в качестве файла<filename>php.exe</filename>.
   <acronym>CGI</acronym>-версия находится в файле <filename>php-cgi.exe</filename>.
   Кроме того, в дистрибутив входит файл <filename>php-win.exe</filename>,
   если PHP был сконфигурирован с помощью <option role="configure">--enable-cli-win32</option>.
   Он полностью эквивалентен &cli;-версии, за исключением того,
   что абсолютно ничего не выводит, и, таким образом, не предоставляет консоль
   (окно терминала не появляется на экране).
  </para>

  <note>
   <title>Какой из вариантов SAPI установлен?</title>
   <para>
    Выполните из командной строки <command>php -v</command>
    для получения информации о том, является ли <filename>php</filename>
    <acronym>CGI</acronym> или &cli;. Также вы можете использовать
    функцию <function>php_sapi_name</function> или константу
    <constant>PHP_SAPI</constant>.
   </para>
  </note>

  <note>
   <para>
    Соответствующую страницу руководства (<literal>man</literal>)
    Unix можно просмотреть с помощью команды <command>man php</command>
    в консоли.
   </para>
  </note>
 </section>
 <!--}}}-->

 <!--Differences: {{{-->
 <section xml:id="features.commandline.differences">
  <title>Основные отличия от остальных реализаций <acronym>SAPI</acronym></title>

  <para>
   Основные отличия &cli; <acronym>SAPI</acronym> от остальных реализаций
   <acronym>SAPI</acronym>:
   <itemizedlist>
    <listitem>
     <para>
      В отличие от <acronym>CGI</acronym> <acronym>SAPI</acronym>,
      заголовки не пишутся в поток вывода.
     </para>
     <para>
      Несмотря на то, что в <acronym>CGI</acronym> <acronym>SAPI</acronym>
      есть способ подавления HTTP-заголовков, в &cli.sapi; нет
      возможности их включить.
     </para>
     <para>
      &cli; по умолчанию запускается в тихом режиме, тем не менее,
      ключи <option>-q</option> и <option>--no-header</option>
      сохранены для обратной совместимости, что позволяет
      использовать старые <acronym>CGI</acronym>-скрипты.
     </para>
     <para>
      Текущая директория не изменяется на рабочую директорию скрипта.
      (Ключи <option>-C</option> и <option>--no-chdir</option>
      сохранены для обратной совместимости)
     </para>
     <para>
      Сообщения об ошибках выдаются в текстовом режиме
      (без <acronym>HTML</acronym>-форматирования).
     </para>
    </listitem>

    <listitem>
     <para>
      Некоторые настройки &php.ini; переопределяются &cli.sapi;,
      поскольку они не имеют смысла при работе в командной строке:
     </para>
     <para>
      <table>
       <title>Переопределяемые директивы &php.ini;</title>
       <tgroup cols="3">
        <thead>
         <row>
          <entry>Директива</entry>
          <entry>Значение по умолчанию в &cli; <acronym>SAPI</acronym></entry>
          <entry>Комментарий</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><link linkend="ini.html-errors">html_errors</link></entry>
          <entry>&false;</entry>
          <entry>
           По умолчанию &false;, т.к. бывает достаточно сложно читать в консоли
           сообщения об ошибке, когда они наполнены бессмысленными <acronym>HTML</acronym>-тегами.
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.implicit-flush">implicit_flush</link></entry>
          <entry>&true;</entry>
          <entry>
           Обычно в консоли желательно отображать вывод, например,
           из <function>print</function>,
           <function>echo</function> и других,
           сразу же минуя буфер. Тем не менее, по-прежнему можно использовать
           <link linkend="ref.outcontrol">буферизацию вывода</link> для
           отложенного вывода или манипуляций с ним.
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.max-execution-time">max_execution_time</link></entry>
          <entry>0 (без ограничений)</entry>
          <entry>
           PHP, выполняемый в консоли, как правило, используется для более широкого диапазона
           задач, чем обычные веб-скрипты. И так как они могут выполняться очень долго,
           то максимальное время выполнения неограниченно.
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.register-argc-argv">register_argc_argv</link></entry>
          <entry>&true;</entry>
          <entry>
           <para>
            Установка этой опции в значение &true; означает, что скрипты
            запускаемые через &cli; <acronym>SAPI</acronym> всегда
            имеют доступ к <emphasis>argc</emphasis> (количество аргументов, переданных приложению)
            и <emphasis>argv</emphasis> (массив текущих аргументов).
           </para>
           <para>
            При использовании &cli; <acronym>SAPI</acronym>
            переменные <varname>$argc</varname> и <varname>$argv</varname>
            автоматически заполняются соответствующими значениями. Эти
            значения можно также найти в массиве <varname>$_SERVER</varname>,
            например: <varname>$_SERVER['argv']</varname>.
           </para>
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.output-buffering">output_buffering</link></entry>
          <entry>&false;</entry>
          <entry>
           <para>
            Несмотря на то, что эта опция &php.ini; жёстко установлена в &false;,
            функции <link linkend="book.outcontrol">буферизации вывода</link> всё ещё
            доступны.
           </para>
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.max-input-time">max_input_time</link></entry>
          <entry>&false;</entry>
          <entry>
           <para>
            PHP &cli; не поддерживает GET, POST или загрузку файлов.
           </para>
          </entry>
         </row>
        </tbody>
       </tgroup>
      </table>
     </para>
     <note>
      <para>
       Эти директивы не могут быть инициализированы другими значениями
       из конфигурационного файла &php.ini; или любого другого (в случае, если он указан).
       Это ограничение связано с тем, что значения применяются
       после обработки конфигурационных файлов. Тем не менее, эти значения
       могут быть изменены во время работы скрипта (хотя это не имеет особого смысла
       для всех них, например <link linkend="ini.register-argc-argv">register_argc_argv</link>).
      </para>
     </note>
     <note>
      <para>
       Рекомендуется установить опцию
       <link linkend="ini.ignore-user-abort">ignore_user_abort</link> для
       скриптов, используемых из командной строки. За подробностями
       обращайтесь к функции <function>ignore_user_abort</function>.
      </para>
     </note>
    </listitem>

    <listitem>
     <para>
      Для облегчения работы в окружении оболочки было определено
      некоторое количество констант для
      <link linkend="features.commandline.io-streams">потоков ввода/вывода</link>.
     </para>
    </listitem>

    <listitem>
     <para>
      &cli.sapi; <emphasis role="strong">не</emphasis>
      изменяет текущую директорию на директорию исполняемого скрипта.
     </para>
     <example>
      <title>
       Пример, демонстрирующий разницу с <acronym>CGI</acronym> <acronym>SAPI</acronym>:
      </title>
      <programlisting role="php">
<![CDATA[
<?php
// Простейший тестовый скрипт под названием test.php
echo getcwd(), "\n";
?>
]]>
      </programlisting>
      <para>
       В случае, если используется <acronym>CGI</acronym>-версия, результат работы будет следующим:
      </para>
      <screen>
<![CDATA[
$ pwd
/tmp

$ php -q another_directory/test.php
/tmp/another_directory
]]>
      </screen>
      <para>
       Это наглядно демонстрирует, что PHP изменяет
       текущую директорию на директорию исполняемого скрипта.
      </para>
      <para>
       Использование &cli.sapi; даёт другой результат:
      </para>
      <screen>
<![CDATA[
$ pwd
/tmp

$ php -f another_directory/test.php
/tmp
]]>
      </screen>
      <para>
       Это обеспечивает большую гибкость при написании консольных скриптов на PHP.
      </para>
     </example>
     <note>
      <para>
       <acronym>CGI</acronym> <acronym>SAPI</acronym> позволяет
       получить аналогичное &cli.sapi; поведение в случае
       использования ключа <option>-C</option>
       при запуске из командной строки.
      </para>
     </note>
    </listitem>
   </itemizedlist>
  </para>
 </section>
 <!--}}}-->

 <!--Options: {{{-->
 <section xml:id="features.commandline.options">
  <title>Список опций командной строки</title>
  <titleabbrev>Опции</titleabbrev>

  <para>
   Список опций командной строки, предоставляемых PHP,
   могут быть получены в любой момент, запустив PHP с ключом <option>-h</option>:
   <screen>
<![CDATA[
Usage: php [options] [-f] <file> [--] [args...]
   php [options] -r <code> [--] [args...]
   php [options] [-B <begin_code>] -R <code> [-E <end_code>] [--] [args...]
   php [options] [-B <begin_code>] -F <file> [-E <end_code>] [--] [args...]
   php [options] -- [args...]
   php [options] -a

  -a               Run interactively
  -c <path>|<file> Look for php.ini file in this directory
  -n               No php.ini file will be used
  -d foo[=bar]     Define INI entry foo with value 'bar'
  -e               Generate extended information for debugger/profiler
  -f <file>        Parse and execute <file>.
  -h               This help
  -i               PHP information
  -l               Syntax check only (lint)
  -m               Show compiled in modules
  -r <code>        Run PHP <code> without using script tags <?..?>
  -B <begin_code>  Run PHP <begin_code> before processing input lines
  -R <code>        Run PHP <code> for every input line
  -F <file>        Parse and execute <file> for every input line
  -E <end_code>    Run PHP <end_code> after processing all input lines
  -H               Hide any passed arguments from external tools.
  -S <addr>:<port> Run with built-in web server.
  -t <docroot>     Specify document root <docroot> for built-in web server.
  -s               Output HTML syntax highlighted source.
  -v               Version number
  -w               Output source with stripped comments and whitespace.
  -z <file>        Load Zend extension <file>.

  args...          Arguments passed to script. Use -- args when first argument
                   starts with - or script is read from stdin

  --ini            Show configuration file names

  --rf <name>      Show information about function <name>.
  --rc <name>      Show information about class <name>.
  --re <name>      Show information about extension <name>.
  --rz <name>      Show information about Zend extension <name>.
  --ri <name>      Show configuration for extension <name>.
]]>
   </screen>
  </para>

  <para>
   <table>
    <title>Опции, доступные из командной строки</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Опция</entry>
       <entry>Полное название</entry>
       <entry>Описание</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>-a</entry>
       <entry>--interactive</entry>
       <entry>
        <para>
         Запустить PHP в интерактивном режиме. Для получения дополнительной информации смотрите
         раздел <link linkend="features.commandline.interactive">Интерактивная консоль</link>.
        </para>
       </entry>
      </row>
      <row>
       <entry>-b</entry>
       <entry>--bindpath</entry>
       <entry>
        <para>
         Путь связывания библиотек (Bind Path) для внешнего режима FASTCGI Server (только для <acronym>CGI</acronym>).
        </para>
       </entry>
      </row>
      <row>
       <entry>-C</entry>
       <entry>--no-chdir</entry>
       <entry>
        <para>
         Не менять текущую директорию на директорию скрипта (только для <acronym>CGI</acronym>).
        </para>
       </entry>
      </row>
      <row>
       <entry>-q</entry>
       <entry>--no-header</entry>
       <entry>
        <para>
         Тихий режим. Подавляет вывод заголовков <acronym>HTTP</acronym>
         (только для <acronym>CGI</acronym>).
        </para>
       </entry>
      </row>
      <row>
       <entry>-T</entry>
       <entry>--timing</entry>
       <entry>
        <para>
         Измерить время выполнения скрипта, повторенного <varname>count</varname>
         раз (только для <acronym>CGI</acronym>).
        </para>
       </entry>
      </row>
      <row>
       <entry>-c</entry>
       <entry>--php-ini</entry>
       <entry>
        <para>
         Указывает, либо директорию, в которой нужно искать
         конфигурационный файл &php.ini;, либо пользовательский
         <literal>INI</literal>-файл (название которого может
         отличаться от стандартного &php.ini;), например:
        </para>
        <para><informalexample>
         <screen>
<![CDATA[
$ php -c /custom/directory/ my_script.php

$ php -c /custom/directory/custom-file.ini my_script.php
]]>
         </screen>
         </informalexample></para>
        <para>
         Если эта опция не указана, поиск &php.ini; будет осуществлён
         в <link linkend="configuration.file">местах по умолчанию</link>.
        </para>
       </entry>
      </row>
      <row>
       <entry>-n</entry>
       <entry>--no-php-ini</entry>
       <entry>
        <para>
         Полностью игнорировать &php.ini;.
        </para>
       </entry>
      </row>
      <row>
       <entry>-d</entry>
       <entry>--define</entry>
       <entry>
        <para>
         Устанавливает пользовательское значение для каждой из
         конфигурационных опций, доступных в &php.ini;. Синтаксис выглядит следующим образом:
         <screen>
<![CDATA[
 -d configuration_directive[=value]
 ]]>
         </screen>
        </para>
        <para><example>
         <screen>
<![CDATA[
# Если значение опущено, то соответствующей опции будет присвоено значение "1"
$ php -d max_execution_time
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(1) "1"

# Указание пустого значения установит соответствующую опцию значением ""
php -d max_execution_time=
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(0) ""

# Конфигурационная переменная будет установлена любым значением, указанным после символа '='
$  php -d max_execution_time=20
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(2) "20"
$  php
        -d max_execution_time=doesntmakesense
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(15) "doesntmakesense"
]]>
         </screen>
         </example></para>
       </entry>
      </row>
      <row>
       <entry>-e</entry>
       <entry>--profile-info</entry>
       <entry>
        <para>
         Включить режим расширенной информации, используемый
         отладчиком/профайлером.
        </para>
       </entry>
      </row>
      <row>
       <entry>-f</entry>
       <entry>--file</entry>
       <entry>
        <para>
         Парсит и исполняет файл, указанный в опции <option>-f</option>.
         Этот параметр необязателен и может быть опущен - достаточно
         просто указать имя запускаемого файла.
        </para>
        <note>
         <para>
          Для передачи аргументов в скрипт, первый аргумент должен быть
          <literal>--</literal>, иначе PHP будет интерпретировать их как свои опции.
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-h и -?</entry>
       <entry>--help и --usage</entry>
       <entry>
        Выводит список опций командной строки с однострочным описанием того, что они делают.
       </entry>
      </row>
      <row>
       <entry>-i</entry>
       <entry>--info</entry>
       <entry>
        Вызывает <function>phpinfo</function> и выводить её результат.
        В случае, если PHP работает некорректно, рекомендуется
        выполнить <command>php -i</command> и
        посмотреть, выводятся ли сообщения об ошибках до или
        вместо информационных таблиц. Учитывайте, что в случае использования
        <acronym>CGI</acronym>-модуля весь вывод будет в формате
        <acronym>HTML</acronym> и, как следствие, очень большим.
       </entry>
      </row>
      <row>
       <entry>-l</entry>
       <entry>--syntax-check</entry>
       <entry>
        <para>
         Предоставляет удобный способ для проверки заданного
         PHP-кода на наличие синтаксических ошибок.
         В случае успешной проверки будет напечатана следующая фраза:
         "<literal>No syntax errors detected in &lt;filename&gt;</literal>",
         а код возврата будет равен <literal>0</literal>.
         При неудачной проверке будет выведено "<literal>Errors parsing &lt;filename&gt;</literal>"
         вместе с внутренними сообщениями парсера, а код возврата будет равен <literal>-1</literal>.
        </para>
        <para>
         Данная опция не будет обнаруживать
         фатальные ошибки (например, вызов неопределённых функций).
         Используйте опцию <option>-f</option>, если вы
         хотите проверить код на наличие фатальных ошибок.
        </para>
        <note>
         <para>
          Эта опция не работает с опцией <option>-r</option>.
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-m</entry>
       <entry>--modules</entry>
       <entry>
        <para><example>
         <title>Вывод встроенных (и загруженных) модулей PHP и Zend</title>
         <screen>
<![CDATA[
$ php -m
[PHP Modules]
xml
tokenizer
standard
session
posix
pcre
overload
mysql
mbstring
ctype

[Zend Modules]
]]>
         </screen>
         </example></para>
       </entry>
      </row>
      <row>
       <entry>-r</entry>
       <entry>--run</entry>
       <entry>
        <para>
         Позволяет выполнять PHP-код, указанный
         непосредственно в командной строке. Открывающие и закрывающие
         PHP-теги (<literal>&lt;?php</literal> и <literal>?&gt;</literal>)
         <emphasis role="strong">не нужны</emphasis> и будут
         приводит к синтаксической ошибке, если они присутствуют.
        </para>
        <note>
         <para>
          При использовании этого ключа следует быть очень осторожным и избегать
          недоразумений, связанных с автоматической подстановкой переменных окружения.
         </para>
         <example>
          <title>Ошибка синтаксиса при использовании двойных кавычек</title>
          <screen>
<![CDATA[
$ php -r "$foo = get_defined_constants();"
PHP Parse error:  syntax error, unexpected '=' in Command line code on line 1

Parse error: syntax error, unexpected '=' in Command line code on line 1
]]>
          </screen>
         </example>
         <para>
          Проблема здесь заключается в том, что sh/bash выполняет автоматическую
          подстановку переменных в случае, если используются двойные кавычки
          (<literal>"</literal>). Поскольку переменная <varname>$foo</varname>
          вряд ли определена, она заменяется пустой строкой, что приводит к тому,
          что передаваемый PHP-код для выполнения выглядит следующим образом:
         </para>
         <informalexample>
          <screen>
<![CDATA[
$ php -r " = get_defined_constants();"
]]>
          </screen>
         </informalexample>

         <para>
          Правильным решением в данном случае будет использование
          одинарных кавычек <literal>'</literal>, поскольку автоматическая
          подстановка переменных, заключённых в одинарные кавычки, в sh/bash не происходит.
         </para>
         <example>
          <title>Использование одинарных кавычек для предотвращения
           подстановки переменных в консоли</title>
          <screen>
<![CDATA[
$ php -r '$foo = get_defined_constants(); var_dump($foo);'
array(370) {
  ["E_ERROR"]=>
  int(1)
  ["E_WARNING"]=>
  int(2)
  ["E_PARSE"]=>
  int(4)
  ["E_NOTICE"]=>
  int(8)
  ["E_CORE_ERROR"]=>
  [...]
]]>
          </screen>
         </example>
         <para>
          При использовании оболочки, отличной от sh/bash, могут возникнуть
          другие проблемы. В таком случае необходимо создать отчёт о возникшей ошибке на сайте
          <link xlink:href="&url.php.bugs;">&url.php.bugs;</link>.
          Можно столкнуться с проблемами при попытке получить доступ
          к переменным оболочки или при работе с экранирующими обратными слешами.
          Теперь вы предупреждены!
         </para>
        </note>
        <note>
         <para>
          Ключ <option>-r</option> доступен в &cli.sapi;, но недоступен
          в <emphasis>CGI</emphasis> <acronym>SAPI</acronym>.
         </para>
        </note>
        <note>
         <para>
          Эта опция предназначена только для самого простого кода.
          Поэтому некоторые конфигурационные директивы (например,
          <link linkend="ini.auto-prepend-file">auto_prepend_file</link>
          и <link linkend="ini.auto-append-file">auto_append_file</link>)
          в этом режиме будут проигнорированы.
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-B</entry>
       <entry>--process-begin</entry>
       <entry>
        <para>
         Выполняемый код PHP перед обработкой потока ввода (stdin).
        </para>
       </entry>
      </row>
      <row>
       <entry>-R</entry>
       <entry>--process-code</entry>
       <entry>
        <para>
         PHP-код, выполняемый для каждой строки ввода.
        </para>
        <para>
         В этом режиме есть две специальные переменные:
         <varname>$argn</varname> и <varname>$argi</varname>.
         <varname>$argn</varname> содержит строку, которую PHP
         обрабатывает в данный момент, а <varname>$argi</varname>
         содержит номер этой строки.
        </para>
       </entry>
      </row>
      <row>
       <entry>-F</entry>
       <entry>--process-file</entry>
       <entry>
        <para>
         PHP-файл, выполняемый для каждой строки ввода.
        </para>
       </entry>
      </row>
      <row>
       <entry>-E</entry>
       <entry>--process-end</entry>
       <entry>
        <para>
         PHP-код, выполняемый после обработки ввода.
        </para>
        <para><example>
         <title>Использование опций <option>-B</option>, <option>-R</option> и
          <option>-E</option> для подсчёта количества строк в
          проекте.
         </title>
         <screen>
<![CDATA[
$ find my_proj | php -B '$l=0;' -R '$l += count(@file($argn));' -E 'echo "Всего строк: $l\n";'
Всего строк: 37328
]]>
         </screen>
         </example></para>
       </entry>
      </row>
      <row>
       <entry>-S</entry>
       <entry>--server</entry>
       <entry>
        <para>
         Запускает <link linkend="features.commandline.webserver">встроенный веб-сервер</link>.
        </para>
       </entry>
      </row>
      <row>
       <entry>-t</entry>
       <entry>--docroot</entry>
       <entry>
        Указывает корень документа для
        <link linkend="features.commandline.webserver">встроенного веб-сервера</link>.
       </entry>
      </row>
      <row>
       <entry>-s</entry>
       <entry>--syntax-highlight и --syntax-highlighting</entry>
       <entry>
        <para>
         Показать исходный код с подсветкой синтаксиса.
        </para>
        <para>
         Эта опция использует внутренний механизм для разбора файла
         и записи в стандартный поток вывода подсвеченной версии
         этого файла. Учтите, что все что она делает, это генерирует
         блок <literal>&lt;code&gt; [...] &lt;/code&gt;</literal>
         HTML-тегов, без HTML-заголовков.
        </para>
        <note>
         <para>
          Эта опция несовместима с опцией <option>-r</option>.
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-v</entry>
       <entry>--version</entry>
       <entry>
        <para><example>
         <title>Использование <option>-v</option> для получения
          типа <acronym>SAPI</acronym> и версии PHP и Zend</title>
         <screen>
<![CDATA[
$ php -v
PHP 5.3.1 (cli) (built: Dec 11 2009 19:55:07)
Copyright (c) 1997-2009 The PHP Group
Zend Engine v2.3.0, Copyright (c) 1998-2009 Zend Technologies
]]>
         </screen>
         </example></para>
       </entry>
      </row>
      <row>
       <entry>-w</entry>
       <entry>--strip</entry>
       <entry>
        <para>
         Показать исходный код без комментариев и пробелов.
        </para>
        <note>
         <para>
          Эта опция несовместима с опцией <option>-r</option>.
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-z</entry>
       <entry>--zend-extension</entry>
       <entry>
        <para>
         Загружает модуль Zend. Если передано только имя файла,
         PHP попытается загрузить этот модуль из пути библиотек
         по умолчанию (обычно указывается в <filename>/etc/ld.so.conf</filename> в
         системах Linux). Передача файла с абсолютным путём не будет использовать
         системный путь поиска библиотеки. Относительное имя файла, содержащее
         директорию, укажет PHP подгрузить модуль относительно
         текущей директории.
        </para>
       </entry>
      </row>
      <row>
       <entry></entry>
       <entry>--ini</entry>
       <entry>
        <para>
         Показывает имена конфигурационных файлов и отсканированные директории.
         <example>
          <title>Пример <literal>--ini</literal></title>
          <programlisting role="shell">
<![CDATA[
$ php --ini
Configuration File (php.ini) Path: /usr/dev/php/5.2/lib
Loaded Configuration File:         /usr/dev/php/5.2/lib/php.ini
Scan for additional .ini files in: (none)
Additional .ini files parsed:      (none)
]]>
          </programlisting>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>--rf</entry>
       <entry>--rfunction</entry>
       <entry>
        <para>
         Показывает информацию об указанной функции или методе
         класса (например, количество и названия параметров).
        </para>
        <para>
         Эта опция доступна только в том случае, если PHP был скомпилирован
         с поддержкой <link linkend="book.reflection">Reflection</link>.
        </para>
        <para>
         <example>
          <title>Базовое использование <literal>--rf</literal></title>
          <programlisting role="shell">
<![CDATA[
$ php --rf var_dump
Function [ <internal> public function var_dump ] {

  - Parameters [2] {
    Parameter #0 [ <required> $var ]
    Parameter #1 [ <optional> $... ]
  }
}
]]>
          </programlisting>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>--rc</entry>
       <entry>--rclass</entry>
       <entry>
        <para>
         Показывает информацию об указанном классе
         (список констант, свойств и методов).
        </para>
        <para>
         Эта опция доступна только в том случае, если PHP был скомпилирован
         с поддержкой <link linkend="book.reflection">Reflection</link>.
        </para>
        <para>
         <example>
          <title>Пример <literal>--rc</literal></title>
          <programlisting role="shell">
<![CDATA[
$ php --rc Directory
Class [ <internal:standard> class Directory ] {

  - Constants [0] {
  }

  - Static properties [0] {
  }

  - Static methods [0] {
  }

  - Properties [0] {
  }

  - Methods [3] {
    Method [ <internal> public method close ] {
    }

    Method [ <internal> public method rewind ] {
    }

    Method [ <internal> public method read ] {
    }
  }
}
]]>
          </programlisting>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>--re</entry>
       <entry>--rextension</entry>
       <entry>
        <para>
         Показывает информацию об указанном модуле
         (список опций &php.ini;, определённых функций, констант
         и классов).
        </para>
        <para>
         Эта опция доступна только в том случае, если PHP был скомпилирован
         с поддержкой <link linkend="book.reflection">Reflection</link>.
        </para>
        <para>
         <example>
          <title>Пример <literal>--re</literal></title>
          <programlisting role="shell">
<![CDATA[
$ php --re json
Extension [ <persistent> extension #19 json version 1.2.1 ] {

  - Functions {
    Function [ <internal> function json_encode ] {
    }
    Function [ <internal> function json_decode ] {
    }
  }
}
]]>
          </programlisting>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>--rz</entry>
       <entry>--rzendextension</entry>
       <entry>
        <para>
         Показывает информацию о конфигурации указанного Zend-модуля
         (та же информация, которая возвращается <function>phpinfo</function>).
        </para>
       </entry>
      </row>
      <row>
       <entry>--ri</entry>
       <entry>--rextinfo</entry>
       <entry>
        <para>
         Показывает информацию о конфигурации указанного модуля
         (та же информация, которая возвращается <function>phpinfo</function>).
         Конфигурацию ядра можно узнать, указав в качестве имени
         модуля значение "main".
        </para>
        <para>
         <example>
          <title>Пример <literal>--ri</literal></title>
          <programlisting role="shell">
<![CDATA[
$ php --ri date

date

date/time support => enabled
"Olson" Timezone Database Version => 2009.20
Timezone Database => internal
Default timezone => Europe/Oslo

Directive => Local Value => Master Value
date.timezone => Europe/Oslo => Europe/Oslo
date.default_latitude => 59.930972 => 59.930972
date.default_longitude => 10.776699 => 10.776699
date.sunset_zenith => 90.583333 => 90.583333
date.sunrise_zenith => 90.583333 => 90.583333
]]>
          </programlisting>
         </example>
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>

  <note>
   <para>
    Опции <literal>-rBRFEH</literal>, <literal>--ini</literal> и
    <literal>--r[fcezi]</literal> доступны только в &cli;.
   </para>
  </note>
 </section>
 <!--}}}-->

 <!--Usage: {{{-->
 <section xml:id="features.commandline.usage">
  <title>Выполнение PHP-файлов</title>
  <titleabbrev>Использование</titleabbrev>

  <para>
   В &cli.sapi; есть три различных способа запуска PHP-кода:
   <orderedlist>
    <listitem>
     <para>
      Указание конкретного файла для запуска.
     </para>
     <informalexample>
      <screen>
<![CDATA[
$ php my_script.php

$ php -f my_script.php
]]>
      </screen>
     </informalexample>
     <para>
      Оба способа (с указанием опции <option>-f</option> или без) запустят
      файл <filename>my_script.php</filename>. Нет ограничений, какой
      файл запускать; в частности, файлы не обязаны иметь
      расширение <literal>.php</literal>.
     </para>
     <note>
      <para>
       Если необходимо передать аргументы в скрипт,
       то при использовании опции <option>-f</option>
       первым аргументом должен быть <literal>--</literal> .
      </para>
     </note>
    </listitem>
    <listitem>
     <para>
      Передать PHP-код напрямую в командной строке.
     </para>
     <informalexample>
      <screen>
<![CDATA[
$ php -r 'print_r(get_defined_constants());'
]]>
      </screen>
     </informalexample>
     <para>
      Необходимо быть особо осторожным при использовании этого способа,
      т.к. может произойти подстановка переменных оболочки при использовании
      двойных кавычек.
     </para>
     <note>
      <para>
       Внимательно прочтите пример: в нем нет открывающих и закрывающих тегов!
       Опция <option>-r</option> просто в них не нуждается, и их использование
       приведёт к ошибке разбора.
      </para>
     </note>
    </listitem>
    <listitem>
     <para>
      Передать запускаемый PHP-код через стандартный поток ввода
      (<literal>stdin</literal>).
     </para>
     <para>
      Это даёт мощную возможность создавать PHP-код и
      передавать его запускаемому файлу, как показано в этом
      (вымышленном) примере:
     </para>
     <informalexample>
      <screen>
<![CDATA[
$ some_application | some_filter | php | sort -u > final_output.txt
]]>
      </screen>
     </informalexample>
    </listitem>
   </orderedlist>
   Вы не можете комбинировать любой из этих трёх способов запуска кода.
  </para>

  <para>
   Как и любое другое консольное приложение, бинарный файл PHP
   принимает аргументы, но PHP-скрипт также может получать
   аргументы. PHP не ограничивает количество аргументов,
   передаваемых в скрипт (оболочка консоли устанавливает
   некоторый порог количества символов, которые могут быть переданы;
   обычно этого лимита хватает). Переданные аргументы доступны
   в глобальном массиве <varname>$argv</varname>. Первый индекс
   (ноль) всегда содержит имя вызываемого скрипта из командной
   строки. Учтите, что если код вызывается на лету из командной
   строки с помощью опции <option>-r</option>, значением
   <varname>$argv[0]</varname> будет просто дефис
   (<literal>-</literal>). То же самое верно и для кода,
   переданного через конвейер из <literal>STDIN</literal>.
  </para>

  <para>
   Вторая зарегистрированная глобальная переменная - это
   <varname>$argc</varname>, содержащая количество элементов
   в массиве <varname>$argv</varname>
   (а <emphasis role="strong">не</emphasis> количество аргументов,
   переданных скрипту).
  </para>

  <para>
   Если передаваемые аргументы не начинаются с символа
   <literal>-</literal>, то особых проблем быть не должно.
   Передаваемый в скрипт аргумент, который начинается с <literal>-</literal>
   создаст проблемы, т.к. PHP решит, что он сам должен его
   обработать. Для предотвращения подобного поведения
   используйте разделитель списка аргументов <literal>--</literal>.
   После того, как этот разделитель будет проанализирован PHP, все последующие
   аргументы будут переданы в скрипт нетронутыми.
  </para>

  <informalexample>
   <screen>
<![CDATA[
# Эта команда не запустит данный код, но покажет информацию об использовании PHP
$ php -r 'var_dump($argv);' -h
Usage: php [options] [-f] <file> [args...]
[...]

# Эта команда передаст аргумент '-h' в скрипт, предотвратив показ справки PHP
$ php -r 'var_dump($argv);' -- -h
array(2) {
  [0]=>
  string(1) "-"
  [1]=>
  string(2) "-h"
}
]]>
   </screen>
  </informalexample>

  <para>
   Однако, в Unix-системах есть ещё один способ использования
   PHP для консольных скриптов. Можно написать скрипт,
   первая строка которого будет начинаться с
   <literal>#!/usr/bin/php</literal> (или же другой
   корректный путь к бинарному файлу PHP &cli;).
   После этой строки можно поместить обычный PHP-код, заключённый
   в открывающие и закрывающие теги PHP. Как только будут установлены
   корректные атрибуты запуска на файл (например,
   <command>chmod +x test</command>), скрипт может быть
   запущен как обычный консольный или perl-скрипт:
  </para>

  <example>
   <title>Запуск PHP-скрипта как консольного</title>
   <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php
var_dump($argv);
?>
]]>
   </programlisting>
   <para>
    Предполагая, что этот файл назван <filename>test</filename>
    и находится в текущей директории, можно сделать следующее:
   </para>
   <screen>
<![CDATA[
$ chmod +x test
$ ./test -h -- foo
array(4) {
  [0]=>
  string(6) "./test"
  [1]=>
  string(2) "-h"
  [2]=>
  string(2) "--"
  [3]=>
  string(3) "foo"
}
]]>
   </screen>
  </example>

  <para>
   Как можно увидеть, в этом случае не нужно заботиться о
   передаче параметров, которые начинаются с <literal>-</literal>.
  </para>

  <para>
   Исполняемый PHP-файл может использоваться для запуска PHP-скриптов
   независимо от веб-сервера. В случае работы в Unix-подобной системе,
   необходимо добавить в первую строку файла <literal>#!</literal> (называемый также "shebang")
   чтобы указать, какая из программ должна запускать скрипт.
   На Windows-платформах можно назначить обработчик <filename>php.exe</filename> для файлов
   с расширениями <literal>.php</literal> или создать пакетный
   (.bat) файл для запуска скриптов посредством PHP.
   Строка, добавляемая в начале скрипта для Unix-систем,
   не влияет на их работу в ОС Windows, таким образом можно
   создавать кроссплатформенные скрипты. Ниже приведён простой
   пример скрипта, выполняемого из командной строки:
  </para>

  <para>
   <example>
    <title>Скрипт, предназначенный для запуска из командной строки (script.php)</title>
    <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php

if ($argc != 2 || in_array($argv[1], array('--help', '-help', '-h', '-?'))) {
?>

Это консольный PHP-скрипт, принимающий один аргумент.

  Использование:
  <?php echo $argv[0]; ?> <option>

  <option> Любое слово, которое вы хотели бы
  напечатать. Опции  --help, -help, -h,
  или -? покажут текущую справочную информацию.

<?php
} else {
    echo $argv[1];
}
?>
]]>
    </programlisting>
   </example>
  </para>

  <para>
   В приведённом выше скрипте в первой строке содержится shebang,
   указывающий что этот файл должен запускаться PHP. Работа ведётся с &cli;-версией,
   поэтому не будет выведено ни одного <acronym>HTTP</acronym>-заголовка.
  </para>

  <para>
   Скрипт сначала проверяет наличие обязательного одного аргумента (в дополнение к
   имени скрипта, который также подсчитывается). Если их нет, или если переданный
   аргумент был <option>--help</option>, <option>-help</option>,
   <option>-h</option> или <option>-?</option>, выводится
   справочное сообщение с использованием <varname>$argv[0]</varname>, которое содержит
   имя выполняемого скрипта. В противном случае просто выводится полученный аргумент.
  </para>

  <para>
   Для запуска приведённого примера в Unix-системе, нужно сделать
   его исполняемым и просто выполнить в консоли
   <command>script.php echothis</command> или
   <command>script.php -h</command>. В Windows-системе можно
   создать пакетный файл:
  </para>

  <para>
   <example>
    <title>Пакетный файл для запуска PHP-скрипта из командной строки (script.bat)</title>
    <programlisting role="shell">
<![CDATA[
@echo OFF
"C:\php\php.exe" script.php %*
]]>
    </programlisting>
   </example>
  </para>

  <para>
   Предполагая, что вышеприведённый скрипт называется
   <filename>script.php</filename>, а полный путь к &cli;
   <filename>php.exe</filename> находится в
   <filename>C:\php\php.exe</filename>, этот пакетный файл
   запустит его с переданными параметрами:
   <command>script.bat echothis</command> или
   <command>script.bat -h</command>.
  </para>

  <para>
   Также можно ознакомиться с модулем
   <link linkend="ref.readline">Readline</link> для получения
   дополнительных функций, которые можно использовать для улучшения
   консольного PHP-скрипта.
  </para>

  <para>
   В Windows запуск PHP можно настроить без
   необходимости указывать <filename>C:\php\php.exe</filename> или
   расширение <literal>.php</literal>.
   Подробнее эта тема описана в разделе
   <link linkend="install.windows.commandline">Запуск PHP из
    командной строки в Microsoft Windows</link>.
  </para>

  <note>
   <para>
    В Windows рекомендуется запускать PHP под актуальной учётной записью пользователя.
    При работе в сетевой службе некоторые операции не будут выполнены, поскольку
    "сопоставление имён учётных записей и идентификаторов безопасности не выполнено".
   </para>
  </note>
 </section>
 <!--}}}-->

 <!--I/O Streams: {{{-->
 <section xml:id="features.commandline.io-streams">
  <title>Потоки ввода/вывода</title>
  <titleabbrev>Потоки ввода/вывода</titleabbrev>

  <para>
   Модуль &cli.sapi; определяет несколько констант для потоков
   ввода/вывода, чтобы упростить работу с командной строкой.
  </para>

  <para>
   <table>
    <title>Константы, специфичные для модуля CLI</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Константа</entry>
       <entry>Описание</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><constant>STDIN</constant></entry>
       <entry>
        <para>Уже открытый поток ввода (<literal>stdin</literal>).
         Это предотвращает необходимость его открывать следующим способом:
         <programlisting role="php">
<![CDATA[
<?php
$stdin = fopen('php://stdin', 'r');
?>
]]>
         </programlisting>
         Если вы хотите прочесть одну строку из <literal>stdin</literal>,
         можно использовать следующий код:
         <programlisting role="php">
<![CDATA[
<?php
$line = trim(fgets(STDIN)); // читает одну строку из STDIN
fscanf(STDIN, "%d\n", $number); // читает число из STDIN
?>
]]>
         </programlisting>
        </para></entry>
      </row>
      <row>
       <entry><constant>STDOUT</constant></entry>
       <entry><para>
        Уже открытый поток вывода (<literal>stdout</literal>).
        Это предотвращает необходимость его открывать следующим способом:
        <programlisting role="php">
<![CDATA[
<?php
$stdout = fopen('php://stdout', 'w');
?>
]]>
        </programlisting>
        </para></entry>
      </row>
      <row>
       <entry><constant>STDERR</constant></entry>
       <entry>
        <para>
         Уже открытый поток ошибок (<literal>stderr</literal>).
         Это предотвращает необходимость его открывать следующим способом:
         <programlisting role="php">
<![CDATA[
<?php
$stderr = fopen('php://stderr', 'w');
?>
]]>
         </programlisting>
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>

  <para>
   Учитывая вышесказанное, нет необходимости самому открывать поток,
   например, <literal>stderr</literal>, а можно  просто
   использовать уже определённую константу ресурса потока:
   <programlisting role="shell">
<![CDATA[
php -r 'fwrite(STDERR, "stderr\n");'
]]>
   </programlisting>
   Вам не нужно явно закрывать эти потоки, они будут закрыты PHP
   автоматически при окончании вашего скрипта.
  </para>

  <note>
   <para>
    Эти константы недоступны, если считывается PHP-скрипт
    из <literal>stdin</literal>.
   </para>
  </note>
 </section>
 <!--}}}-->

 <!--Interactive shell: {{{-->
 <section xml:id="features.commandline.interactive">
  <title>Интерактивная консоль</title>

  <para>
   Модуль &cli.sapi; предоставляет
   интерактивную консоль, используя опцию
   <option>-a</option>, если PHP был скомпилирован с опцией
   <option role="configure">--with-readline</option>.
   Начиная с PHP PHP 7.1.0, интерактивная консоль также доступна на Windows, если
   <link linkend="book.readline">модуль readline</link> включён.
  </para>

  <para>
   Используя интерактивную консоль, можно ввести и выполнить
   непосредственно PHP-код.
  </para>

  <example>
   <title>Запуск кода в интерактивной консоли</title>
   <programlisting role="shell">
<![CDATA[
$ php -a
Interactive shell

php > echo 5+8;
13
php > function addTwo($n)
php > {
php { return $n + 2;
php { }
php > var_dump(addtwo(2));
int(4)
php >
]]>
   </programlisting>
  </example>

  <para>
   Интерактивная консоль также автодополняет (с помощью клавиши Tab)
   имена функций, констант, классов, переменных, вызовы
   статических методов и константы классов.
  </para>

  <example>
   <title>Автодополнение по Tab</title>
   <simpara>
    Двойное нажатие клавиши Tab при наличии нескольких вариантов
    дополнения покажет список этих вариантов:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > strp[TAB][TAB]
strpbrk   strpos    strptime
php > strp
]]>
   </programlisting>
   <simpara>
    Когда есть только одно дополнение, одиночное нажатие
    Tab дополнит оставшийся текст на той же самой строке:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > strpt[TAB]ime(
]]>
   </programlisting>
   <simpara>
    Дополнение также работает для имён, которые были объявлены
    в течение данной интерактивной сессии:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > $fooThisIsAReallyLongVariableName = 42;
php > $foo[TAB]ThisIsAReallyLongVariableName
]]>
   </programlisting>
  </example>

  <para>
   Интерактивная консоль хранит историю команд, для доступа к которой
   можно использовать стрелки вверх и вниз.
   История хранится в файле <filename>~/.php_history</filename>.
  </para>

  <para>
   Модуль &cli.sapi; предоставляет
   две новые настройки в &php.ini;: <parameter>cli.pager</parameter> и
   <parameter>cli.prompt</parameter>. Настройка <parameter>cli.pager</parameter>
   позволяет использовать внешнюю программу (такую как <filename>less</filename>)
   для постраничного просмотра данных вместо их прямого вывода на экран.
   Настройка <parameter>cli.prompt</parameter> позволяет задавать
   приглашение <literal>php &gt;</literal> на ввод команды.
  </para>

  <para>
   Также можно устанавливать настройки &php.ini; в интерактивной
   консоли, используя специальное сокращение.
  </para>

  <example>
   <title>Установка настройки &php.ini; в интерактивной консоли</title>
   <simpara>
    Настройка <parameter>cli.prompt</parameter>:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > #cli.prompt=hello world :>
hello world :>
]]>
   </programlisting>
   <simpara>
    Используя обратные апострофы можно задать PHP-код, который
    выполнится в приглашении на ввод команды:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > #cli.prompt=`echo date('H:i:s');` php >
15:49:35 php > echo 'hi';
hi
15:49:43 php > sleep(2);
15:49:45 php >
]]>
   </programlisting>
   <simpara>
    Установка <filename>less</filename> для постраничного вывода данных:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > #cli.pager=less
php > phpinfo();
(output displayed in less)
php >
]]>
   </programlisting>
  </example>

  <para>
   Настройка <parameter>cli.prompt</parameter> поддерживает
   несколько управляющих последовательностей:
   <table>
    <title>Управляющие последовательности <parameter>cli.prompt</parameter></title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Управляющая последовательность</entry>
       <entry>Описание</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>\e</literal></entry>
       <entry>
        Используется для добавления цветов в приглашение на ввод команды.
        Пример: <literal>\e[032m\v \e[031m\b \e[34m\> \e[0m</literal>
       </entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>Версия PHP.</entry>
      </row>
      <row>
       <entry><literal>\b</literal></entry>
       <entry>
        Отображает в какой части PHP мы находимся. Для примера <literal>/*</literal>
        показывает, что мы находимся в многострочном комментарии. Внешняя область
        видимости обозначается как <literal>php</literal>.
       </entry>
      </row>
      <row>
       <entry><literal>\&gt;</literal></entry>
       <entry>
        Указывает символ приглашения. По умолчанию это символ <literal>&gt;</literal>,
        но можно изменить, когда оболочка находится внутри незакрытого блока или строки.
        Возможные символы: <literal>' " { ( &gt;</literal>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>

  <note>
   <para>
    Файлы, подключённые с помощью опций
    <link linkend="ini.auto-prepend-file">auto_prepend_file</link> и
    <link linkend="ini.auto-append-file">auto_append_file</link>
    обрабатываются в этом режиме с некоторыми ограничениями,
    например, функции должны быть объявлены до их использования.
   </para>
  </note>
 </section>
 <!--}}}-->

 <!--Built-in CLI Web Server: {{{-->
 <section xml:id="features.commandline.webserver">
  <title>Встроенный веб-сервер</title>

  <warning>
   <para>
    Веб-сервер предназначен для помощи в разработке приложений. Он также может
    быть полезным в тестовых целях или для демонстрации приложения, запускаемого
    в полностью контролируемом окружении. Он не выполняет функции полноценного
    веб-сервера и не должен использоваться в общедоступных сетях.
   </para>
  </warning>

  <para>
   Модуль &cli.sapi; содержит встроенный веб-сервер.
  </para>

  <para>
   Веб-сервер выполняет только один однопоточный процесс, поэтому приложения PHP
   будут останавливаться, если запрос заблокирован.
  </para>

  <para>
   URI запросы обслуживаются из текущей директории, в которой был запущен PHP,
   если не используется опция -t для явного указания корневого документа.
   Если URI запроса не указывает на определённый файл, то будет возвращён
   index.php или index.html в указанной директории. Если ни один из файлов не существует,
   то поиск этих файлов будет продолжен в родительской директории и так далее до тех пор,
   пока они не будут найдены или был достигнут корень документа. Если найден
   index.php или index.html, он возвращается, а в $_SERVER['PATH_INFO'] будет
   находится последняя часть URL. В противном случае возвращается 404 код ответа.
  </para>

  <para>
   Если PHP-файл указывается в командной строке, когда запускается веб-сервер,
   то он рассматривается как скрипт "маршрутизации" (router). Скрипт выполняется
   в самом начале каждого HTTP-запроса. Если этот скрипт возвращает
   &false;, то запрашиваемый ресурс возвращается как есть.
   В противном случае браузеру будет возвращён вывод этого скрипта.
  </para>

  <para>
   Стандартные MIME-типы возвращаются для файлов со следующими расширениями: .3gp,
   .apk, .avi, .bmp, .css, .csv, .doc, .docx, .flac, .gif, .gz,
   .gzip, .htm, .html, .ics, .jpe, .jpeg, .jpg, .js, .kml, .kmz,
   .m4a, .mov, .mp3, .mp4, .mpeg, .mpg, .odp, .ods, .odt, .oga, .ogg,
   .ogv, .pdf, .pdf, .png, .pps, .pptx, .qt, .svg, .swf, .tar, .text,
   .tif, .txt, .wav, .webm, .wmv, .xls, .xlsx, .xml, .xsl, .xsd и .zip.
  </para>

  <table>
   <title>История правок: Поддерживаемые MIME-типы (расширения файлов)</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>&Version;</entry>
      <entry>&Description;</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>5.5.12</entry>
      <entry>
       .xml, .xsl, и .xsd
      </entry>
     </row>
     <row>
      <entry>5.5.7</entry>
      <entry>
       .3gp, .apk, .avi, .bmp, .csv, .doc, .docx, .flac, .gz, .gzip,
       .ics, .kml, .kmz, .m4a, .mp3, .mp4, .mpg, .mpeg, .mov, .odp, .ods,
       .odt, .oga, .pdf, .pptx, .pps, .qt, .swf, .tar, .text, .tif, .wav,
       .wmv, .xls, .xlsx и .zip
      </entry>
     </row>
     <row>
      <entry>5.5.5</entry>
      <entry>
       .pdf
      </entry>
     </row>
     <row>
      <entry>5.4.11</entry>
      <entry>
       .ogg, .ogv, и .webm
      </entry>
     </row>
     <row>
      <entry>5.4.4</entry>
      <entry>
       .htm и .svg
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table>
   <title>История изменений</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>&Version;</entry>
      <entry>&Description;</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>7.4.0</entry>
      <entry>
       Вы можете настроить встроенный веб-сервер так, чтобы он выполнял разветвление нескольких воркеров
       для проверки кода, который требует нескольких одновременных запросов
       к встроенному веб-серверу. Задайте в переменной окружения
       <envar>PHP_CLI_SERVER_WORKERS</envar>
       количество требуемых воркеров перед запуском
       сервера.
       Не поддерживается в Windows.
       <warning>
        <para>
         Эта <emphasis>экспериментальная</emphasis> функция <emphasis>не </emphasis>
         предназначена для продакшен использования. Обычно встроенный веб-сервер
         <emphasis>не</emphasis> предназначен для продакшен использования.
        </para>
       </warning>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <example>
   <title>Запуск веб-сервера</title>
   <programlisting role="shell">
<![CDATA[
$ cd ~/public_html
$ php -S localhost:8000
]]>
   </programlisting>
   <para>
    В консоли выведется:
   </para>
   <screen>
<![CDATA[
PHP 5.4.0 Development Server started at Thu Jul 21 10:43:28 2011
Listening on localhost:8000
Document root is /home/me/public_html
Press Ctrl-C to quit
]]>
   </screen>
   <para>
    После URI-запросов http://localhost:8000/ и http://localhost:8000/myscript.html
    в консоли выведется примерно следующее:
   </para>
   <screen>
<![CDATA[
PHP 5.4.0 Development Server started at Thu Jul 21 10:43:28 2011
Listening on localhost:8000
Document root is /home/me/public_html
Press Ctrl-C to quit.
[Thu Jul 21 10:48:48 2011] ::1:39144 GET /favicon.ico - Request read
[Thu Jul 21 10:48:50 2011] ::1:39146 GET / - Request read
[Thu Jul 21 10:48:50 2011] ::1:39147 GET /favicon.ico - Request read
[Thu Jul 21 10:48:52 2011] ::1:39148 GET /myscript.html - Request read
[Thu Jul 21 10:48:52 2011] ::1:39149 GET /favicon.ico - Request read
]]>
   </screen>
   <para>
    Обратите внимание, что до PHP 7.4.0 статические ресурсы с символическими ссылками не были доступны в Windows, если только скрипт маршрутизатора не обработал бы их.
   </para>
  </example>

  <example>
   <title>Запуск с указанием корневой директории</title>
   <programlisting role="shell">
<![CDATA[
$ cd ~/public_html
$ php -S localhost:8000 -t foo/
]]>
   </programlisting>
   <para>
    В консоли выведется:
   </para>
   <screen>
<![CDATA[
PHP 5.4.0 Development Server started at Thu Jul 21 10:50:26 2011
Listening on localhost:8000
Document root is /home/me/public_html/foo
Press Ctrl-C to quit
]]>
   </screen>
  </example>

  <example>
   <title>Использование скрипта маршрутизации</title>
   <para>
    В этом примере, запросы изображений будут отображать их, но запросы HTML-файлов
    будут возвращать "Добро пожаловать в PHP".
   </para>
   <programlisting role="php">
<![CDATA[
<?php
// router.php
if (preg_match('/\.(?:png|jpg|jpeg|gif)$/', $_SERVER["REQUEST_URI"])) {
    return false;    // сервер возвращает файлы напрямую.
} else {
    echo "<p>Добро пожаловать в PHP</p>";
}
?>]]>
   </programlisting>
   <programlisting role="shell">
<![CDATA[
$ php -S localhost:8000 router.php
]]>
   </programlisting>
   <warning>
    <para>
     Встроенный веб-сервер не должен использоваться в общедоступной сети.
    </para>
   </warning>
  </example>

  <example>
   <title>Проверка использования веб-сервера CLI</title>
   <para>
    Для совместного использования скрипта маршрутизации при разработке с
    веб-сервером CLI и в дальнейшем с рабочим (production) веб-сервером:
   </para>
   <programlisting role="php">
<![CDATA[
<?php
// router.php
if (php_sapi_name() == 'cli-server') {
    /* Маршрутизация с заданными правилами и возврат false */
}
/* продолжение с обычными операциями index.php */
?>]]>
   </programlisting>
   <programlisting role="shell">
<![CDATA[
$ php -S localhost:8000 router.php
]]>
   </programlisting>
  </example>

  <example>
   <title>Поддержка неподдерживаемых типов файлов</title>
   <para>
    Если вам нужно обслуживать статические ресурсы с MIME-типами, неподдерживаемыми
    веб-сервером CLI, используйте это:
   </para>
   <programlisting role="php">
<![CDATA[
<?php
// router.php
$path = pathinfo($_SERVER["SCRIPT_FILENAME"]);
if ($path["extension"] == "el") {
    header("Content-Type: text/x-script.elisp");
    readfile($_SERVER["SCRIPT_FILENAME"]);
}
else {
    return FALSE;
}
?>]]>
   </programlisting>
   <programlisting role="shell">
<![CDATA[
$ php -S localhost:8000 router.php
]]>
   </programlisting>
  </example>

  <example>
   <title>Доступ к веб-серверу CLI с удалённых машин</title>
   <para>
    Вы можете сделать веб-сервер доступным на 8000 порту для всех сетевых интерфейсов:
   </para>
   <programlisting role="shell">
<![CDATA[
$ php -S 0.0.0.0:8000
]]>
   </programlisting>
  </example>

 </section>
 <!--}}}-->

 <section xml:id="features.commandline.ini">
  <title>Опции конфигурации</title>
  <para>
   <table>
    <title>Опции конфигурации CLI SAPI</title>
    <tgroup cols="4">
     <thead>
      <row>
       <entry>&Name;</entry>
       <entry>&Default;</entry>
       <entry>&Changeable;</entry>
       <entry>&Changelog;</entry>
      </row>
     </thead>
     <tbody xml:id="features.commandline.ini.list">
      <row>
       <entry><link linkend="ini.cli-server.color">cli_server.color</link></entry>
       <entry>"0"</entry>
       <entry>PHP_INI_ALL</entry>
       <entry></entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>

  &ini.descriptions.title;

  <para>
   <variablelist>
    <varlistentry xml:id="ini.cli-server.color">
     <term>
      <parameter>cli_server.color</parameter>
      <type>bool</type>
     </term>
     <listitem>
      <para>
       Включает поддержку цветовых кодов ANSI в выводе терминала
       встроенного веб-сервера.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </section>

</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=marker fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
